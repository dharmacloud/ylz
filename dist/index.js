
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
	'use strict';

	/** @returns {void} */ function noop() {}
	/**
	 * @template T
	 * @template S
	 * @param {T} tar
	 * @param {S} src
	 * @returns {T & S}
	 */ function assign(tar, src) {
	    // @ts-ignore
	    for(const k in src)tar[k] = src[k];
	    return /** @type {T & S} */ tar;
	}
	/** @returns {void} */ function add_location(element, file, line, column, char) {
	    element.__svelte_meta = {
	        loc: {
	            file,
	            line,
	            column,
	            char
	        }
	    };
	}
	function run(fn) {
	    return fn();
	}
	function blank_object() {
	    return Object.create(null);
	}
	/**
	 * @param {Function[]} fns
	 * @returns {void}
	 */ function run_all(fns) {
	    fns.forEach(run);
	}
	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */ function is_function(thing) {
	    return typeof thing === 'function';
	}
	/** @returns {boolean} */ function safe_not_equal(a, b) {
	    return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
	}
	let src_url_equal_anchor;
	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */ function src_url_equal(element_src, url) {
	    if (element_src === url) return true;
	    if (!src_url_equal_anchor) {
	        src_url_equal_anchor = document.createElement('a');
	    }
	    // This is actually faster than doing URL(..).href
	    src_url_equal_anchor.href = url;
	    return element_src === src_url_equal_anchor.href;
	}
	/** @returns {boolean} */ function is_empty(obj) {
	    return Object.keys(obj).length === 0;
	}
	/** @returns {void} */ function validate_store(store, name) {
	    if (store != null && typeof store.subscribe !== 'function') {
	        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
	    }
	}
	function subscribe(store, ...callbacks) {
	    if (store == null) {
	        for (const callback of callbacks){
	            callback(undefined);
	        }
	        return noop;
	    }
	    const unsub = store.subscribe(...callbacks);
	    return unsub.unsubscribe ? ()=>unsub.unsubscribe() : unsub;
	}
	/**
	 * Get the current value from a store by subscribing and immediately unsubscribing.
	 *
	 * https://svelte.dev/docs/svelte-store#get
	 * @template T
	 * @param {import('../store/public.js').Readable<T>} store
	 * @returns {T}
	 */ function get_store_value(store) {
	    let value;
	    subscribe(store, (_)=>value = _)();
	    return value;
	}
	/** @returns {void} */ function component_subscribe(component, store, callback) {
	    component.$$.on_destroy.push(subscribe(store, callback));
	}
	function create_slot(definition, ctx, $$scope, fn) {
	    if (definition) {
	        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
	        return definition[0](slot_ctx);
	    }
	}
	function get_slot_context(definition, ctx, $$scope, fn) {
	    return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
	}
	function get_slot_changes(definition, $$scope, dirty, fn) {
	    if (definition[2] && fn) {
	        const lets = definition[2](fn(dirty));
	        if ($$scope.dirty === undefined) {
	            return lets;
	        }
	        if (typeof lets === 'object') {
	            const merged = [];
	            const len = Math.max($$scope.dirty.length, lets.length);
	            for(let i = 0; i < len; i += 1){
	                merged[i] = $$scope.dirty[i] | lets[i];
	            }
	            return merged;
	        }
	        return $$scope.dirty | lets;
	    }
	    return $$scope.dirty;
	}
	/** @returns {void} */ function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
	    if (slot_changes) {
	        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
	        slot.p(slot_context, slot_changes);
	    }
	}
	/** @returns {any[] | -1} */ function get_all_dirty_from_scope($$scope) {
	    if ($$scope.ctx.length > 32) {
	        const dirty = [];
	        const length = $$scope.ctx.length / 32;
	        for(let i = 0; i < length; i++){
	            dirty[i] = -1;
	        }
	        return dirty;
	    }
	    return -1;
	}
	function action_destroyer(action_result) {
	    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
	}

	/** @type {typeof globalThis} */ const globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : global;

	function _define_property$d(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */ function append(target, node) {
	    target.appendChild(node);
	}
	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */ function insert(target, node, anchor) {
	    target.insertBefore(node, anchor || null);
	}
	/**
	 * @param {Node} node
	 * @returns {void}
	 */ function detach(node) {
	    if (node.parentNode) {
	        node.parentNode.removeChild(node);
	    }
	}
	/**
	 * @returns {void} */ function destroy_each(iterations, detaching) {
	    for(let i = 0; i < iterations.length; i += 1){
	        if (iterations[i]) iterations[i].d(detaching);
	    }
	}
	/**
	 * @template {keyof HTMLElementTagNameMap} K
	 * @param {K} name
	 * @returns {HTMLElementTagNameMap[K]}
	 */ function element(name) {
	    return document.createElement(name);
	}
	/**
	 * @template {keyof SVGElementTagNameMap} K
	 * @param {K} name
	 * @returns {SVGElement}
	 */ function svg_element(name) {
	    return document.createElementNS('http://www.w3.org/2000/svg', name);
	}
	/**
	 * @param {string} data
	 * @returns {Text}
	 */ function text(data) {
	    return document.createTextNode(data);
	}
	/**
	 * @returns {Text} */ function space() {
	    return text(' ');
	}
	/**
	 * @returns {Text} */ function empty() {
	    return text('');
	}
	/**
	 * @param {EventTarget} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @returns {() => void}
	 */ function listen(node, event, handler, options) {
	    node.addEventListener(event, handler, options);
	    return ()=>node.removeEventListener(event, handler, options);
	}
	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */ function attr(node, attribute, value) {
	    if (value == null) node.removeAttribute(attribute);
	    else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}
	/**
	 * @param {HTMLInputElement[]} group
	 * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}
	 */ function init_binding_group(group) {
	    /**
		 * @type {HTMLInputElement[]} */ let _inputs;
	    return {
	        /* push */ p (...inputs) {
	            _inputs = inputs;
	            _inputs.forEach((input)=>group.push(input));
	        },
	        /* remove */ r () {
	            _inputs.forEach((input)=>group.splice(group.indexOf(input), 1));
	        }
	    };
	}
	/**
	 * @param {Element} element
	 * @returns {ChildNode[]}
	 */ function children(element) {
	    return Array.from(element.childNodes);
	}
	/**
	 * @returns {void} */ function set_input_value(input, value) {
	    input.value = value == null ? '' : value;
	}
	/**
	 * @returns {void} */ function set_style(node, key, value, important) {
	    if (value == null) {
	        node.style.removeProperty(key);
	    } else {
	        node.style.setProperty(key, value, important ? 'important' : '');
	    }
	}
	// unfortunately this can't be a constant as that wouldn't be tree-shakeable
	// so we cache the result instead
	/**
	 * @type {boolean} */ let crossorigin;
	/**
	 * @returns {boolean} */ function is_crossorigin() {
	    if (crossorigin === undefined) {
	        crossorigin = false;
	        try {
	            if (typeof window !== 'undefined' && window.parent) {
	                void window.parent.document;
	            }
	        } catch (error) {
	            crossorigin = true;
	        }
	    }
	    return crossorigin;
	}
	/**
	 * @param {HTMLElement} node
	 * @param {() => void} fn
	 * @returns {() => void}
	 */ function add_iframe_resize_listener(node, fn) {
	    const computed_style = getComputedStyle(node);
	    if (computed_style.position === 'static') {
	        node.style.position = 'relative';
	    }
	    const iframe = element('iframe');
	    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' + 'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
	    iframe.setAttribute('aria-hidden', 'true');
	    iframe.tabIndex = -1;
	    const crossorigin = is_crossorigin();
	    /**
		 * @type {() => void}
		 */ let unsubscribe;
	    if (crossorigin) {
	        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
	        unsubscribe = listen(window, 'message', /** @param {MessageEvent} event */ (event)=>{
	            if (event.source === iframe.contentWindow) fn();
	        });
	    } else {
	        iframe.src = 'about:blank';
	        iframe.onload = ()=>{
	            unsubscribe = listen(iframe.contentWindow, 'resize', fn);
	            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)
	            // see https://github.com/sveltejs/svelte/issues/4233
	            fn();
	        };
	    }
	    append(node, iframe);
	    return ()=>{
	        if (crossorigin) {
	            unsubscribe();
	        } else if (unsubscribe && iframe.contentWindow) {
	            unsubscribe();
	        }
	        detach(iframe);
	    };
	}
	/**
	 * @returns {void} */ function toggle_class(element, name, toggle) {
	    // The `!!` is required because an `undefined` flag means flipping the current state.
	    element.classList.toggle(name, !!toggle);
	}
	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
	 * @returns {CustomEvent<T>}
	 */ function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
	    return new CustomEvent(type, {
	        detail,
	        bubbles,
	        cancelable
	    });
	}
	/** */ class HtmlTag {
	    /**
		 * @param {string} html
		 * @returns {void}
		 */ c(html) {
	        this.h(html);
	    }
	    /**
		 * @param {string} html
		 * @param {HTMLElement | SVGElement} target
		 * @param {HTMLElement | SVGElement} anchor
		 * @returns {void}
		 */ m(html, target, anchor = null) {
	        if (!this.e) {
	            if (this.is_svg) this.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ target.nodeName);
	            else this.e = element(/** @type {keyof HTMLElementTagNameMap} */ target.nodeType === 11 ? 'TEMPLATE' : target.nodeName);
	            this.t = target.tagName !== 'TEMPLATE' ? target : /** @type {HTMLTemplateElement} */ target.content;
	            this.c(html);
	        }
	        this.i(anchor);
	    }
	    /**
		 * @param {string} html
		 * @returns {void}
		 */ h(html) {
	        this.e.innerHTML = html;
	        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);
	    }
	    /**
		 * @returns {void} */ i(anchor) {
	        for(let i = 0; i < this.n.length; i += 1){
	            insert(this.t, this.n[i], anchor);
	        }
	    }
	    /**
		 * @param {string} html
		 * @returns {void}
		 */ p(html) {
	        this.d();
	        this.h(html);
	        this.i(this.a);
	    }
	    /**
		 * @returns {void} */ d() {
	        this.n.forEach(detach);
	    }
	    constructor(is_svg = false){
	        /**
		 * @private
		 * @default false
		 */ _define_property$d(this, "is_svg", false);
	        /** parent for creating node */ _define_property$d(this, "e", undefined);
	        /** html tag nodes */ _define_property$d(this, "n", undefined);
	        /** target */ _define_property$d(this, "t", undefined);
	        /** anchor */ _define_property$d(this, "a", undefined);
	        this.is_svg = is_svg;
	        this.e = this.n = null;
	    }
	}

	let current_component;
	/** @returns {void} */ function set_current_component(component) {
	    current_component = component;
	}
	function get_current_component() {
	    if (!current_component) throw new Error('Function called outside component initialization');
	    return current_component;
	}
	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).
	 *
	 * https://svelte.dev/docs/svelte#onmount
	 * @template T
	 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */ function onMount(fn) {
	    get_current_component().$$.on_mount.push(fn);
	}
	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * https://svelte.dev/docs/svelte#ondestroy
	 * @param {() => any} fn
	 * @returns {void}
	 */ function onDestroy(fn) {
	    get_current_component().$$.on_destroy.push(fn);
	}
	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * https://svelte.dev/docs/svelte#createeventdispatcher
	 * @template {Record<string, any>} [EventMap=any]
	 * @returns {import('./public.js').EventDispatcher<EventMap>}
	 */ function createEventDispatcher() {
	    const component = get_current_component();
	    return (type, detail, { cancelable = false } = {})=>{
	        const callbacks = component.$$.callbacks[type];
	        if (callbacks) {
	            // TODO are there situations where events could be dispatched
	            // in a server (non-DOM) environment?
	            const event = custom_event(/** @type {string} */ type, detail, {
	                cancelable
	            });
	            callbacks.slice().forEach((fn)=>{
	                fn.call(component, event);
	            });
	            return !event.defaultPrevented;
	        }
	        return true;
	    };
	}

	const dirty_components = [];
	const binding_callbacks = [];
	let render_callbacks = [];
	const flush_callbacks = [];
	const resolved_promise = /* @__PURE__ */ Promise.resolve();
	let update_scheduled = false;
	/** @returns {void} */ function schedule_update() {
	    if (!update_scheduled) {
	        update_scheduled = true;
	        resolved_promise.then(flush);
	    }
	}
	/** @returns {void} */ function add_render_callback(fn) {
	    render_callbacks.push(fn);
	}
	/** @returns {void} */ function add_flush_callback(fn) {
	    flush_callbacks.push(fn);
	}
	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();
	let flushidx = 0; // Do *not* move this inside the flush() function
	/** @returns {void} */ function flush() {
	    // Do not reenter flush while dirty components are updated, as this can
	    // result in an infinite loop. Instead, let the inner flush handle it.
	    // Reentrancy is ok afterwards for bindings etc.
	    if (flushidx !== 0) {
	        return;
	    }
	    const saved_component = current_component;
	    do {
	        // first, call beforeUpdate functions
	        // and update components
	        try {
	            while(flushidx < dirty_components.length){
	                const component = dirty_components[flushidx];
	                flushidx++;
	                set_current_component(component);
	                update(component.$$);
	            }
	        } catch (e) {
	            // reset dirty state to not end up in a deadlocked state and then rethrow
	            dirty_components.length = 0;
	            flushidx = 0;
	            throw e;
	        }
	        set_current_component(null);
	        dirty_components.length = 0;
	        flushidx = 0;
	        while(binding_callbacks.length)binding_callbacks.pop()();
	        // then, once components are updated, call
	        // afterUpdate functions. This may cause
	        // subsequent updates...
	        for(let i = 0; i < render_callbacks.length; i += 1){
	            const callback = render_callbacks[i];
	            if (!seen_callbacks.has(callback)) {
	                // ...so guard against infinite loops
	                seen_callbacks.add(callback);
	                callback();
	            }
	        }
	        render_callbacks.length = 0;
	    }while (dirty_components.length)
	    while(flush_callbacks.length){
	        flush_callbacks.pop()();
	    }
	    update_scheduled = false;
	    seen_callbacks.clear();
	    set_current_component(saved_component);
	}
	/** @returns {void} */ function update($$) {
	    if ($$.fragment !== null) {
	        $$.update();
	        run_all($$.before_update);
	        const dirty = $$.dirty;
	        $$.dirty = [
	            -1
	        ];
	        $$.fragment && $$.fragment.p($$.ctx, dirty);
	        $$.after_update.forEach(add_render_callback);
	    }
	}
	/**
	 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
	 * @param {Function[]} fns
	 * @returns {void}
	 */ function flush_render_callbacks(fns) {
	    const filtered = [];
	    const targets = [];
	    render_callbacks.forEach((c)=>fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
	    targets.forEach((c)=>c());
	    render_callbacks = filtered;
	}

	const outroing = new Set();
	/**
	 * @type {Outro}
	 */ let outros;
	/**
	 * @returns {void} */ function group_outros() {
	    outros = {
	        r: 0,
	        c: [],
	        p: outros // parent group
	    };
	}
	/**
	 * @returns {void} */ function check_outros() {
	    if (!outros.r) {
	        run_all(outros.c);
	    }
	    outros = outros.p;
	}
	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} [local]
	 * @returns {void}
	 */ function transition_in(block, local) {
	    if (block && block.i) {
	        outroing.delete(block);
	        block.i(local);
	    }
	}
	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} local
	 * @param {0 | 1} [detach]
	 * @param {() => void} [callback]
	 * @returns {void}
	 */ function transition_out(block, local, detach, callback) {
	    if (block && block.o) {
	        if (outroing.has(block)) return;
	        outroing.add(block);
	        outros.c.push(()=>{
	            outroing.delete(block);
	            if (callback) {
	                if (detach) block.d(1);
	                callback();
	            }
	        });
	        block.o(local);
	    } else if (callback) {
	        callback();
	    }
	}

	// general each functions:
	function ensure_array_like(array_like_or_iterator) {
	    return (array_like_or_iterator === null || array_like_or_iterator === void 0 ? void 0 : array_like_or_iterator.length) !== undefined ? array_like_or_iterator : Array.from(array_like_or_iterator);
	}

	/** @returns {{}} */ function get_spread_update(levels, updates) {
	    const update = {};
	    const to_null_out = {};
	    const accounted_for = {
	        $$scope: 1
	    };
	    let i = levels.length;
	    while(i--){
	        const o = levels[i];
	        const n = updates[i];
	        if (n) {
	            for(const key in o){
	                if (!(key in n)) to_null_out[key] = 1;
	            }
	            for(const key in n){
	                if (!accounted_for[key]) {
	                    update[key] = n[key];
	                    accounted_for[key] = 1;
	                }
	            }
	            levels[i] = n;
	        } else {
	            for(const key in o){
	                accounted_for[key] = 1;
	            }
	        }
	    }
	    for(const key in to_null_out){
	        if (!(key in update)) update[key] = undefined;
	    }
	    return update;
	}
	function get_spread_object(spread_props) {
	    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
	}

	function _define_property$c(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	/** @returns {void} */ function bind(component, name, callback) {
	    const index = component.$$.props[name];
	    if (index !== undefined) {
	        component.$$.bound[index] = callback;
	        callback(component.$$.ctx[index]);
	    }
	}
	/** @returns {void} */ function create_component(block) {
	    block && block.c();
	}
	/** @returns {void} */ function mount_component(component, target, anchor) {
	    const { fragment, after_update } = component.$$;
	    fragment && fragment.m(target, anchor);
	    // onMount happens before the initial afterUpdate
	    add_render_callback(()=>{
	        const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
	        // if the component was destroyed immediately
	        // it will update the `$$.on_destroy` reference to `null`.
	        // the destructured on_destroy may still reference to the old array
	        if (component.$$.on_destroy) {
	            component.$$.on_destroy.push(...new_on_destroy);
	        } else {
	            // Edge case - component was destroyed immediately,
	            // most likely as a result of a binding initialising
	            run_all(new_on_destroy);
	        }
	        component.$$.on_mount = [];
	    });
	    after_update.forEach(add_render_callback);
	}
	/** @returns {void} */ function destroy_component(component, detaching) {
	    const $$ = component.$$;
	    if ($$.fragment !== null) {
	        flush_render_callbacks($$.after_update);
	        run_all($$.on_destroy);
	        $$.fragment && $$.fragment.d(detaching);
	        // TODO null out other refs, including component.$$ (but need to
	        // preserve final state?)
	        $$.on_destroy = $$.fragment = null;
	        $$.ctx = [];
	    }
	}
	/** @returns {void} */ function make_dirty(component, i) {
	    if (component.$$.dirty[0] === -1) {
	        dirty_components.push(component);
	        schedule_update();
	        component.$$.dirty.fill(0);
	    }
	    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
	}
	// TODO: Document the other params
	/**
	 * @param {SvelteComponent} component
	 * @param {import('./public.js').ComponentConstructorOptions} options
	 *
	 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
	 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
	 * This will be the `add_css` function from the compiled component.
	 *
	 * @returns {void}
	 */ function init(component, options, instance, create_fragment, not_equal, props, append_styles = null, dirty = [
	    -1
	]) {
	    const parent_component = current_component;
	    set_current_component(component);
	    /** @type {import('./private.js').T$$} */ const $$ = component.$$ = {
	        fragment: null,
	        ctx: [],
	        // state
	        props,
	        update: noop,
	        not_equal,
	        bound: blank_object(),
	        // lifecycle
	        on_mount: [],
	        on_destroy: [],
	        on_disconnect: [],
	        before_update: [],
	        after_update: [],
	        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
	        // everything else
	        callbacks: blank_object(),
	        dirty,
	        skip_bound: false,
	        root: options.target || parent_component.$$.root
	    };
	    append_styles && append_styles($$.root);
	    let ready = false;
	    $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest)=>{
	        const value = rest.length ? rest[0] : ret;
	        if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
	            if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
	            if (ready) make_dirty(component, i);
	        }
	        return ret;
	    }) : [];
	    $$.update();
	    ready = true;
	    run_all($$.before_update);
	    // `false` as a special case of no DOM component
	    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	    if (options.target) {
	        if (options.hydrate) {
	            // TODO: what is the correct type here?
	            // @ts-expect-error
	            const nodes = children(options.target);
	            $$.fragment && $$.fragment.l(nodes);
	            nodes.forEach(detach);
	        } else {
	            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	            $$.fragment && $$.fragment.c();
	        }
	        if (options.intro) transition_in(component.$$.fragment);
	        mount_component(component, options.target, options.anchor);
	        flush();
	    }
	    set_current_component(parent_component);
	}
	/**
	 * Base class for Svelte components. Used when dev=false.
	 *
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 */ class SvelteComponent {
	    /** @returns {void} */ $destroy() {
	        destroy_component(this, 1);
	        this.$destroy = noop;
	    }
	    /**
		 * @template {Extract<keyof Events, string>} K
		 * @param {K} type
		 * @param {((e: Events[K]) => void) | null | undefined} callback
		 * @returns {() => void}
		 */ $on(type, callback) {
	        if (!is_function(callback)) {
	            return noop;
	        }
	        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
	        callbacks.push(callback);
	        return ()=>{
	            const index = callbacks.indexOf(callback);
	            if (index !== -1) callbacks.splice(index, 1);
	        };
	    }
	    /**
		 * @param {Partial<Props>} props
		 * @returns {void}
		 */ $set(props) {
	        if (this.$$set && !is_empty(props)) {
	            this.$$.skip_bound = true;
	            this.$$set(props);
	            this.$$.skip_bound = false;
	        }
	    }
	    constructor(){
	        /**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */ _define_property$c(this, "$$", undefined);
	        /**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */ _define_property$c(this, "$$set", undefined);
	    }
	} /**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	// generated during release, do not modify
	/**
	 * The current version, as set in package.json.
	 *
	 * https://svelte.dev/docs/svelte-compiler#svelte-version
	 * @type {string}
	 */ const VERSION = '4.2.19';
	const PUBLIC_VERSION = '4';

	function _define_property$b(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @returns {void}
	 */ function dispatch_dev(type, detail) {
	    document.dispatchEvent(custom_event(type, {
	        version: VERSION,
	        ...detail
	    }, {
	        bubbles: true
	    }));
	}
	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */ function append_dev(target, node) {
	    dispatch_dev('SvelteDOMInsert', {
	        target,
	        node
	    });
	    append(target, node);
	}
	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */ function insert_dev(target, node, anchor) {
	    dispatch_dev('SvelteDOMInsert', {
	        target,
	        node,
	        anchor
	    });
	    insert(target, node, anchor);
	}
	/**
	 * @param {Node} node
	 * @returns {void}
	 */ function detach_dev(node) {
	    dispatch_dev('SvelteDOMRemove', {
	        node
	    });
	    detach(node);
	}
	/**
	 * @param {Node} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @param {boolean} [has_prevent_default]
	 * @param {boolean} [has_stop_propagation]
	 * @param {boolean} [has_stop_immediate_propagation]
	 * @returns {() => void}
	 */ function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
	    const modifiers = options === true ? [
	        'capture'
	    ] : options ? Array.from(Object.keys(options)) : [];
	    if (has_prevent_default) modifiers.push('preventDefault');
	    if (has_stop_propagation) modifiers.push('stopPropagation');
	    if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');
	    dispatch_dev('SvelteDOMAddEventListener', {
	        node,
	        event,
	        handler,
	        modifiers
	    });
	    const dispose = listen(node, event, handler, options);
	    return ()=>{
	        dispatch_dev('SvelteDOMRemoveEventListener', {
	            node,
	            event,
	            handler,
	            modifiers
	        });
	        dispose();
	    };
	}
	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */ function attr_dev(node, attribute, value) {
	    attr(node, attribute, value);
	    if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {
	        node,
	        attribute
	    });
	    else dispatch_dev('SvelteDOMSetAttribute', {
	        node,
	        attribute,
	        value
	    });
	}
	/**
	 * @param {Element} node
	 * @param {string} property
	 * @param {any} [value]
	 * @returns {void}
	 */ function prop_dev(node, property, value) {
	    node[property] = value;
	    dispatch_dev('SvelteDOMSetProperty', {
	        node,
	        property,
	        value
	    });
	}
	/**
	 * @param {Text} text
	 * @param {unknown} data
	 * @returns {void}
	 */ function set_data_dev(text, data) {
	    data = '' + data;
	    if (text.data === data) return;
	    dispatch_dev('SvelteDOMSetData', {
	        node: text,
	        data
	    });
	    text.data = /** @type {string} */ data;
	}
	function ensure_array_like_dev(arg) {
	    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg) && !(typeof Symbol === 'function' && arg && Symbol.iterator in arg)) {
	        throw new Error('{#each} only works with iterable values.');
	    }
	    return ensure_array_like(arg);
	}
	/**
	 * @returns {void} */ function validate_slots(name, slot, keys) {
	    for (const slot_key of Object.keys(slot)){
	        if (!~keys.indexOf(slot_key)) {
	            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
	        }
	    }
	}
	/**
	 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
	 *
	 * Can be used to create strongly typed Svelte components.
	 *
	 * #### Example:
	 *
	 * You have component library on npm called `component-library`, from which
	 * you export a component called `MyComponent`. For Svelte+TypeScript users,
	 * you want to provide typings. Therefore you create a `index.d.ts`:
	 * ```ts
	 * import { SvelteComponent } from "svelte";
	 * export class MyComponent extends SvelteComponent<{foo: string}> {}
	 * ```
	 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
	 * to provide intellisense and to use the component like this in a Svelte file
	 * with TypeScript:
	 * ```svelte
	 * <script lang="ts">
	 * 	import { MyComponent } from "component-library";
	 * </script>
	 * <MyComponent foo={'bar'} />
	 * ```
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 * @template {Record<string, any>} [Slots=any]
	 * @extends {SvelteComponent<Props, Events>}
	 */ class SvelteComponentDev extends SvelteComponent {
	    /** @returns {void} */ $destroy() {
	        super.$destroy();
	        this.$destroy = ()=>{
	            console.warn('Component was already destroyed'); // eslint-disable-line no-console
	        };
	    }
	    /** @returns {void} */ $capture_state() {}
	    /** @returns {void} */ $inject_state() {}
	    /** @param {import('./public.js').ComponentConstructorOptions<Props>} options */ constructor(options){
	        if (!options || !options.target && !options.$$inline) {
	            throw new Error("'target' is a required option");
	        }
	        super(), /**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Props}
		 */ _define_property$b(this, "$$prop_def", void 0), /**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Events}
		 */ _define_property$b(this, "$$events_def", void 0), /**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Slots}
		 */ _define_property$b(this, "$$slot_def", void 0);
	    }
	}

	if (typeof window !== 'undefined') // @ts-ignore
	(window.__svelte || (window.__svelte = {
	    v: new Set()
	})).v.add(PUBLIC_VERSION);

	const OFFTAG_REGEX_G = /\^([#@\/\.\:a-z_\-\d~]*)([<\{\[](?:\\.|.)*?[>\}\]])?/g //不含^
	;
	//export const OFFTAG_REGEX_G=/\^([a-z_]+[#@\/\.\:~a-z_\-\d]*)(\[(?:\\.|.)*?\])?/g //標記樣式
	//export const OFFTAG_REGEX=/\^([a-z_]+[#@\/\.\:~a-z_\-\d]*)(\[(?:\\.|.)*?\])?/ //標記樣式
	///export const NAMED_OFFTAG="([#@\\/\\.\\:~a-z_\\-\\d]*)(\\[(?:\\\\.|.)*?\\])?" //已知名稱的標記
	//export const OFFTAG_REGEX_SPLIT=/(\^[a-z_]+[#@\/\.\:~a-z_\-\d]*)(\[(?:\\.|.)*?\])?/ //標記樣式
	const QUOTEPREFIX = '\u001a', QUOTEPAT = /\u001a(\d+)/g; // 抽取字串的前綴，之後是序號
	const OFFTAG_NAME_ATTR = /([a-z_\:]+)(.*)/ //名稱可以含az_: ，但不可為數字
	;
	const OFFTAG_COMPACT_ID = /^([a-z\d]+[_a-z\d\-~\.]*)/; //縮式 id
	const QSTRING_REGEX_G = /"((?:\\.|.)*?)"/g //字串標式
	;
	const OFFTAG_LEADBYTE = '^';
	const FROMTILL = /^(>\d+)?(<\d+)?(:[\-\d]+)?$/;
	const PTK_FROMTILL = /^([a-z\.\d\-_]+\:)(>\d+)?(<\d+)?(:[\-\d]+)?$/;
	const PTK_ACTION_FROMTILL = /^([a-z\.\d\-_]+\:)?([^<>\d:]+[^:<>]*)(>\d+)?(<\d+)?(:[\-\d]+)?$/;
	const MIN_ABRIDGE = 8; //minimum token in abridge segment

	const CJKRanges = {
	    'BMP': [
	        0x4e00,
	        0x9fa5
	    ],
	    'SurrogageLeft': [
	        0xD800,
	        0xDBFF
	    ],
	    'SurrogageRight': [
	        0xDC00,
	        0xDFFF
	    ],
	    'ExtA': [
	        0x3400,
	        0x4dff
	    ],
	    'ExtB': [
	        0x20000,
	        0x2A6FF
	    ],
	    'ExtC': [
	        0x2A700,
	        0x2B73F
	    ],
	    'ExtD': [
	        0x2B740,
	        0x2B81F
	    ],
	    'ExtE': [
	        0x2B820,
	        0x2CEAF
	    ],
	    'ExtF': [
	        0x2CEB0,
	        0x2EBE0
	    ],
	    'ExtG': [
	        0x30000,
	        0x3134F
	    ],
	    'ExtH': [
	        0x31350,
	        0x323AF
	    ],
	    'ExtZ': [
	        0xA0000,
	        0xD47FF
	    ]
	};
	const CJKRangeName = (s)=>{
	    let cp = 0;
	    if (typeof s === 'string') {
	        const code = parseInt(s, 16);
	        if (!isNaN(code)) {
	            cp = code;
	        } else {
	            cp = s.codePointAt(0) || 0;
	        }
	    }
	    for(let rangename in CJKRanges){
	        const [from, to] = CJKRanges[rangename];
	        if (cp >= from && cp <= to) return rangename;
	    }
	};
	const isPunc = (str)=>{
	    if (!str) return false;
	    const cp = str.charCodeAt(0);
	    // console.log(cp,str,full)
	    return cp >= 0x3001 && cp <= 0x301f || cp > 0xff00 || cp >= 0xfe10 && cp <= 0xfe6b;
	};
	//EMEDITOR highlight \^([#@\/\.\:a-z_\-\d~]+)([<\(「『〔（︹︵︷【︻《〈︽︿﹁﹃﹙﹝‘“〝](?:\\.|.)*?[>\)」』〕）︺︶︸】︼》〉︾﹀﹂』﹚﹞’”〞])?
	const openBrackets = "<{[(｛「『〔（︹︵︷【︻《〈︽︿﹁﹃﹙﹝﹛‘“〝‵";
	const closeBrackets = ">}])｝」』〕）︺︶︸】︼》〉︾﹀﹂﹄﹚﹞﹜’”〞′";
	const closeBracketOf = (ch)=>{
	    if (!ch) return '';
	    const at = openBrackets.indexOf(ch.slice(0, 1));
	    if (~at) return closeBrackets[at];
	    return '';
	};
	const removeBracket = (str)=>{
	    const closebracket = closeBracketOf(str);
	    if (closebracket && str.slice(str.length - 1) == closebracket) {
	        return str.slice(1, str.length - 1);
	    }
	    return str;
	};
	const VerticalPuncs = {
	    '「': '﹁',
	    '」': '﹂',
	    '『': '﹃',
	    '』': '﹄'
	};
	const toVerticalPunc = (punc)=>{
	    return VerticalPuncs[punc] || punc;
	};

	const substrUTF32 = (str, from, n)=>{
	    if (!str || !n || n < 0) return '';
	    let i = from;
	    while(n > 0 && i < str.length){
	        if (str.codePointAt(i) > 0xffff) {
	            i++;
	        }
	        n--;
	        i++;
	    }
	    return str.slice(from, i);
	};
	const splitUTF32 = (str)=>{
	    if (!str) {
	        const empty = [];
	        return empty;
	    }
	    let i = 0;
	    const out = [];
	    while(i < str.length){
	        const code = str.codePointAt(i) || 0;
	        out.push(code);
	        i++;
	        if (code > 0xffff) i++;
	    }
	    return out;
	};
	const splitUTF32Char = (str)=>splitUTF32(str).map((cp)=>String.fromCodePoint(cp));

	const CJKWordBegin_Reg = /(^[\u2e80-\u2fd5\u3400-\u9fff\ud400-\udfff\ue000\uffff]+)/;
	const Word_tailspace_Reg = /([\dA-Za-z\u1000-\u1049\u0900-\u0963\u96f\u00c0-\u02af\u1e00-\u1faf][\dA-Za-z\u1000-\u1049\u0900-\u0963\u96f\u00c0-\u02af\u1e00-\u1faf\d]* ?)/g;
	const MAXPHRASELEN = 16;

	var TokenType = /*#__PURE__*/ function(TokenType) {
	    TokenType[TokenType["UNSEARCHABLE"] = 1] = "UNSEARCHABLE";
	    TokenType[TokenType["OFFTAG"] = 3] = "OFFTAG";
	    TokenType[TokenType["SEARCHABLE"] = 16] = "SEARCHABLE";
	    TokenType[TokenType["ROMANIZE"] = 32] = "ROMANIZE";
	    TokenType[TokenType["MYANMAR"] = 33] = "MYANMAR";
	    TokenType[TokenType["CJK"] = 48] = "CJK";
	    TokenType[TokenType["CJK_BMP"] = 49] = "CJK_BMP";
	    TokenType[TokenType["CJK_SURROGATE"] = 50] = "CJK_SURROGATE";
	    return TokenType;
	}({});
	function Token(text, choff, tkoff, type, line = 0) {
	    return {
	        text,
	        choff,
	        tkoff,
	        type
	    };
	}
	const tokenize = (text)=>{
	    const out = [];
	    let i = 0, tkoff = 0;
	    if (typeof text !== 'string') return [];
	    while(i < text.length){
	        let code = text.codePointAt(i) || 0;
	        if (code > 0xffff) {
	            const sur = String.fromCodePoint(code);
	            out.push(Token(sur, i, tkoff, 50));
	            tkoff++;
	            i += 2;
	            continue;
	        } else if (code >= 0x2000 && code <= 0xffff) {
	            const tt = code >= 2e80 && code <= 0x2fff //radical
	             || code >= 0x3041 && code <= 0x9fff //0xbmp
	             || code >= 0xd400 && code < 0xdfff //surrogates
	             || code >= 0xe000 && code < 0xfadf ? 49 : 1;
	            out.push(Token(text[i], i, tkoff, tt));
	            if (tt !== 1) tkoff++;
	            i++;
	            continue;
	        }
	        //space or alpha number
	        let s = '', prev = 0;
	        let j = i;
	        while(j < text.length && code < 0x2000){
	            s += text[j];
	            code = text.codePointAt(++j) || 0;
	        }
	        s.replace(Word_tailspace_Reg, (m, m1, offset)=>{
	            if (offset > prev) {
	                out.push(Token(s.substring(prev, offset), prev + i, tkoff, 1));
	            }
	            while(s[offset] == ' ')offset++;
	            out.push(Token(m1, i + offset, tkoff, 32));
	            tkoff++;
	            prev = offset + m.length;
	            return '';
	        });
	        if (prev < s.length) out.push(Token(s.substring(prev), prev + i, tkoff, 1));
	        i = j;
	    }
	    return out;
	};

	const jsonify = (almostJson)=>{
	    try {
	        return JSON.parse(almostJson);
	    } catch (e) {
	        almostJson = almostJson.replace(/([a-zA-Z0-9_$]+\s*):/g, '"$1":').replace(/'([^']+?)'([\s,\]\}])/g, '"$1"$2');
	        return JSON.parse(almostJson);
	    }
	};
	const chars = {
	    '[': ']',
	    '{': '}'
	};
	const any = (iteree, iterator)=>{
	    let result;
	    for(let i = 0; i < iteree.length; i++){
	        result = iterator(iteree[i], i, iteree);
	        if (result) {
	            break;
	        }
	    }
	    return result;
	};
	const extractObject = (str)=>{
	    if (str.charAt(0) !== '{') return [
	        "",
	        0
	    ];
	    let startIndex = 0;
	    let openingChar = str[startIndex];
	    let closingChar = chars[openingChar];
	    let endIndex = -1;
	    let count = 0;
	    str = str.substring(startIndex);
	    any(str, (letter, i)=>{
	        if (letter === openingChar) {
	            count++;
	        } else if (letter === closingChar) {
	            count--;
	        }
	        if (!count) {
	            endIndex = i;
	            return true;
	        }
	    });
	    if (endIndex === -1) {
	        return [
	            '',
	            0
	        ];
	    }
	    let obj = str.substring(0, endIndex + 1);
	    return [
	        obj,
	        endIndex + 1
	    ];
	};

	function _define_property$a(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	const parseCompactAttr = (str)=>{
	    const out = {}, arr = str.split(/([@#~])/);
	    while(arr.length){
	        let v = arr.shift();
	        if (v === '~') out['to'] = arr.shift();
	        else if (v === '@') out['ln'] = arr.shift(); // a pointer
	        else if (v === '#') {
	            v = arr.shift() || '';
	            const m = v.match(OFFTAG_COMPACT_ID); //id with numeric leading may omit #
	            if (m) out.id = m[1];
	        } else {
	            out.id = v;
	        }
	    }
	    return out;
	};
	const parseAttributes = (rawAttrs, compactAttr)=>{
	    let quotes = Array(); //字串抽出到quotes，方便以空白為拆分單元,
	    const getqstr = (str, withq = false)=>str.replace(QUOTEPAT, (m, qc)=>{
	            return (withq ? '"' : '') + quotes[parseInt(qc)] + (withq ? '"' : '');
	        });
	    let rawattr = rawAttrs ? rawAttrs.slice(1, rawAttrs.length - 1).replace(QSTRING_REGEX_G, (m, m1)=>{
	        quotes.push(m1);
	        return QUOTEPREFIX + (quotes.length - 1);
	    }) : '';
	    const attrarr = rawattr.split(/( +)/), attrs = {}; //至少一個空白做為屬性分隔
	    if (compactAttr) Object.assign(attrs, parseCompactAttr(compactAttr));
	    while(attrarr.length){
	        const it = attrarr.shift() || '';
	        let eq = -1, key = '';
	        if (it[0] == '~' || it[0] == '#' || it[0] == '@') {
	            key = it[0];
	            if (key == '#') key = 'id';
	            if (key == '@') key = 'ln';
	            if (key == '~') key = 'to';
	            eq = it[1] == '=' ? 1 : 0;
	        } else {
	            eq = it.indexOf('=');
	            if (eq > 0) key = it.slice(0, eq);
	        }
	        if (eq > -1) {
	            attrs[key] = getqstr(it.slice(eq + 1));
	            if (attrarr.length && !attrarr[0].trim()) attrarr.shift(); //drop the following space
	        } else {
	            if (it) attrs[it] = true;
	        }
	    }
	    return attrs;
	};
	// 剖析一個offtag,  ('a7[k=1]') 等效於 ('a7','[k=1]')
	// 接受 <a=33 b=44>(舊格式) 或 {a:33,b:44}
	const parseOfftag = (raw, rawAttrs)=>{
	    let attrs = {};
	    if (raw[0] == OFFTAG_LEADBYTE) raw = raw.slice(1);
	    if (rawAttrs) {
	        if (rawAttrs[0] !== '<' && rawAttrs[0] !== '{') {
	            //attrs.innertext=removeBracket(rawAttrs);
	            rawAttrs = '';
	        } else {
	            const at = raw.indexOf('<');
	            const at2 = raw.indexOf('{');
	            if (at2 > 0) {
	                rawAttrs = raw.slice(at);
	                raw = raw.slice(0, at);
	            } else if (at > 0) {
	                rawAttrs = raw.slice(at);
	                raw = raw.slice(0, at);
	            }
	        }
	    }
	    const o = raw.match(OFFTAG_NAME_ATTR);
	    if (!o) {
	        console.log("\ninvalid tag, raw", raw, 'attr', rawAttrs);
	        return [
	            raw,
	            {}
	        ];
	    } else {
	        let [m2, tagName, compactAttr] = o;
	        if (rawAttrs && rawAttrs.charAt(0) == '{') {
	            const attrs2 = jsonify(rawAttrs);
	            attrs = parseAttributes('', compactAttr);
	            for(let key in attrs2){
	                attrs[key] = attrs2[key];
	            }
	        } else {
	            if (compactAttr || rawAttrs) attrs = parseAttributes(rawAttrs, compactAttr);
	        }
	        return [
	            tagName,
	            attrs
	        ];
	    }
	};
	const resolveEnd = (raw, plain, tags)=>{
	    //文字型的範圍，已知原字串終點，計算正字串長度(utf16)
	    for(let i = 0; i < tags.length; i++){
	        const tag = tags[i];
	        let j = i;
	        if (tag.end > tag.start && !tag.width) {
	            while(j < tags.length && tag.end > tags[j].start)j++;
	            if (j < tags.length && tags[j].start > tag.end || j == tags.length) j--;
	            const closest = j < tags.length ? tags[j] : tag; //最接近終點的 tag
	            tag.width = tag.end - closest.start //從closest 到本tag終點之間的的正字串距離 即 原字串距離
	            ;
	            tag.width += closest.choff - tag.choff //closest 和 tag 正字串距離
	            ;
	        }
	    }
	    //數字型的範圍，已知正字串長度(offtext 標記提供以 utf32為單位)，計算原字串終點
	    for(let i = 0; i < tags.length; i++){
	        const tag = tags[i];
	        if (tag.width && tag.end == tag.start) {
	            //轉換utf32 個數為 utf16 個數
	            tag.width = substrUTF32(plain, tag.choff, tag.width).length;
	            let j = i + 1;
	            while(j < tags.length && tag.choff + tag.width > tags[j].choff)j++;
	            if (j < tags.length && tags[j].choff > tag.choff + tag.width || j == tags.length) j--;
	            const closest = j < tags.length ? tags[j] : tag;
	            //最接近終點的 tag，再無其他tag ，即正字串原字串定位相同
	            if (closest === tag) {
	                tag.end += tag.width; //到終點前無其他tag，直接加上 width 即可
	            } else {
	                tag.end = closest.start //取 closest 的原字串位置 加上
	                 + (tag.choff + tag.width - closest.choff);
	            //tag.choff+tag.width 正字串長度 - closest 的正字串座標 即 正字串個數=原字串個數
	            }
	        }
	    }
	};
	const parseOfftext = (str, line = 0)=>{
	    if (!str || str.indexOf('^') == -1) return [
	        str || '',
	        []
	    ];
	    let tags = Array();
	    let choff = 0, prevoff = 0; // choff : offset to plain text
	    let text = str.replace(OFFTAG_REGEX_G, (m, rawName, rawAttrs, offset)=>{
	        if (!rawName) {
	            if (rawAttrs && rawAttrs.startsWith('[')) {
	                const transclusiontag = {
	                    name: '',
	                    offset,
	                    aoffset: offset + 1,
	                    attrs: {},
	                    line,
	                    choff,
	                    width: 0,
	                    start: offset + 2,
	                    end: offset + rawAttrs.length,
	                    active: false
	                };
	                tags.push(transclusiontag);
	                const innertext = removeBracket(rawAttrs);
	                return innertext;
	            }
	            return '';
	        }
	        let [tagName, attrs] = parseOfftag(rawName, rawAttrs);
	        let width = 0;
	        let start = offset + m.length, end = start; //文字開始及結束
	        let endch = attrs['~'];
	        if (endch) {
	            if (isNaN(parseInt(endch))) {
	                width = 0;
	                let repeat = 0;
	                const m = endch.match(/\+(\d+)$/);
	                if (m) {
	                    endch = endch.slice(0, endch.length - m.length);
	                    repeat = parseInt(m[1]);
	                }
	                let at = str.indexOf(endch, start);
	                while(~at && repeat){
	                    at = str.indexOf(endch, at + 1);
	                    repeat--;
	                }
	                if (~at) {
	                    end = at + endch.length;
	                    delete attrs['~']; //resolved, remove it
	                }
	            } else {
	                width = parseInt(endch); //這是utf32 的個數
	            }
	        //tag.end resolveEnd 才知道
	        } else {
	            const closebracket = closeBracketOf(str.charAt(start));
	            if (closebracket) {
	                const at = str.indexOf(closebracket, start + 1);
	                if (~at) end = at + closebracket.length; //包括括號
	            }
	        }
	        const aoffset = offset + rawName.length + 1;
	        choff += offset - prevoff; //目前文字座標，做為標記的起點
	        let offtag = {
	            name: tagName,
	            offset,
	            aoffset,
	            attrs,
	            line,
	            choff,
	            width,
	            start,
	            end,
	            active: false
	        };
	        tags.push(offtag);
	        choff -= m.length;
	        prevoff = offset;
	        return '';
	    });
	    resolveEnd(str, text, tags);
	    //need one concreate char to hold tag at the end
	    if (tags.length && tags[tags.length - 1].choff >= text.length) {
	        text += ' ';
	    }
	    return [
	        text,
	        tags
	    ];
	};
	const updateOfftext = (rawtext, tag, newtag)=>{
	    for(let n in newtag.attrs){
	        if (newtag.attrs[n] != tag.attrs[n]) {
	            let newvalue = typeof newtag.attrs[n] !== 'string' ? JSON.stringify(newtag.attrs[n]) : newtag.attrs[n];
	            if (newvalue.indexOf(' ') > 0) {
	                newvalue = '"' + newvalue + '"';
	            }
	            const regex = new RegExp('\\b' + n + ' *= *"?' + tag.attrs[n] + '"?');
	            rawtext = rawtext.replace(regex, n + '=' + newvalue);
	        }
	    }
	    return rawtext;
	};
	class Offtext {
	    getTag(ntag) {
	        return this.tags[ntag];
	    }
	    tagText(tag, raw = false) {
	        if (typeof tag == 'number') tag = this.tags[tag];
	        if (!tag) return '';
	        return raw ? this.raw.slice(tag.start, tag.end) : this.plain.slice(tag.choff, tag.choff + tag.width);
	    }
	    tagRawText(tag) {
	        return this.tagText(tag, true);
	    }
	    constructor(raw, line = 0){
	        _define_property$a(this, "raw", void 0);
	        _define_property$a(this, "plain", void 0);
	        _define_property$a(this, "tags", void 0);
	        this.raw = raw;
	        //let plain,tags;
	        let [plain, tags] = parseOfftext(raw, line);
	        this.plain = plain;
	        this.tags = tags;
	    }
	}
	const eatofftag = (str)=>{
	    let thetag = '', p = 0;
	    let ch = str.charAt(0);
	    if (ch == '{') {
	        const [obj, len] = extractObject(str);
	        return str.slice(0, len);
	    }
	    while(thetag.length < 128 && ch && p < str.length){
	        const cp = str.charCodeAt(p) || 0;
	        if (cp > 0x2d && cp <= 0x3b || cp >= 0x61 && cp <= 0x7a || cp == 0x40 || cp == 0x23 || cp == 0x5f || cp == 0x7e) {
	            thetag += ch;
	            p++;
	        } else {
	            break;
	        }
	        ch = str.charAt(p);
	    }
	    return thetag;
	};
	//  page 
	//  page.line    // line must be number
	//  page@book
	//  page@book.lineoff 
	//  page.line@book
	const parsePageBookLine = (addr)=>{
	    let lineoff = 0;
	    const m = addr.match(/\.(\d+)/);
	    if (m) {
	        lineoff = parseInt(m[1]);
	        addr = addr.replace(m[0], '');
	    }
	    let [page, book] = addr.split('@');
	    return [
	        page,
	        book,
	        lineoff
	    ];
	};
	//parse a complete transclusion with chinese
	const parseTransclusion = (str)=>{
	    if (str.startsWith('^')) str = str.slice(1);
	    let tag = '', innertext = str;
	    if (!str.indexOf('[')) {
	        tag = eatofftag(str);
	        innertext = removeBracket(str.slice(tag.length));
	    }
	    const at = innertext.indexOf('|');
	    let caption = innertext;
	    if (at > 0) {
	        caption = innertext.slice(0, at);
	        innertext = innertext.slice(at + 1);
	    }
	    return [
	        tag,
	        innertext,
	        caption
	    ];
	};

	const bsearchNumber = (arr, obj)=>{
	    let low = 0, high = arr.length - 1, mid;
	    while(low < high){
	        mid = low + high >> 1;
	        if (arr[mid] === obj) {
	            while(mid > -1 && arr[mid - 1] === obj)mid--; //值重覆的元素，回逆到第一個
	            return mid;
	        }
	        arr[mid] < obj ? low = mid + 1 : high = mid;
	    }
	    return low;
	};
	const bsearch = (arr, obj)=>{
	    let low = 0, high = arr.length - 1, mid;
	    while(low < high){
	        mid = low + high >> 1;
	        if (arr[mid] === obj) {
	            while(mid > -1 && arr[mid - 1] === obj)mid--; //值重覆的元素，回逆到第一個
	            return mid;
	        }
	        arr[mid] < obj ? low = mid + 1 : high = mid;
	    }
	    return low;
	};
	const bsearchGetter = (getter, obj)=>{
	    const len = parseInt(getter(-1)); //get the len
	    let low = 0, high = len - 1; //getter is 1-based
	    while(low < high){
	        let mid = low + high >> 1;
	        if (getter(mid) === obj) {
	            while(mid > -1 && getter(mid - 1) === obj)mid--; //值重覆的元素，回逆到第一個
	            return mid;
	        }
	        getter(mid) < obj ? low = mid + 1 : high = mid;
	    }
	    return low;
	};

	const alphabetically = (a, b)=>a > b ? 1 : a < b ? -1 : 0;
	const alphabetically0 = (a, b)=>a[0] > b[0] ? 1 : a[0] < b[0] ? -1 : 0;
	const unique = (arr, sorted = false)=>{
	    if (!arr || !arr.length) return [];
	    if (!sorted) {
	        arr.sort(typeof arr[0] == 'string' ? alphabetically : (a, b)=>a - b);
	    }
	    let prev, out = [];
	    for(let i = 0; i < arr.length; i++){
	        if (arr[i] !== prev) out.push(arr[i]);
	        prev = arr[i];
	    }
	    return out;
	};
	const fromObj = (obj, cb)=>{
	    const arr = [];
	    for(let key in obj){
	        if (!cb) {
	            arr.push(key + '\t' + obj[key]);
	        } else {
	            if (typeof cb == 'function') {
	                arr.push(cb(key, obj[key]));
	            } else {
	                arr.push([
	                    key,
	                    obj[key]
	                ]);
	            }
	        }
	    }
	    if (cb && typeof cb !== 'function') {
	        arr.sort((a, b)=>b[1] - a[1]);
	    }
	    return arr;
	};
	const sortObj = (obj, func)=>{
	    const arr = [];
	    for(let key in obj){
	        arr.push([
	            key,
	            obj[key]
	        ]);
	    }
	    if (func) arr.sort(func);
	    else arr.sort((a, b)=>{
	        return +b[1] - a[1];
	    });
	    return arr;
	};
	//
	const sortNumberArray = (arr)=>{
	    const value_id = arr.map((v, idx)=>[
	            v,
	            idx
	        ]);
	    value_id.sort((a, b)=>a[0] - b[0]);
	    const indexes = value_id.map(([v, idx])=>idx);
	    const newarr = value_id.map(([v, idx])=>v);
	    return [
	        newarr,
	        indexes
	    ];
	};

	const arraydiff = (arr1, arr2)=>arr1.filter((x)=>!arr2.includes(x)).concat(arr2.filter((x)=>!arr1.includes(x)));
	const indexOfs = (arr, tofind)=>{
	    const out = [];
	    for(let j = 0; j < arr.length; j++){
	        if (~arr[j].indexOf(tofind)) {
	            out.push(j);
	        }
	    }
	    return out;
	};

	const CodeStart = 0x0E;
	const BYTE_MAX = 113;
	const BYTE1_MAX = 45 //delta
	;
	const BYTE2_MAX = 44 * BYTE_MAX + BYTE1_MAX //5017      //for year bc 2000~ad2280
	;
	const BYTE2_START = 45;
	const BYTE3_START = 89;
	const BYTE4_START = 105;
	const BYTE5_START = 112;
	const BYTE3_MAX = 16 * BYTE_MAX * BYTE_MAX + BYTE2_MAX // ~204304     
	;
	const BYTE4_MAX = 6 * BYTE_MAX * BYTE_MAX * BYTE_MAX + BYTE3_MAX // ~10100279   
	;
	const BYTE5_MAX = 2 * BYTE_MAX * BYTE_MAX * BYTE_MAX * BYTE_MAX + BYTE4_MAX // 326094722
	;
	const SEP2DITEM = 0x7f;
	const SEPARATOR2D = "\u007f";
	const unpackInt = (s, delta = false)=>{
	    let arr = [];
	    //let started=false;
	    if (!s) return [];
	    let o, i = 0, c = 0, prev = 0;
	    while(i < s.length){
	        o = s.charCodeAt(i) - CodeStart;
	        if (o < BYTE2_START) ; else if (o < BYTE3_START) {
	            const i1 = s.charCodeAt(++i) - CodeStart;
	            o -= BYTE2_START;
	            o = o * BYTE_MAX + i1 + BYTE1_MAX;
	        } else if (o < BYTE4_START) {
	            const i2 = s.charCodeAt(++i) - CodeStart;
	            const i1 = s.charCodeAt(++i) - CodeStart;
	            o -= BYTE3_START;
	            o = o * BYTE_MAX * BYTE_MAX + i2 * BYTE_MAX + i1 + BYTE2_MAX;
	        } else if (o < BYTE5_START) {
	            const i3 = s.charCodeAt(++i) - CodeStart;
	            const i2 = s.charCodeAt(++i) - CodeStart;
	            const i1 = s.charCodeAt(++i) - CodeStart;
	            o -= BYTE4_START;
	            o = o * BYTE_MAX * BYTE_MAX * BYTE_MAX + i3 * BYTE_MAX * BYTE_MAX + i2 * BYTE_MAX + i1 + BYTE3_MAX;
	        } else if (o < SEP2DITEM) {
	            const i4 = s.charCodeAt(++i) - CodeStart;
	            const i3 = s.charCodeAt(++i) - CodeStart;
	            const i2 = s.charCodeAt(++i) - CodeStart;
	            const i1 = s.charCodeAt(++i) - CodeStart;
	            o -= BYTE5_START;
	            o = o * BYTE_MAX * BYTE_MAX * BYTE_MAX * BYTE_MAX + i4 * BYTE_MAX * BYTE_MAX * BYTE_MAX + i3 * BYTE_MAX * BYTE_MAX + i2 * BYTE_MAX + i1 + BYTE3_MAX;
	        } else {
	            throw new Error("exit max integer 0x7f," + o);
	        }
	        arr[c] = o + (delta ? prev : 0) - 1;
	        prev = arr[c];
	        c++;
	        i++;
	    }
	    return arr; // return normal array , easier for consequence operation (intersect, union)
	};
	const unpackIntDelta = (str)=>{
	    return unpackInt(str, true);
	};
	const unpackIntDelta2d = (str)=>{
	    if (!str) return [];
	    return unpackInt2d(str, true);
	};
	const unpackInt2d = (str, delta = false)=>{
	    if (!str) return [];
	    const arr = str.split(SEPARATOR2D);
	    if (arr.length == 1) return [
	        unpackInt(arr[0])
	    ];
	    return arr.map((it)=>unpackInt(it, delta));
	};

	//might be two dimensional,separated by | 
	const packInt2d = (arr, delta = false)=>{
	    const o = [];
	    for(let i = 0; i < arr.length; i++){
	        o.push(packInt(arr[i], delta));
	    }
	    return o.join(SEPARATOR2D);
	};
	const packInt = (arr, delta = false)=>{
	    if (arr.length == 0) return '';
	    const sz = arr.length * 5;
	    let s = new Uint8Array(sz), int = arr[0] + 1, prev = arr[0], idx1 = 0;
	    for(let i = 1; i <= arr.length; i++){
	        if (int < BYTE1_MAX) {
	            s[idx1++] = int + CodeStart;
	        } else if (int < BYTE2_MAX) {
	            int -= BYTE1_MAX;
	            let i1, i2;
	            i1 = int % BYTE_MAX;
	            i2 = Math.floor(int / BYTE_MAX);
	            s[idx1++] = i2 + BYTE2_START + CodeStart;
	            s[idx1++] = i1 + CodeStart;
	        } else if (int < BYTE3_MAX) {
	            int -= BYTE2_MAX;
	            let i1, i2, i3;
	            i1 = int % BYTE_MAX;
	            int = Math.floor(int / BYTE_MAX);
	            i2 = int % BYTE_MAX;
	            i3 = Math.floor(int / BYTE_MAX);
	            s[idx1++] = i3 + BYTE3_START + CodeStart;
	            s[idx1++] = i2 + CodeStart;
	            s[idx1++] = i1 + CodeStart;
	        } else if (int < BYTE4_MAX) {
	            int -= BYTE3_MAX;
	            let i1, i2, i3, i4;
	            i1 = int % BYTE_MAX;
	            int = Math.floor(int / BYTE_MAX);
	            i2 = int % BYTE_MAX;
	            int = Math.floor(int / BYTE_MAX);
	            i3 = int % BYTE_MAX;
	            i4 = Math.floor(int / BYTE_MAX);
	            s[idx1++] = i4 + BYTE4_START + CodeStart;
	            s[idx1++] = i3 + CodeStart;
	            s[idx1++] = i2 + CodeStart;
	            s[idx1++] = i1 + CodeStart;
	        } else if (int < BYTE5_MAX) {
	            int -= BYTE4_MAX;
	            let i1, i2, i3, i4, i5;
	            i1 = int % BYTE_MAX;
	            int = Math.floor(int / BYTE_MAX);
	            i2 = int % BYTE_MAX;
	            int = Math.floor(int / BYTE_MAX);
	            i3 = int % BYTE_MAX;
	            int = Math.floor(int / BYTE_MAX);
	            i4 = int % BYTE_MAX;
	            i5 = Math.floor(int / BYTE_MAX);
	            s[idx1++] = i5 + BYTE5_START + CodeStart;
	            s[idx1++] = i4 + CodeStart;
	            s[idx1++] = i3 + CodeStart;
	            s[idx1++] = i2 + CodeStart;
	            s[idx1++] = i1 + CodeStart;
	        } else {
	            // console.log(arr)
	            // console.log('neighbor of arr',i,delta,arr.slice(i,10),arr.length, prev)
	            throw new Error('exist max int boundary ' + BYTE5_MAX + ' i' + i + ',val:' + arr[i] + ' int' + int);
	        }
	        int = (delta ? arr[i] - prev : arr[i]) + 1;
	        if (int < 0 && delta) {
	            console.log('arr length', arr.length, 'now', arr[i], 'prev', prev);
	            throw new Error('negative delta');
	        }
	        prev = arr[i] || 0;
	    }
	    //new TextDecoder is quite fast
	    return new TextDecoder().decode(s.subarray(0, idx1)); //slice will make new copy
	};
	const packIntDelta = (arr)=>packInt(arr, true);
	const packIntDelta2d = (arr2d)=>packInt2d(arr2d, true);

	/**
	 * StringArray backed by a delimitered string. 
	 * quick setup speed as spliting is not required.
	 * preventing javscript engine to generate tons of "sliced string"
	 * fast sequencial read and partial search (String.indexOf).
	 * fast random seek by charpos at the space cost of 1/average_item_size)
	 * */ function _define_property$9(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	const LEMMA_DELIMITER = '\x7f';
	const SA_MATCH_ANY = 3, SA_MATCH_START = 0, SA_MATCH_MIDDLE = 1, SA_MATCH_END = 2;
	class StringArray {
	    buildcharpos() {
	        let prev = -1, p = 0;
	        while(p < this.buf.length){
	            const at = this.buf.indexOf(this.sep, prev);
	            if (at == -1) {
	                this.charpos.push(this.buf.length);
	                break;
	            } else {
	                this.charpos.push(at + 1);
	                prev = at + 1;
	            }
	        }
	    }
	    len() {
	        return this.charpos.length;
	    }
	    reset() {
	        this.now = 0;
	    }
	    first() {
	        this.reset();
	        return this.next();
	    }
	    next() {
	        if (this.now == -1) return;
	        const at = this.buf.indexOf(this.sep, this.now);
	        if (at == -1) {
	            if (this.now >= 0) {
	                const lastline = this.buf.slice(this.now);
	                this.now = -1;
	                return lastline;
	            } else {
	                this.now = -1;
	                return;
	            }
	        }
	        const s = this.buf.slice(this.now, at);
	        this.now = at + 1;
	        return s;
	    }
	    get(idx) {
	        if (idx == -1) return this.charpos.length.toString(); //for  bsearchGetter
	        if (this.sequencial || idx < 0) return '';
	        const from = idx == 0 ? 0 : this.charpos[idx - 1];
	        const to = this.charpos[idx] - (idx == this.charpos.length - 1 ? 0 : 1);
	        return this.buf.slice(from, to);
	    }
	    at(offset) {
	        return bsearchNumber(this.charpos, offset);
	    }
	    //assuming sorted
	    find(pat) {
	        const getter = this.get.bind(this);
	        if (this.delimiter) pat += this.delimiter;
	        const at = bsearchGetter(getter, pat); // this.get(-1) return len
	        const found = getter(at);
	        return found.endsWith(pat) ? at : -1;
	    }
	    indexOf(pat) {
	        let at;
	        at = this.buf.indexOf(pat);
	        while(at > -1){
	            if (at == 0 && this.buf.charAt(pat.length) == this.sep) return 0;
	            if (this.buf.length == pat.length + at && this.buf.charAt(at - 1) == this.sep) return this.len() - 1;
	            if (this.buf.charAt(at - 1) == this.sep && this.buf.charAt(at + pat.length) == this.sep) {
	                return bsearchNumber(this.charpos, at) + 1;
	            } else {
	                at = this.buf.indexOf(pat, at + pat.length);
	            }
	        }
	        return -1;
	    }
	    enumMiddle(infix, max = 999) {
	        if (this.middleCache.hasOwnProperty(infix)) {
	            return this.middleCache[infix];
	        }
	        let idx = this.buf.indexOf(infix);
	        const out = Array();
	        while(idx > -1){
	            const at = this.at(idx);
	            const lp = at ? this.charpos[at - 1] : 0;
	            const lp2 = this.charpos[at] - 1 - infix.length;
	            if (idx > lp && idx < lp2) {
	                out.push(at);
	                if (out.length > max) break;
	            }
	            idx = this.buf.indexOf(infix, this.charpos[at] + this.sep.length);
	        }
	        this.middleCache[infix] = out;
	        return out;
	    }
	    enumStart(prefix, max = 999) {
	        const getter = this.get.bind(this);
	        let at = bsearchGetter(getter, prefix); // this.get(0) return len
	        if (at == -1) return [];
	        const out = Array();
	        const len = this.len();
	        while(at < len){
	            const found = this.get(at);
	            if (found.startsWith(prefix)) {
	                out.push(at);
	                if (out.length > max) break;
	            } else break;
	            at++;
	        }
	        return out;
	    }
	    enumEnd(suffix, max = 999) {
	        if (this.endCache.hasOwnProperty(suffix)) {
	            console.log('cache');
	            return this.endCache[suffix];
	        }
	        if (suffix[suffix.length - 1] !== this.sep) suffix = suffix + this.sep;
	        let idx = this.buf.indexOf(suffix);
	        const out = Array();
	        while(idx > -1 && this.buf.charAt(idx - 1) !== this.sep){
	            const at = this.at(idx);
	            out.push(at);
	            if (out.length > max) break;
	            idx = this.buf.indexOf(suffix, idx + this.sep.length);
	        }
	        this.endCache[suffix] = out;
	        return out;
	    }
	    enumAny(infix, max = 999) {
	        if (this.middleCache.hasOwnProperty(infix)) {
	            return this.middleCache[infix];
	        }
	        let idx = this.buf.indexOf(infix);
	        const out = Array();
	        while(idx > -1){
	            const at = this.at(idx);
	            const lp = at ? this.charpos[at - 1] : 0;
	            const lp2 = this.charpos[at] - 1 - infix.length;
	            if (idx >= lp && idx <= lp2) {
	                out.push(at);
	                if (out.length > max) break;
	            }
	            idx = this.buf.indexOf(infix, this.charpos[at] + this.sep.length);
	        }
	        this.middleCache[infix] = out;
	        return out;
	    }
	    enumMode(s, mode = 0, max) {
	        if (mode == SA_MATCH_ANY) return this.enumAny(s, max);
	        else if (mode == SA_MATCH_START) return this.enumStart(s, max);
	        else if (mode == SA_MATCH_MIDDLE) return this.enumMiddle(s, max);
	        else if (mode == SA_MATCH_END) return this.enumEnd(s, max);
	        return [];
	    }
	    matchLongest(text) {
	        const getter = this.get.bind(this);
	        const at = bsearchGetter(getter, text) - 1; // this.get(0) return len
	        const out = [];
	        let upper = at - 1;
	        if (text.startsWith(this.get(at))) out.push([
	            this.get(at),
	            at
	        ]);
	        let lower = at + 1;
	        while(upper > 0){
	            const found = this.get(upper);
	            //ascii stop immediately
	            if (text.startsWith(found)) out.push([
	                found,
	                upper
	            ]);
	            else if (text.codePointAt(0) < 0x100 || text[0] !== found[0]) break;
	            upper--;
	        }
	        while(lower < this.len()){
	            const found = this.get(lower);
	            if (text.startsWith(found)) out.push([
	                found,
	                lower
	            ]);
	            else if (text.codePointAt(0) < 0x100 || text[0] !== found[0]) break;
	            lower++;
	        }
	        out.sort((a, b)=>b[0].length - a[0].length);
	        return out;
	    }
	    /* if delimiter is missing, value is the text after key, ie , a fixed with key */ getValue(key) {
	        const at = this.find(key);
	        return ~at ? this.get(at).slice(key.length + this.delimiter.length) : '';
	    }
	    constructor(buf, opts = {}){
	        _define_property$9(this, "buf", '');
	        _define_property$9(this, "sep", '');
	        _define_property$9(this, "charpos", []);
	        _define_property$9(this, "middleCache", {});
	        _define_property$9(this, "endCache", {});
	        _define_property$9(this, "now", void 0);
	        _define_property$9(this, "sequencial", void 0);
	        _define_property$9(this, "delimiter", void 0);
	        _define_property$9(this, "findMatches", (rawtext)=>{
	            let i = 0;
	            const out = [];
	            while(i < rawtext.length){
	                const tf = rawtext.slice(i);
	                const m = this.matchLongest(tf);
	                if (m.length) {
	                    i += m.length;
	                    out.push([
	                        i,
	                        m[0][0],
	                        m[0][1]
	                    ]);
	                } else {
	                    i++;
	                }
	            }
	            return out;
	        });
	        this.sequencial = opts.sequencial;
	        this.delimiter = opts.delimiter || ''; //separate key and value
	        this.buf = buf;
	        this.sep = opts.sep || '\n'; //separate item
	        this.now = 0;
	        // if (this.sep && this.sep.codePointAt(0) >=0x20) {
	        // console.log('avoid using ascii bigger than space as separator, tab 0x09 is a better choice')
	        // }
	        //用\t (key\tvalue) ，不要用 =或 : 做分割符 ，去掉 value ，key 不必重排。(因 = 的ascii值在數字之後)
	        //只做一次順序讀取，可節省 buildcharpos;
	        if (!this.sequencial) this.buildcharpos();
	    }
	}

	const lineBreaksOffset = (str)=>{
	    let i = 0;
	    const out = Array();
	    while(i < str.length){
	        const at = str.indexOf('\n', i);
	        if (at == -1) break;
	        out.push(at);
	        i = at + 1;
	    }
	    return out;
	};
	const humanBytes = (n)=>{
	    if (n < 1024) {
	        return [
	            n,
	            'B'
	        ];
	    }
	    if (n < 1024 * 1024) {
	        return [
	            parseFloat((n / 1024).toFixed(2)),
	            'KB'
	        ];
	    } else {
	        return [
	            parseFloat((n / (1024 * 1024)).toFixed(2)),
	            'MB'
	        ];
	    }
	};
	function debounce(f, ms) {
	    let timer;
	    return function(...args) {
	        clearTimeout(timer);
	        timer = setTimeout(f.bind(this, ...args), ms);
	    };
	}

	const parseJsonp = (str)=>{
	    const start = str.indexOf('{');
	    const end = str.indexOf('},`') + 1;
	    let payload = str.substring(end + 2, str.length - 1);
	    if (payload[payload.length - 1] == '`') payload = payload.slice(0, payload.length - 1);
	    //indexOf is much faster than regex, replace only when needed
	    if (payload.indexOf("\\\\") > -1) payload = payload.replace(/\\\\/g, "\\");
	    if (payload.indexOf("\\`") > -1) payload = payload.replace(/\\`/g, "`");
	    if (payload.indexOf("$\\{") > -1) payload = payload.replace(/\$\\\{/g, '${');
	    return [
	        JSON.parse(str.substring(start, end)),
	        payload
	    ];
	};
	const loadScript = async (src, cb)=>{
	    if (cb && cb()) {
	        return true //no need to load
	        ;
	    }
	    if (src.slice(0, 2) == './') src = src.slice(2);
	    const css = src.endsWith('.css');
	    const children = document.head.children;
	    for(let i = 0; i < children.length; i++){
	        const ele = children[i];
	        if (css && ele.tagName == 'LINK' && ele.href.endsWith('/' + src)) {
	            if (i < children.length - 1) {
	                document.head.removeChild(ele);
	                document.head.appendChild(ele);
	            }
	            return true;
	        } else if (ele.tagName == 'SCRIPT' && ele.src.endsWith('/' + src)) return true;
	    }
	    const promise = new Promise((resolve, reject)=>{
	        const script = document.createElement(css ? "link" : "script");
	        script.type = css ? 'text/css' : 'text/javascript';
	        if (css) {
	            script.rel = 'stylesheet';
	            script.href = src;
	        } else {
	            script.src = src;
	        }
	        script.onerror = reject;
	        script.async = true;
	        script.onload = resolve;
	        document.head.appendChild(script);
	    });
	    return promise;
	};

	const toChineseNumber = (n)=>{
	    let out = '';
	    while(n){
	        const digit = [
	            '〇',
	            '一',
	            '二',
	            '三',
	            '四',
	            '五',
	            '六',
	            '七',
	            '八',
	            '九'
	        ][n % 10];
	        out = digit + out;
	        n = Math.floor(n / 10);
	    }
	    return out;
	};
	const StyledNumber1 = {
	    'Ⅰ': 10,
	    'ⅰ': 10,
	    '⒜': 26,
	    'Ⓐ': 26,
	    'ⓐ': 26,
	    '⓫': 10,
	    '㉑': 15,
	    '㍘': 25,
	    '㍙': 24,
	    '㈠': 10,
	    '㊀': 10,
	    '㋀': 12,
	    '㏠': 31,
	    '①': 50,
	    '⑴': 20,
	    '⒈': 20,
	    '⓵': 10,
	    '❶': 10,
	    '➀': 10,
	    '➊': 10,
	    '₁': 9
	};
	const styledNumber = (n, style = '①', offset = 1)=>{
	    let max = StyledNumber1[style];
	    if (typeof n !== 'number') n = parseInt(n) || 0;
	    if (!max) {
	        return n.toString(); //fall back
	    } else {
	        if (n - offset >= max) {
	            return n.toString();
	        }
	        if (style == '①') {
	            if (n > 35) {
	                style = '㊱';
	                n -= 35;
	            } else if (n > 20) {
	                style = '㉑';
	                n -= 20;
	            }
	            if (n == 0) return '⓪';
	        }
	        let code = style.charCodeAt(0) + n - offset;
	        return String.fromCharCode(code);
	    }
	};

	const sleep = (time)=>new Promise((r)=>{
	        setTimeout(()=>r(), time);
	    });
	const updateUrl = (address)=>{
	    window.location.hash = '#' + address;
	};
	const addressFromUrl = ()=>{
	    let hash = window.location.hash;
	    if (hash[0] == '#') hash = hash.slice(1);
	    let address = decodeURI(hash);
	    if (~address.indexOf('%')) address = decodeURIComponent(address);
	    if (!~address.indexOf('bk') && !~address.indexOf('ak')) address = ''; //invalid adress
	    return address;
	};

	const sc2tc$1 = `㑔㑯
㑇㑳
㐹㑶
刾㓨
㘎㘚
㚯㜄
㛣㜏
㟆㠏
㤘㥮
㨫㩜
㧐㩳
擜㩵
㻪㻽
䀥䁻
鿎䃮
䌶䊷
䌺䋙
䌻䋚
䌿䋹
䌾䋻
䎬䎱
䙌䙡
䜧䜀
䞍䝼
䦂䥇
鿏䥑
䥾䥱
䦶䦛
䦷䦟
䯅䯀
鲃䰾
䲣䱷
䲝䱽
鳚䲁
鳤䲘
鹮䴉
丢丟
并<併並
干<幹>乾
乱亂
亚亞
伫佇
来來
仑侖
侣侶
俣俁
系<繫係
伣俔
侠俠
伡俥
伥倀
俩倆
俫倈
仓倉
个個
们們
伦倫
㑈倲
伟偉
㐽偑
侧側
侦偵
伪僞偽
㐷傌
杰<傑
伧傖
伞傘
备備
佣<傭
偬傯
传傳
伛傴
债債
伤傷
倾傾
偻僂
仅僅
佥僉
侨僑
仆<僕
侥僥
偾僨
价<價
仪儀
㑺儁
侬儂
亿億
侩儈
俭儉
傧儐
俦儔
侪儕
尽盡儘
偿償
优<優
储儲
俪儷
㑩儸
傩儺
傥儻
俨儼
兑兌
儿<兒
兖兗
内內
两兩
册冊
幂冪
净凈
冻凍
凛凜
凯凱
别別
删刪
刭剄
则則
克<剋
刹剎
刬剗
刚剛
剥剝
剐剮
剀剴
创創
划<劃
剧劇
刘劉
刽劊
刿劌
剑劍
㓥劏
剂劑
㔉劚
劲勁
动動
务務
勋勛
胜<勝
劳勞
势勢
勚勩
劢勱
励勵
劝勸
匀勻
匦匭
汇彙匯
匮匱
区區
协協
却卻
厍厙
厌厭
厉厲
厣厴
参參
叁叄
丛叢
咤>吒
吴吳
呐吶
吕呂
呙咼
员員
呗唄
吣唚
问問
哑啞
启啟
唡啢
㖞喎
唤喚
丧喪
乔喬
单單
哟喲
呛嗆
啬嗇
唝嗊
吗嗎
呜嗚
唢嗩
哔嗶
叹嘆
喽嘍
啯嘓
呕嘔
啧嘖
尝嘗
唛嘜
哗嘩
唠嘮
啸嘯
叽嘰
哓嘵
呒嘸
啴嘽
嘘噓
㖊噚
咝噝
哒噠
哝噥
哕噦
嗳噯
哙噲
喷噴
吨<噸
当當噹
咛嚀
吓嚇
哜嚌
噜嚕
啮嚙
呖嚦
咙嚨
亸嚲
喾嚳
严嚴
嘤嚶
啭囀
嗫囁
嚣囂
冁囅
呓囈
啰囉
嘱囑
囱囪
囵圇
国國
围圍
园園
圆圓
图圖
团團
埯垵
垭埡
采<採埰
执執
坚堅
垩堊
垴堖
埚堝
尧堯
报報
场場
块塊
茔塋
垲塏
埘塒
涂<塗
坞塢
埙塤
尘塵
堑塹
垫墊
坠墜
堕墮
坟墳
垯墶
垦墾
坛罈壇
垱壋
压壓
垒壘
圹壙
垆壚
坏<壞
垄壟
垅壠
坜壢
坝壩
塆壪
壮壯
壶壺
壸壼
寿壽
够夠
梦夢
夹夾
奂奐
奥奧
奁奩
夺奪
奨奬
奋奮
姹奼
妆妝
姗姍
奸<姦
娱娛
娄婁
妇婦
娅婭
娲媧
妫媯
㛀媰
媪媼
妈媽
妪嫗
妩嫵
娴嫻
婳嫿
媭嬃
娆嬈
婵嬋
娇嬌
嫱嬙
嫒嬡
嬷嬤
嫔嬪
婴嬰
婶嬸
㛤孋
娈孌
孙孫
学學
孪孿
宫宮
寝寢
实實
宁<寧
审審
写寫
宽寬
㝦寯
宠寵
宝寶
将將
专專
寻尋
对對
导導
尴尷
届屆
尸<屍
屃屓
屉屜
屡屢
层層
屦屨
属屬
冈岡
岘峴
岛島
峡峽
崃崍
岗崗
峥崢
岽崬
岚嵐
㟥嵾
嵝嶁
崭嶄
岖嶇
嵚嶔
崂嶗
峤嶠
峣嶢
峄嶧
崄嶮
岙嶴
嵘嶸
岭<嶺
屿嶼
岿巋
峦巒
巅巔
巯巰
帅帥
师師
帐帳
带帶
帧幀
帏幃
㡎幓
帼幗
帻幘
帜幟
币幣
帮幫
帱幬
么<麼>幺>麽
几<幾
库庫
厕廁
厢廂
厩廄
厦廈
厨廚
厮廝
庙廟
厂<廠
庑廡
废廢
广廣
廪廩
庐廬
厅廳
弑弒
弪弳
张張
强強
弹彈
弥彌
弯彎
彝<彞
彟彠
彦彥
彨彲
后<>後
径徑
从從
徕徠
复<複復>覆
征<>徵
彻徹
恒恆
耻恥
悦悅
悮悞
怅悵
闷悶
恶惡
恼惱
恽惲
恻惻
爱愛
惬愜
悫愨
怆愴
恺愷
忾愾
栗<慄
态態
愠慍
惨慘
惭慚
恸慟
惯慣
怄慪
怂慫
虑慮
悭慳
庆慶
㥪慺
忧憂
惫憊
㤭憍
怜<憐
凭憑
愦憒
慭憖
惮憚
愤憤
悯憫
怃憮
宪憲
忆憶
恳懇
应應
怿懌
懔懍
怼懟
懑懣
㤽懤
㤖懧
恹懨
惩懲
懒懶
怀<懷
悬懸
忏<懺
惧懼
慑懾
恋戀
戆戇
戋戔
戗戧
戬戩
战戰
戯戱
戏戲
户戶
抛拋
捝挩
挟挾
舍<捨
扪捫
扫掃
抡掄
㧏掆
挜掗
挣掙
挂<掛
拣揀
扬揚
换換
挥揮
损損
摇搖
捣搗
揾搵
抢搶
掴摑
掼摜
搂摟
挚摯
抠摳
抟摶
掺摻
捞撈
挦撏
撑撐
挠撓
㧑撝
挢撟
掸撣
拨撥
抚撫
扑<撲
揿撳
挞撻
挝撾
捡撿
拥擁
掳擄
择擇
击擊
挡擋
㧟擓
担擔
据<據
挤擠
㧛擥
拟擬
摈擯
拧擰
搁擱
掷擲
扩擴
撷擷
摆擺
擞擻
撸擼
㧰擽
扰<擾
摅攄
撵攆
拢攏
拦攔
撄攖
搀攙
撺攛
携攜
摄攝
攒攢
挛攣
摊攤
搅攪
揽攬
败敗
叙敘
敌敵
数數
敛斂
毙斃
敩斆
斓斕
斩斬
断斷
于<>於
时時
晋晉
昼晝
晕暈
晖暉
旸暘
畅暢
暂暫
晔曄
历歷曆
昙曇
晓曉
向<曏
暧曖
旷曠
昽曨
晒<曬
书書
会會
胧朧
东東
栅柵
杆<桿
栀梔
枧梘
条條
枭梟
棁梲
弃棄
枨棖
枣棗
栋棟
㭎棡
栈棧
栖<棲
梾棶
桠椏
㭏椲
杨楊
枫楓
桢楨
业業
极<極
杩榪
荣榮
榅榲
桤榿
构<構
枪槍
梿槤
椠槧
椁槨
椮槮
桨槳
椢槶
椝槼
桩樁
乐樂
枞樅
楼樓
标標
枢樞
㭤樢
样樣
㭴樫
桪樳
朴<樸
树樹
桦樺
椫樿
桡橈
桥橋
机<機
椭橢
横橫
檩檁
柽檉
档檔
桧檜
槚檟
检檢
樯檣
梼檮
台<颱臺檯
槟檳
柠檸
槛檻
柜<櫃
橹櫓
榈櫚
栉櫛
椟櫝
橼櫞
栎櫟
橱櫥
槠櫧
栌櫨
枥櫪
橥櫫
榇櫬
蘖櫱
栊櫳
榉櫸
樱櫻
栏欄
权權
椤欏
栾欒
榄欖
棂欞
钦欽
欧歐
欤歟
欢歡
岁歲
归歸
殁歿
残殘
殒殞
殇殤
㱮殨
殚殫
殓殮
殡殯
㱩殰
歼殲
杀殺
壳殼
毁毀
殴毆
毵毿
牦氂
毡氈
氇氌
气<氣
氢氫
氩氬
氲氳
决決
没沒
冲衝沖
况況
汹洶
浃浹
泾涇
凉涼
泪淚
渌淥
沦淪
渊淵
涞淶
浅淺
涣渙
减減
沨渢
涡渦
测測
浑渾
凑湊
浈湞
汤湯
沩溈
准<準
沟溝
温溫
浉溮
涢溳
沧滄
灭滅
涤滌
荥滎
沪滬
滞滯
渗滲
浒滸
浐滻
滚滾
满滿
渔漁
溇漊
沤漚
汉漢
涟漣
渍漬
涨漲
溆漵
渐漸
浆漿
颍潁
泼潑
洁<潔
㴋潚
潜潛
润潤
浔潯
溃潰
滗潷
涠潿
涩澀
浇澆
涝澇
涧澗
渑澠
泽澤
滪澦
泶澩
浍澮
淀<澱
㳠澾
浊濁
浓濃
㳡濄
湿濕
泞<濘
溁濚
浕濜
济濟
涛濤
㳔濧
滥濫
潍濰
滨濱
溅濺
泺濼
滤濾
澛瀂
滢瀅
渎瀆
㲿瀇
泻瀉
沈<瀋
浏瀏
濒瀕
泸瀘
沥瀝
潇瀟
潆瀠
潴瀦
泷瀧
濑瀨
㳽瀰
潋瀲
澜瀾
沣灃
滠灄
洒<灑
漓<灕
滩灘
灏灝
漤灠
㳕灡
湾灣
滦灤
滟灧
灾災
为為
乌烏
烃烴
无無
炼煉
炜煒
烟煙
茕煢
焕煥
烦煩
炀煬
㶽煱
煴熅
荧熒
炝熗
热熱
颎熲
炽熾
烨燁
灯燈
烧燒
烫燙
焖燜
营營
灿燦
烛燭
烩燴
㶶燶
烬燼
焘燾
烁爍
炉爐
烂爛
争爭
爷爺
尔爾
墙牆
牍牘
牵牽
荦犖
犊犢
牺犧
状狀
狭狹
狈狽
狰猙
犹猶
狲猻
犸獁
狱獄
狮獅
奖獎
独獨
狯獪
猃獫
狝獮
狞獰
㺍獱
获穫獲
猎獵
犷獷
兽獸
獭獺
献獻
猕獼
猡玀
现現
珐琺
珲琿
玮瑋
玚瑒
琐瑣
瑶瑤
莹瑩
玛瑪
玱瑲
琏璉
琎璡
玑璣
瑷璦
珰璫
㻅璯
环環
玙璵
瑸璸
玺璽
琼瓊
珑瓏
璎瓔
瓒瓚
瓯甌
产產
亩畝
毕畢
画畫
异<異
畴疇
叠疊
痉痙
疴痾
痖瘂
疯瘋
疡瘍
痪瘓
瘗瘞
疮瘡
疟瘧
瘆瘮
疭瘲
瘘瘺
疗療
痨癆
痫癇
瘅癉
疠癘
瘪癟
痒<癢
疖癤
症<癥
疬癧
癞癩
癣癬
瘿癭
瘾癮
痈癰
瘫癱
癫癲
发髮發
皑皚
疱皰
皲皸
皱皺
盗盜
盏盞
监監
盘盤
卢盧
荡蕩盪
眦眥
众眾
困<睏
睁睜
睐睞
眍瞘
䁖瞜
瞒瞞
瞆瞶
睑瞼
眬矓
瞩矚
矫矯
硁硜
硖硤
砗硨
砚硯
硕碩
砀碭
砜碸
确<確
码碼
䂵碽
硙磑
砖磚
硵磠
碜磣
碛磧
矶磯
硗磽
䃅磾
硚礄
硷鹼礆
础礎
碍礙
矿礦
砺礪
砾礫
矾礬
砻礱
禄祿
祸禍
祯禎
祎禕
祃禡
御<禦
禅禪
礼禮
祢禰
祷禱
秃禿
籼秈
税稅
秆稈
䅉稏
禀稟
种<種
称稱
谷<穀
䅟穇
稣穌
积積
颖穎
秾穠
穑穡
秽穢
稳穩
稆穭
窝窩
洼<窪
穷窮
窑窯
窎窵
窭窶
窥窺
窜竄
窍竅
窦竇
窃竊
竞競
笔筆
笋筍
笕筧
䇲筴
笺箋
筝箏
节節
范<範
筑<築
箧篋
筼篔
笃篤
筛篩
筚篳
箦簀
篓簍
箪簞
简簡
篑簣
箫簫
筜簹
签簽
帘<簾
篮籃
筹籌
䉤籔
箓籙
篯籛
箨籜
籁籟
笼籠
笾籩
簖籪
篱<籬
箩籮
粤粵
糁糝
粪糞
粮糧
粝糲
籴糴
粜糶
纟糹
纠糾
纪紀
纣紂
约約
红紅
纡紆
纥紇
纨紈
纫紉
纹紋
纳納
纽紐
纾紓
纯純
纰紕
纼紖
纱紗
纮紘
纸紙
级級
纷紛
纭紜
纴紝
纺紡
䌷紬
细細
绂紱
绁紲
绅紳
纻紵
绍紹
绀紺
绋紼
绐紿
绌絀
终終
组組
䌹絅
绊絆
绗絎
结結
绝絕
绦縧絛
绔絝
绞絞
络絡
绚絢
给給
绒絨
绖絰
统統
丝絲
绛絳
绢絹
绑綁
绡綃
绠綆
绨綈
绤綌
绥綏
䌼綐
经經
综綜
缍綞
绿綠
绸綢
绻綣
绶綬
维維
绹綯
绾綰
纲綱
网<網
缀綴
䌽綵
纶綸
绺綹
绮綺
绽綻
绰綽
绫綾
绵綿
绲緄
缁緇
紧緊
绯緋
绪緒
绬緓
绱鞝緔
缃緗
缄緘
缂緙
线線
缉緝
缎緞
缔締
缗緡
缘緣
缌緦
编編
缓緩
缅緬
纬緯
缑緱
缈緲
练練
缏緶
缇緹
致<緻
萦縈
缙縉
缢縊
缒縋
绉縐
缣縑
缊縕
缞縗
缚縛
缜縝
缟縞
缛縟
县縣
缝縫
缡縭
缩縮
纵縱
缧縲
䌸縳
缦縵
絷縶
缕縷
缥縹
总總
绩績
绷繃
缫繅
缪繆
缯繒
织織
缮繕
缭繚
绕繞
绣繡
缋繢
绳繩
绘繪
茧<繭
缰韁繮
缳繯
缲繰
缴繳
䍁繸
绎繹
继繼
缤繽
缱繾
䍀繿
颣纇
缬纈
纩纊
续續
累<纍
缠纏
缨纓
纤纖
缵纘
缆纜
钵缽
罂罌
罚罰
骂罵
罢罷
罗羅
罴羆
羁羈
芈羋
羟羥
义義
习習
翚翬
翘翹
翙翽
耧耬
耢耮
圣<聖
闻聞
联聯
聪聰
声聲
耸聳
聩聵
聂聶
职職
聍聹
听<聽
聋聾
肃肅
胁脅
脉脈
胫脛
脱脫
胀脹
肾腎
胨腖
脶腡
脑腦
肿腫
脚腳
肠腸
腽膃
腘膕
肤膚
䏝膞
胶膠
腻膩
胆膽
脍膾
脓膿
䐪臇
脸臉
脐臍
膑臏
腊<臘
胪臚
脏髒臟
脔臠
臜臢
临臨
与<與
兴興
举舉
旧舊
舱艙
舣艤
舰艦
舻艫
艰艱
艳艷
刍芻
苎苧
兹茲
荆荊
庄<莊
茎莖
荚莢
苋莧
华華
苌萇
莱萊
万<萬
荝萴
莴萵
叶葉
荭葒
着>著
荮葤
苇葦
荤葷
莳蒔
莅蒞
苍蒼
荪蓀
盖蓋
莲蓮
苁蓯
莼蓴
荜蓽
蒌蔞
蒋蔣
葱蔥
茑蔦
荫蔭
荨蕁
蒇蕆
荞蕎
荬蕒
芸<蕓
莸蕕
荛蕘
蒉蕢
芜蕪
萧蕭
蓣蕷
蕰薀
荟薈
蓟薊
芗薌
蔷薔
荙薘
莶薟
荐<薦
萨薩
䓕薳
苧<薴
䓓薵
荠薺
蓝藍
荩藎
艺藝
药藥
薮藪
苈藶
蔼藹
蔺藺
萚蘀
蕲蘄
芦蘆
苏蘇
蕴蘊
苹<蘋
藓蘚
蔹蘞
茏蘢
兰蘭
蓠蘺
萝蘿
蔂<虆
处處
虚虛
虏虜
号號
亏虧
虬虯
蛱蛺
蜕蛻
蚬蜆
蚀蝕
猬蝟
虾蝦
蜗蝸
蛳螄
蚂螞
萤螢
䗖螮
蝼螻
螀螿
蛰蟄
蝈蟈
螨蟎
虮<蟣
蝉蟬
蛲蟯
虫<蟲
蛏蟶
蚁蟻
蚃蠁
蝇蠅
虿蠆
蛴蠐
蝾蠑
蜡<蠟
蛎蠣
蟏蠨
蛊蠱
蚕<蠶
蛮蠻
术術
同<衕
胡<鬍衚
卫衛
衮袞
袅裊
补補
装裝
里<裡
制<製
裈褌
袆褘
裤褲
裢褳
褛褸
亵褻
裥襇
褝襌
袯襏
袄襖
裣襝
裆襠
褴襤
袜襪
䙓襬
衬襯
袭襲
襕襴
见見
觃覎
规規
觅覓
视視
觇覘
觋覡
觍覥
觎覦
亲親
觊覬
觏覯
觐覲
觑覷
觉覺
览覽
觌覿
观觀
觞觴
觯觶
触<觸
讠訁
订訂
讣訃
计計
讯訊
讧訌
讨討
讦訐
讱訒
训訓
讪訕
讫訖
讬託
记記
讹訛
讶訝
讼訟
䜣訢
诀訣
讷訥
讻訩
访訪
设設
许許
诉訴
诃訶
诊診
注<註
诂詁
诋詆
讵詎
诈詐
诒詒
诏詔
评評
诐詖
诇詗
诎詘
诅詛
词詞
咏詠
诩詡
询詢
诣詣
试試
诗詩
诧詫
诟詬
诡詭
诠詮
诘詰
话話
该該
详詳
诜詵
诙詼
诖詿
诔誄
诛誅
诓誆
夸<誇
志<誌
认認
诳誑
诶誒
诞誕
诱誘
诮誚
语語
诚誠
诫誡
诬誣
误誤
诰誥
诵誦
诲誨
说說
谁誰
课課
谇誶
诽誹
谊誼
訚誾
调調
谄諂
谆諄
谈談
诿諉
请請
诤諍
诹諏
诼諑
谅諒
论論
谂諗
谀諛
谍諜
谞諝
谝諞
诨諢
谔諤
谛諦
谐諧
谏諫
谕諭
谘諮
讳諱
谙諳
谌諶
讽諷
诸諸
谚諺
谖諼
诺諾
谋謀
谒謁
谓謂
誊謄
诌謅
谎謊
谜謎
谧謐
谑謔
谡謖
谤謗
谦謙
谥謚
讲講
谢謝
谣謠
谟謨
谪謫
谬謬
谫譾謭
讴謳
谨謹
谩謾
证證
谲譎
讥譏
谮譖
识識
谯譙
谭譚
谱譜
谵譫
译譯
议議
谴譴
护護
诪譸
䛓譼
誉譽
读讀
谉讅
变變
詟讋
䜩讌
雠讎
谗讒
让讓
谰讕
谶讖
谠讜
谳讞
岂豈
竖豎
丰<豐
猪豬
豮豶
猫貓
䝙貙
贝貝
贞貞
贠貟
负負
财財
贡貢
贫貧
货貨
贩販
贪貪
贯貫
责責
贮貯
贳貰
赀貲
贰貳
贵貴
贬貶
买買
贷貸
贶貺
费費
贴貼
贻貽
贸貿
贺賀
贲賁
赂賂
赁賃
贿賄
赅賅
资資
贾賈
贼賊
赈賑
赊賒
宾賓
赇賕
赒賙
赉賚
赐賜
赏賞
赔賠
赓賡
贤賢
卖賣
贱賤
赋賦
赕賧
质質
账賬
赌賭
䞐賰
赖賴
赗賵
赚賺
赙賻
购購
赛賽
赜賾
贽贄
赘贅
赟贇
赠贈
赞贊
赝贗贋
赡贍
赢贏
赆贐
赃贓
赑贔
赎贖
赣贛
赪赬
赶<趕
赵趙
趋趨
趱趲
迹跡
践踐
踊<踴
跄蹌
跸蹕
蹒蹣
踪蹤
跷蹺
跶躂
趸躉
踌躊
跻躋
跃躍
䟢躎
踯躑
跞躒
踬躓
蹰躕
跹躚
蹑躡
蹿躥
躜躦
躏躪
躯軀
车車
轧軋
轨軌
军軍
轪軑
轩軒
轫軔
轭軛
软軟
轷軤
轸軫
轱軲
轴軸
轵軹
轺軺
轲軻
轶軼
轼軾
较較
辂輅
辁輇
辀輈
载載
轾輊
辄輒
挽<輓
辅輔
轻輕
辆輛
辎輜
辉輝
辋輞
辍輟
辊輥
辇輦
辈輩
轮輪
辌輬
辑輯
辏輳
输輸
辐輻
辗輾
舆輿
辒轀
毂轂
辖轄
辕轅
辘轆
转轉
辙轍
轿轎
辚轔
轰轟
辔轡
轹轢
轳轤
办辦
辞辭
辫辮
辩辯
农農
迳逕
这這
连連
进進
运運
过過
达達
违違
遥遙
逊遜
递遞
远遠
适<適
迟遲
迁遷
选選
遗遺
辽遼
迈邁
还還
迩邇
边邊
逻邏
逦邐
郏郟
邮郵
郓鄆
乡鄉
邹鄒
邬鄔
郧鄖
邓鄧
郑鄭
邻鄰
郸鄲
邺鄴
郐鄶
邝鄺
酂酇
郦酈
丑<醜
酝醞
医醫
酱醬
酦醱
酿釀
衅釁
酾釃
酽釅
释釋
厘<釐
钅釒
钆釓
钇釔
钌釕
钊釗
钉釘
钋釙
针針
钓釣
钐釤
钏釧
钒釩
钗釵
钍釷
钕釹
钎釺
䥺釾
钯鈀
钫鈁
钘鈃
钭鈄
钚鈈
钠鈉
钝鈍
钩鉤鈎
钤鈐
钣鈑
钑鈒
钞鈔
钮鈕
钧鈞
钙鈣
钬鈥
钛鈦
钪鈧
铌鈮
铈鈰
钶鈳
铃鈴
钴鈷
钹鈸
铍鈹
钰鈺
钸鈽
铀鈾
钿鈿
钾鉀
钜鉅
铊鉈
铉鉉
铇鉋
铋鉍
铂鉑
钷鉕
钳鉗
铆鉚
铅鉛
钺鉞
钲鉦
鿭鑈鉨
钼鉬
钽鉭
铏鉶
铰鉸
铒鉺
铬鉻
铪鉿
银銀
铳銃
铜銅
铚銍
铣銑
铨銓
铢銖
铭銘
铫銚
铦銛
衔銜
铑銠
铷銣
铱銥
铟銦
铵銨
铥銩
铕銪
铯銫
铐銬
铞銱
锐銳
销銷
锈鏽銹
锑銻
锉銼
铝鋁
锒鋃
锌鋅
钡鋇
铤鋌
铗鋏
锋鋒
铻鋙
锊鋝
锓鋟
铘鋣
锄鋤
锃鋥
锔鋦
锇鋨
铓鋩
铺鋪
铖鋮
锆鋯
锂鋰
铽鋱
锍鋶
锯鋸
钢鋼
锞錁
录錄
锖錆
锫錇
锩錈
铔錏
锥錐
锕錒
锟錕
锤錘
锱錙
铮錚
锛錛
锬錟
锭錠
锜錡
钱錢
锦錦
锚錨
锠錩
锡錫
锢錮
错錯
锰錳
表<錶
铼錸
锝鍀
锨鍁
锪鍃
钔鍆
锴鍇
锳鍈
锅鍋
镀鍍
锷鍔
铡鍘
钖鍚
锻鍛
锽鍠
锸鍤
锲鍥
锘鍩
锹鍬
锾鍰
键鍵
锶鍶
锗鍺
钟鐘鍾
镁鎂
锿鎄
镅鎇
镑鎊
镕鎔
锁鎖
镉鎘
镈鎛
镃鎡
钨鎢
蓥鎣
镏鎦
铠鎧
铩鎩
锼鎪
镐鎬
镇鎮
镒鎰
镋鎲
镍鎳
镓鎵
鿔鎶
镎鎿
镞鏃
镟鏇
链鏈
镆鏌
镙鏍
镠鏐
镝鏑
铿鏗
锵鏘
镗鏜
镘鏝
镛鏞
铲鏟
镜鏡
镖鏢
镂鏤
錾鏨
镚鏰
铧鏵
镤鏷
镪鏹
䥽鏺
铙鐃
铴鐋
镣鐐
铹鐒
镦鐓
镡鐔
镫鐙
镢鐝
镨鐠
䦅鐥
锎鐦
锏鐧
镄鐨
镌鐫
镰鐮
䦃鐯
镯鐲
镭鐳
铁鐵
镮鐶
铎鐸
铛鐺
镱鐿
铸鑄
镬鑊
镔鑌
鉴鑒
镲鑔
锧鑕
镴鑞
铄鑠
镳鑣
镥鑥
镧鑭
钥鑰
镵鑱
镶鑲
镊鑷
镩鑹
锣鑼
钻鑽
銮鑾
凿鑿
䦆钁
长長
门門
闩閂
闪閃
闫閆
闬閈
闭閉
开開
闶閌
闳閎
闰閏
闲閒閑
间間
闵閔
闸閘
阂閡
阁閣
阀閥
闺閨
闽閩
阃閫
阆閬
闾閭
阅閱
阊閶
阉閹
阎閻
阏閼
阍閽
阈閾
阌閿
阒闃
板<闆
闱闈
阔闊
阕闋
阑闌
阇闍
阗闐
阘闒
闿闓
阖闔
阙闕
闯闖
关關
阚闞
阓闠
阐闡
辟<闢
阛闤
闼闥
坂>阪
陉陘
陕陝
阵陣
阴陰
陈陳
陆陸
阳陽
陧隉
队隊
阶階
陨隕
际際
随隨
险險
陦隯
隐隱
陇隴
隶隸
只<隻
隽雋
虽雖
双雙
雏雛
杂雜
鸡雞
离<離
难難
云<雲
电電
霡霢
雾霧
霁霽
雳靂
霭靄
叇靆
灵靈
叆靉
靓靚
静靜
䩄靦
靥靨
鼗鞀
巩鞏
鞒鞽
鞑韃
鞯韉
韦韋
韧韌
韨韍
韩韓
韪韙
韬韜
韫韞
韵韻
响響
页頁
顶頂
顷頃
项項
顺順
顸頇
须鬚須
顼頊
颂頌
颀頎
颃頏
预預
顽頑
颁頒
顿頓
颇頗
领領
颌頜
颉頡
颐頤
颏頦
头頭
颒頮
颊頰
颋頲
颕頴
颔頷
颈頸
颓頹
频頻
颗顆
题題
额額
颚顎
颜顏
颙顒
颛顓
愿<願
颡顙
颠顛
类類
颟顢
颢顥
顾顧
颤顫
颥顬
显顯
颦顰
颅顱
颞顳
颧顴
风風
飐颭
飑颮
飒颯
刮<颳
飓颶
飔颸
飏颺
飖颻
飕颼
飗飀
飘飄
飙飆
飚飈
飞飛
饣飠
饥飢
饤飣
饦飥
饨飩
饪飪
饫飫
饬飭
饭飯
饮飲
饴飴
饲飼
饱飽
饰飾
饳飿
饺餃
饸餄
饼餅
饷餉
养養
饵餌
饹餎
饻餏
饽餑
馁餒
饿餓
馂餕
饾餖
余<餘
肴<餚
馄餛
馃餜
饯餞
馅餡
馆館
糇餱
饧餳
馉餶
馇餷
馎餺
饩餼
馏餾
馊餿
馌饁
馍饃
馒饅
馐饈
馑饉
馓饊
馈饋
馔饌
饶饒
飨饗
餍饜
馋饞
馕饢
马馬
驭馭
冯馮
驮馱
驰馳
驯馴
驲馹
驳駁
驻駐
驽駑
驹駒
驵駔
驾駕
骀駘
驸駙
驶駛
驼駝
驷駟
骈駢
骇駭
骃駰
骆駱
骎駸
骏駿
骋騁
骍騂
骓騅
骔騌
骒騍
骑騎
骐騏
骛騖
骗騙
骙騤
䯄騧
骞騫
骘騭
骝騮
腾騰
驺騶
骚騷
骟騸
骡騾
蓦驀
骜驁
骖驂
骠驃
骢驄
驱驅
骅驊
骕驌
骁驍
骣驏
骄驕
验驗
惊<驚
驿驛
骤驟
驴驢
骧驤
骥驥
骦驦
骊驪
骉驫
肮<骯
髅髏
体<體
髌髕
髋髖
松<鬆
鬓鬢
斗<鬥
闹鬧
阋鬩
阄鬮
郁<鬱
鬶鬹
魉魎
魇魘
鱼魚
鱽魛
鱾魢
鲀魨
鲁魯
鲂魴
鱿魷
鲄魺
鲅鮁
鲆鮃
鲌鮊
鲉鮋
鲏鮍
鲇鮎
鲐鮐
鲍鮑
鲋鮒
鲊鮓
鲒鮚
鲘鮜
鲕鮞
䲟鮣
鲖鮦
鲔鮪
鲛鮫
鲑鮭
鲜鮮
鲓鮳
鲪鮶
鲝鮺
鲧鯀
鲠鯁
鲩鯇
鲤鯉
鲨鯊
鲬鯒
鲻鯔
鲯鯕
鲭鯖
鲞鯗
鲷鯛
鲴鯝
鲱鯡
鲵鯢
鲲鯤
鲳鯧
鲸鯨
鲮鯪
鲰鯫
鲶鯰
鲺鯴
鳀鯷
鲫鯽
鳊鯿
鳈鰁
鲗鰂
鳂鰃
䲠鰆
鲽鰈
鳇鰉
䲡鰌
鳅鰍
鲾鰏
鳄鱷鰐
鳆鰒
鳃鰓
鳒鰜
鳑鰟
鳋鰠
鲥鰣
鳏鰥
䲢鰧
鳎鰨
鳐鰩
鳍鰭
鳁鰮
鲢鰱
鳌鰲
鳓鰳
鳘鰵
鲦鰷
鲣鰹
鲹鰺
鳗鰻
鳛鰼
鳔鰾
鳉鱂
鳙鱅
鳕鱈
鳖鱉
鳟鱒
鳝鱔
鳜鱖
鳞鱗
鲟鱘
鲼鱝
鲎鱟
鲙鱠
鳣鱣
鳡鱤
鳢鱧
鲿鱨
鲚鱭
鳠鱯
鲈鱸
鲡鱺
鸟鳥
凫鳧
鸠鳩
鸤鳲
凤鳳
鸣鳴
鸢鳶
䴓鳾
鸩鴆
鸨鴇
鸦鴉
鸰鴒
鸵鴕
鸳鴛
鸲鴝
鸮鴞
鸱鴟
鸪鴣
鸯鴦
鸭鴨
鸸鴯
鸹鴰
鸻鴴
䴕鴷
鸿鴻
鸽鴿
䴔鵁
鸺鵂
鸼鵃
鹀鵐
鹃鵑
鹆鵒
鹁鵓
鹈鵜
鹅鵝
鹄鵠
鹉鵡
鹌鵪
鹏鵬
鹐鵮
鹎鵯
鹊鵲
鹓鵷
鹍鵾
䴖鶄
鸫鶇
鹑鶉
鹒鶊
鹋鶓
鹙鶖
鹕鶘
鹗鶚
鹖鶡
鹛鶥
鹜鶩
䴗鶪
鸧鶬
莺鶯
鹟鶲
鹤鶴
鹠鶹
鹡鶺
鹘鶻
鹣鶼
鹚鷀
鹢鷁
鹞鷂
䴘鷉鷈
鹝鷊
鹧鷓
鹥鷖
鸥鷗
鸷鷙
鹨鷚
鸶鷥
鹪鷦
鹔鷫
鹩鷯
鹫鷲
鹇鷳
鹬鷸
鹰鷹
鹭鷺
鸴鷽
䴙鸊鷿
㶉鸂
鹯鸇
鹱鸌
鹲鸏
鸬鸕
鹴鸘
鹦鸚
鹳鸛
鹂鸝
鸾鸞
卤鹵
咸<鹹
鹾鹺
盐鹽
丽麗
麦麥
麸麩
曲<麯
麹>麴
面<麵
黄黃
黉黌
点點
党<黨
黪黲
黡黶
黩黷
黾黽
鼋黿
鼍鼉
鼹鼴
齐齊
斋齋
赍齎
齑齏
齿齒
龀齔
龁齕
龂齗
龅齙
龇齜
龃齟
龆齠
龄齡
出<齣
龈齦
龊齪
龉齬
龋齲
腭齶
龌齷
龙龍
厐龎
庞龐
䶮龑
龚龔
龛龕
龟龜
䜤鿁
䲤鿐
鿓鿒`;

	const mapping$1 = sc2tc$1.split(/\r?\n/);
	mapping$1.push('“「');
	mapping$1.push('‘『');
	mapping$1.push('”」');
	mapping$1.push('’』');
	/*
	伪=偽僞   //對應兩個繁體字
	㐷=傌     //gb 與 big5 一對一 (繁體無㐷字)
	杰~傑     //繁體有「杰」字
	*/ const overwrite$1 = {
	    "获": "獲穫",
	    "缰": "繮韁",
	    "赝": "贋贗",
	    "伪": "僞偽",
	    "汇": "匯彙",
	    "坛": "壇罈",
	    "台": "臺颱檯",
	    "冲": "沖衝",
	    "硷": "礆鹼",
	    "绱": "緔鞝",
	    "脏": "臟髒",
	    "谫": "謭譾",
	    "钩": "鈎鉤",
	    "鿭": "鉨鑈",
	    "锈": "銹鏽",
	    "闲": "閑閒",
	    "须": "須鬚",
	    "鳄": "鰐鱷"
	};
	const t2s$1 = {}, t2s_unsafe1$1 = {}, s2t = {};
	mapping$1.forEach((line, idx)=>{
	    const r = line.match(/(.)(<?)(.+)/u);
	    if (!r) throw 'wrong data format ' + idx;
	    let [m, sc, op, tc] = r;
	    let oldtc = tc;
	    if (overwrite$1[sc]) tc = overwrite$1[sc];
	    if (op == '') {
	        if (tc.length == 1) {
	            t2s$1[tc] = sc;
	        } else {
	            if (tc[0] == '>') {
	                t2s_unsafe1$1[tc.substring(1)] = sc;
	            } else {
	                //历歷曆  , 发髮發 , 脏臟髒
	                t2s$1[tc[0]] = sc; //第一個繁體可以安全轉到簡體
	                tc = tc.substring(1);
	                for(let i = 0; i < tc.length; i++){
	                    const cp = tc.codePointAt(i); //考慮未來 surrogate
	                    if (!cp) break;
	                    t2s_unsafe1$1[String.fromCodePoint(cp)] = sc;
	                }
	            }
	        }
	    } else {
	        if (tc.length == 1) {
	            t2s_unsafe1$1[tc] = sc; //簡字也在big5中
	        } else {
	            while(tc && tc[0] !== '>'){
	                //接受 幹=>干 ,臺=>台 
	                const ch = String.fromCodePoint(tc.codePointAt(0));
	                t2s_unsafe1$1[ch] = sc;
	                tc = tc.substring(ch.length);
	            }
	        //最後剩六組  干乾  后後  复覆 征徵  于於  么幺麽
	        //繁體都收，不轉換
	        }
	    }
	    tc = oldtc.replace(/\>/g, '');
	    if (op == '<') {
	        s2t[sc] = tc.replace(sc, '') + sc; //簡字也可能是繁字 ， 簡字「面」 可能是繁字的「麵」或「面」
	    } else s2t[sc] = tc;
	});
	const toSim$1 = (s, mode = 1)=>{
	    if (!s) return s;
	    let out = '', i = 0;
	    if (!mode) return s;
	    while(i < s.length){
	        const cp = s.codePointAt(i);
	        const ucs4 = String.fromCodePoint(cp);
	        if (!ucs4) break;
	        let sc = t2s$1[ucs4];
	        if (mode == 2 && !sc) sc = t2s_unsafe1$1[ucs4];
	        out += sc || ucs4;
	        i++;
	        if (cp > 0xffff) i++;
	    }
	    return out;
	};
	const fromSim = (s, mode = 1, bracket = '()')=>{
	    let out = '', i = 0;
	    if (!mode || !s) return s;
	    while(i < s.length && s[i]){
	        const cp = s.codePointAt(i);
	        const ucs4 = String.fromCodePoint(cp);
	        if (!ucs4) break;
	        let tc = s2t[ucs4];
	        if (!tc) {
	            out += ucs4; //沒有繁體
	        } else if (mode == 1 && !tc.codePointAt(1)) {
	            out += tc;
	        } else if (mode == 2) {
	            out += String.fromCodePoint(tc.codePointAt(0)); //選第一個
	        } else if (mode == 3) {
	            if (tc.codePointAt(1)) out += bracket[0] + tc + bracket[1];
	            else out += tc;
	        } else out += ucs4; //保留不變
	        i++;
	        if (cp > 0xffff) i++;
	    }
	    return out;
	};

	class Inverted {
	    nPostingOf(s) {
	        const out = [];
	        const tokens = tokenize(s);
	        for(let i = 0; i < tokens.length; i++){
	            const { type, text } = tokens[i];
	            let at = -1;
	            if (type == TokenType.CJK_BMP) {
	                const cp = text.charCodeAt(0);
	                at = bsearchNumber(this.bmpwithposting, cp);
	                if (this.bmpwithposting[at] !== cp) {
	                    //try sim
	                    const cpsim = fromSim(text).charCodeAt(0);
	                    at = bsearchNumber(this.bmpwithposting, cpsim);
	                    if (this.bmpwithposting[at] !== cpsim) continue;
	                }
	            } else if (type >= TokenType.SEARCHABLE) {
	                if (~at) at += this.bmppostingcount;
	                else {
	                    let at2 = this.words.find(s);
	                    if (~at2) at = at2 + this.bmppostingcount;
	                }
	            }
	            out.push(at);
	        }
	        return out;
	    }
	    constructor(section, postingStart){
	        this.words = new StringArray(section.shift(), {
	            sep: LEMMA_DELIMITER
	        });
	        this.bmpwithposting = unpackIntDelta(section.shift());
	        this.tokenlinepos = unpackIntDelta(section.shift());
	        this.postings = []; //holding loaded postings
	        this.postingStart = postingStart;
	        this.bmppostingcount = 0; //long token starts from here
	        for(let i = 1; i < 65536; i++){
	            if (this.bmpwithposting[i]) this.bmppostingcount++;
	        }
	    }
	}

	/*inspired by https://github.com/Siderite/SortedArrayIntersect AcceleratingIntersercter*/ const plFind = (arr, v, p = 0)=>{
	    let speed = 1;
	    let p2 = p;
	    while(p2 < arr.length){
	        if (v > arr[p2]) {
	            speed++;
	        } else {
	            if (speed <= 1) break;
	            p2 -= speed;
	            speed = 1;
	        }
	        p2 += speed;
	    }
	    return p2;
	};
	const plAnd = (pl1, pl2, dist = 1)=>{
	    let p2 = 0, c = 0;
	    if (!pl1 || !pl2 || pl1.length == 0 || pl2.length == 0) return [];
	    Math.min(pl1.length, pl2.length);
	    let out = [];
	    for(let p1 = 0; p1 < pl1.length; p1++){
	        let v1 = pl1[p1] + dist;
	        let v2 = pl2[p2];
	        while(v1 > v2 && p2 < pl2.length)v2 = pl2[++p2];
	        if (v1 === v2) {
	            out[c++] = v1 - dist;
	        }
	    }
	    return out.slice(0, c);
	};
	const plCount = (pl, plgroup)=>{
	    let p = 0, start = 0, end = 0;
	    const out = [];
	    for(let i = 0; i < plgroup.length; i++){
	        const [from, to] = plgroup[i];
	        start = p;
	        //search this book than ak
	        if (from > pl[p]) start = plFind(pl, from, p);
	        end = start;
	        while(pl[end] < to && end < pl.length)end++;
	        if (end > start) {
	            out[i] = end - start;
	        } else out[i] = 0;
	        p = end;
	    }
	    for(let i = 0; i < out.length; i++){
	        if (typeof out[i] !== 'number') out[i] = 0;
	    }
	    return out;
	};
	const plTrim = (pl, from, to)=>{
	    const at1 = bsearchNumber(pl, from);
	    let at2 = bsearchNumber(pl, to) + 1;
	    const out = pl.slice(at1, at2);
	    while(out[0] < from)out.shift();
	    while(out[out.length - 1] > to)out.pop();
	    return out;
	};
	const plRanges = (posting, ranges)=>{
	    if (!ranges || !ranges.length) return posting;
	    const out = [];
	    let j = 0, r = ranges[j];
	    for(let i = 0; i < posting.length; i++){
	        const p = posting[i];
	        if (p >= r[0] && r[1] >= p) out.push(p);
	        while(p > r[0] && j < ranges.length - 1){
	            r = ranges[++j];
	        }
	        if (j >= ranges.length) break;
	    }
	    return out;
	};
	const plContain = (posting, ltp, withHits = false)=>{
	    let i = 0;
	    const lines = [], hits = [];
	    while(i < posting.length){
	        let p = posting[i];
	        let at = bsearchNumber(ltp, p);
	        if (at >= 0 && at < ltp.length) {
	            if (lines[lines.length - 1] !== at) {
	                lines.push(at);
	            }
	            if (withHits) {
	                if (!hits[lines.length - 1]) hits[lines.length - 1] = [];
	                hits[lines.length - 1].push(p - ltp[at - 1]);
	            }
	            p = posting[i];
	        }
	        i++;
	    }
	    return [
	        lines,
	        hits
	    ];
	};

	function loadPostingsSync(s) {
	    const ptk = this;
	    const nPostings = ptk.inverted.nPostingOf(s);
	    for(let i = 0; i < nPostings.length; i++){
	        const at = nPostings[i];
	        if (at == -1) continue;
	        const line = ptk.inverted.postingStart + nPostings[i];
	        if (!ptk.inverted.postings[at]) {
	            const packedline = ptk.getLine(line);
	            ptk.inverted.postings[at] = unpackIntDelta(packedline);
	        }
	    }
	    return this.getPostings(s);
	}
	function getPostings(s) {
	    const nPostings = this.inverted.nPostingOf(s);
	    const postings = this.inverted.postings;
	    return nPostings.map((np)=>postings[np]);
	}
	const loadPostinglines = async (ptk, s)=>{
	    if (!ptk.inverted) return;
	    const nPostings = ptk.inverted.nPostingOf(s);
	    const postinglines = [];
	    for(let i = 0; i < nPostings.length; i++){
	        if (nPostings[i] < 0) continue;
	        const line = ptk.inverted.postingStart + nPostings[i];
	        postinglines.push([
	            line,
	            line + 1
	        ]);
	    }
	    //must sort for combineRange
	    postinglines.sort((a, b)=>a[0] - b[0]);
	    await ptk.loadLines(postinglines);
	    return postinglines;
	};
	async function loadPostings(s) {
	    const ptk = this;
	    await loadPostinglines(ptk, s);
	    return ptk.loadPostingsSync.call(ptk, s);
	}

	const listExcerpts = async (ptk, tofind, opts = {})=>{
	    var _ptk_inverted;
	    if (!ptk) return {};
	    const tlp = (_ptk_inverted = ptk.inverted) === null || _ptk_inverted === void 0 ? void 0 : _ptk_inverted.tokenlinepos;
	    if (!tlp) return {};
	    let sectionfrom = 0, sectionto = 0;
	    if (opts.range) {
	        const [first, last] = ptk.rangeOfAddress(opts.range);
	        sectionfrom = tlp[first];
	        sectionto = tlp[last];
	    } else {
	        sectionfrom = tlp[0];
	        sectionto = tlp[ptk.header.eot];
	    }
	    const [phrases, postings] = await ptk.parseQuery(tofind, {
	        tosim: ptk.attributes.lang == 'zh'
	    });
	    let chunkobj = {}, lineobj = {}, hitcount = 0;
	    const chunklinepos = (ptk.defines.ck || ptk.defines.dk).linepos;
	    const chunktag = ptk.defines.ck ? 'ck' : 'dk';
	    for(let i = 0; i < postings.length; i++){
	        const pl = plTrim(postings[i], sectionfrom, sectionto);
	        const [pllines, lineshits] = plContain(pl, ptk.inverted.tokenlinepos, true);
	        const phraselen = phrases[i].length;
	        hitcount += pl.length;
	        for(let j = 0; j < pllines.length; j++){
	            const line = pllines[j];
	            let removed = false;
	            if (opts.includelines) {
	                const at = bsearchNumber(opts.includelines, line);
	                if (opts.includelines[at] !== line) removed = true;
	            }
	            if (opts.excludelines) {
	                const at = bsearchNumber(opts.excludelines, line);
	                if (opts.excludelines[at] == line) removed = true;
	            }
	            if (removed) continue;
	            if (!lineobj[line]) lineobj[line] = [];
	            lineobj[line].push(...lineshits[j].map((it)=>it * MAXPHRASELEN + phraselen));
	            const at = bsearchNumber(chunklinepos, line + 1) - 1;
	            if (!chunkobj[at]) {
	                chunkobj[at] = 0;
	            }
	            chunkobj[at]++;
	        }
	    }
	    const lines = fromObj(lineobj, (a, b)=>[
	            parseInt(a),
	            b.sort()
	        ]).sort((a, b)=>a[0] - b[0]);
	    const chunks = fromObj(chunkobj, (a, b)=>[
	            parseInt(a),
	            b
	        ]).sort((a, b)=>b[1] - a[1]);
	    return {
	        lines,
	        chunks,
	        phrases,
	        postings,
	        chunktag
	    };
	};

	const MAX_PHRASE = 5;
	const scoreMatch = (matching, weights)=>{
	    if (matching.length == 0) return 0;
	    let score = 0, matchcount = 0;
	    for(let j = 0; j < weights.length; j++){
	        if (matching[j]) {
	            matchcount++;
	            score += weights[j] * (matching[j] > 1 ? Math.sqrt(matching[j]) : 1); //出現一次以上，效用递減
	        }
	    }
	    let boost = matchcount / weights.length;
	    boost *= boost; // 有兩個詞，只有一個詞有hit ，那boost只有 0.25。
	    return score * boost;
	};
	function scoreLine(postings, chunklinepos, tlp) {
	    tlp = tlp || this.inverted.tokenlinepos, tlplast = tlp[tlp.length - 1];
	    chunklinepos = chunklinepos || this.defines.ck.linepos;
	    const averagelinelen = tlplast / tlp.length;
	    const allhits = postings.reduce((acc, i)=>i.length + acc, 0);
	    const weights = postings.map((pl)=>Math.sqrt(allhits / pl.length));
	    let i = 0, scoredLine = [];
	    const ptr = new Array(postings.length);
	    ptr.fill(0);
	    let prev = 0;
	    while(i < tlp.length - 1){
	        let nearest = tlplast;
	        const from = tlp[i], to = tlp[i + 1];
	        let matching = [];
	        prev = 0;
	        for(let j = 0; j < postings.length; j++){
	            const pl = postings[j];
	            let v = pl[ptr[j]];
	            while(v < from && ptr[j] < pl.length){
	                ptr[j]++;
	                v = pl[ptr[j]];
	            }
	            while(v >= from && v < to){
	                if (!matching[j]) matching[j] = 0;
	                matching[j]++; //each hit has a base score 1
	                if (j == 0) prev = v; // score closer token
	                else {
	                    const dist = v - prev - j;
	                    if (dist == 0) {
	                        matching[j] += 3;
	                    } else {
	                        matching[j] += 1 / dist;
	                    }
	                }
	                ptr[j]++;
	                v = pl[ptr[j]];
	            }
	            if (nearest > v) nearest = v;
	        }
	        const score = scoreMatch(matching, weights);
	        //boost single phrase search with linelen, shorter line get higher score
	        let shortpara = 10 * (averagelinelen / (to - from + 1)); //short para get value > 1
	        if (shortpara < 10) shortpara = 10;
	        //出現次數相同，較短的段落優先
	        const boost = Math.log(shortpara); //boost 不小於 1
	        if (score > 0) {
	            const chunk = bsearchNumber(chunklinepos, i) - 1;
	            scoredLine.push([
	                i + 1,
	                score * boost,
	                chunk
	            ]); //y is 1 base
	        }
	        i++;
	        while(nearest > tlp[i + 1])i++;
	    }
	    scoredLine = scoredLine.sort((a, b)=>b[1] - a[1]);
	    return scoredLine;
	}
	function phraseQuerySync(phrase, tokens = null) {
	    tokens = tokens || this.loadPostingsSync(phrase);
	    if (!tokens) return [];
	    phrase = phrase.trim();
	    const qkey = this.name + '@' + phrase;
	    let out = this.queryCache[qkey];
	    if (out) return out;
	    out = tokens[0];
	    for(let i = 1; i < tokens.length; i++){
	        let pl1 = out;
	        out = plAnd(pl1, tokens[i], i);
	    }
	    this.queryCache[qkey] = out || [];
	    return this.queryCache[qkey];
	}
	async function phraseQuery(phrase) {
	    const tokens = await this.loadPostings(phrase);
	    if (!tokens) return [];
	    return phraseQuerySync.call(this, phrase, tokens);
	}
	async function parseQuery(tofind, opts) {
	    opts = opts || {};
	    const phrases = tofind.split(/[, 　]/);
	    if (phrases.length > MAX_PHRASE) phrases.length = MAX_PHRASE;
	    const outphrases = [], postings = [];
	    for(let i = 0; i < phrases.length; i++){
	        if (!phrases[i].trim()) continue;
	        let posting = await phraseQuery.call(this, phrases[i]);
	        if ((!posting || !posting.length) && this.attributes.lang == 'zh') {
	            posting = await phraseQuery.call(this, fromSim(phrases[i]));
	        }
	        if (opts.ranges && opts.ranges.length) {
	            posting = plRanges(posting, opts.ranges);
	        }
	        outphrases.push(phrases[i]);
	        postings.push(posting || []);
	    }
	    return [
	        outphrases,
	        postings
	    ];
	}
	async function scanText(tofind, opts) {
	    const ptk = this;
	    const [phrases, postings] = await ptk.parseQuery(tofind, opts);
	    if (!postings.length || !ptk.inverted) return [];
	    const tagname = (opts === null || opts === void 0 ? void 0 : opts.groupby) || 'ak';
	    const groupby = ptk.defines[tagname];
	    const tlp = [], TLP = ptk.inverted.tokenlinepos;
	    if (groupby) {
	        for(let i = 0; i < groupby.linepos.length; i++){
	            const nextstart = TLP[groupby.linepos[i + 1]] || TLP[TLP.length - 1];
	            tlp.push([
	                TLP[groupby.linepos[i]],
	                nextstart
	            ]);
	        }
	        const res = new Array(tlp.length);
	        res.fill(0);
	        for(let i = 0; i < postings.length; i++){
	            const res1 = plCount(postings[i], tlp);
	            for(let j = 0; j < tlp.length; j++){
	                res[j] += res1[j];
	            }
	        }
	        const out = res.map((count, idx)=>{
	            const id = groupby.fields.id.values[idx];
	            return {
	                count,
	                caption: groupby.getInnertext(idx),
	                scope: tagname + (parseInt(id) ? id : '#' + id)
	            };
	        });
	        return out;
	    } else {
	        return [
	            {
	                count: postings.length,
	                caption: '-',
	                name: '-'
	            }
	        ];
	    }
	}
	function hitsOfLine(line, allpostings) {
	    const tlp = this.inverted.tokenlinepos;
	    const hits = [];
	    for(let i = 0; i < allpostings.length; i++){
	        const from = tlp[line - 1], till = tlp[line];
	        const hit = plTrim(allpostings[i], from, till).map((it)=>it - from);
	        hits.push(hit);
	    }
	    return hits;
	}
	const tofindInSentence = (sentence, pos = 0, len = 0)=>{
	    if (pos == -1) {
	        return [
	            sentence
	        ];
	    }
	    let tofinds = Array();
	    if (len > 0) {
	        return [
	            sentence.slice(pos, pos + len)
	        ];
	    }
	    if (sentence.length < 4) tofinds.push(sentence);
	    for(let i = pos; i <= sentence.length; i++){
	        let t = sentence.slice(pos, i);
	        if (t.length > 1) tofinds.push(t.trim());
	        t = sentence.slice(pos - 1, i);
	        if (t.length > 1) tofinds.push(t.trim());
	        t = sentence.slice(pos + 1, i);
	        if (t.length > 1) tofinds.push(t.trim());
	        if (t.length > 5) continue;
	    }
	    return unique(tofinds);
	};
	const statSentencePhrase = (tofinds, postings)=>{
	    const out = {};
	    if (tofinds.length == 0) {
	        return [];
	    } else if (tofinds.length == 1) {
	        return [
	            [
	                tofinds[0],
	                postings[0]
	            ]
	        ];
	    }
	    const total = postings.reduce((p, n, i)=>p + Math.log(tofinds[i].length * n.length), 0);
	    const avg = total / postings.length;
	    for(let i = 0; i < postings.length; i++){
	        if (Math.log(postings[i].length * tofinds[i].length) > avg && postings[i].length > 1) {
	            out[tofinds[i]] = postings[i];
	        }
	    }
	    if (!Object.keys(out).length) {
	        for(let i = 0; i < postings.length; i++){
	            out[tofinds[i]] = postings[i];
	        }
	    }
	    //dedup 諸比  諸比丘, 衛國  , 舍衛國
	    for(let key in out){
	        for(let shortkey in out){
	            if (key == shortkey || !out[shortkey].length) continue;
	            if ((key.startsWith(shortkey) || key.endsWith(shortkey)) && out[key].length * 1.1 >= out[shortkey].length) {
	                out[shortkey] = [];
	            }
	        }
	    }
	    for(let key in out){
	        if (out[key].length == 0) delete out[key];
	    }
	    return sortObj(out, (a, b)=>b[1].length - a[1].length).slice(0, 3);
	};
	async function searchSentence(sentence, pos = 0, len = 0) {
	    const out = [];
	    const tofinds = tofindInSentence(sentence.trim(), pos);
	    for(let i = 0; i < tofinds.length; i++){
	        const tf = tofinds[i];
	        out.push(await phraseQuery.call(this, tf));
	    }
	    return statSentencePhrase(tofinds, out);
	}
	function searchSentenceSync(sentence, pos = 0, len = 0) {
	    if (!sentence.trim()) return [];
	    const tofinds = tofindInSentence(sentence, pos, len);
	    const out = tofinds.map((it)=>phraseQuerySync.call(this, it));
	    return statSentencePhrase(tofinds, out);
	}

	function _define_property$8(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	class RenderUnit {
	    tagsOf(closing = false) {
	        const out = [];
	        if (!this.tags || !this.tags.length) return '';
	        for(let i = 0; i < this.tags.length; i++){
	            const tag = this.offtext.getTag(this.tags[i]);
	            if (this.choff == tag.choff + (closing ? tag.width - 1 : 0)) {
	                out.push(this.tags[i]);
	            }
	        }
	        return out;
	    }
	    closestTag() {
	        return this.offtext.getTag(this.tags[this.tags.length - 1]);
	    }
	    constructor(token, ntoken, offtext, postingoffset){
	        _define_property$8(this, "token", void 0 //raw token from tokenize
	        );
	        _define_property$8(this, "open", void 0 //tag open at this token
	        );
	        _define_property$8(this, "close", void 0 //tag close at this token
	        );
	        _define_property$8(this, "text", void 0 //the text to display
	        );
	        _define_property$8(this, "css", void 0 //the classes of css
	        );
	        _define_property$8(this, "hide", void 0 //hide the text
	        );
	        _define_property$8(this, "postingoffset", void 0);
	        _define_property$8(this, "choff", void 0);
	        _define_property$8(this, "ntoken", void 0);
	        _define_property$8(this, "tags", void 0);
	        _define_property$8(this, "luminate", void 0);
	        _define_property$8(this, "highlight", void 0);
	        _define_property$8(this, "offtext", void 0);
	        _define_property$8(this, "extra", void 0);
	        this.token = token;
	        this.postingoffset = postingoffset; //relative offset of posting (indexable token)
	        this.choff = token.choff; //for sorting
	        this.text = token.text; //perform text transformation here
	        this.ntoken = ntoken; //base on a concrete token
	        this.offtext = offtext; //the offtext object
	        this.tags = []; //tags covering this token
	        this.hide = false;
	        this.luminate = 0; //highlight luminates surrounding token, for abridge
	        this.highlight = false;
	        this.css = '';
	    }
	}
	const findUnitText = (runits, text, from = 0)=>{
	    for(let i = from; i < runits.length; i++){
	        if (runits[i].token.text === text) return runits[i];
	    }
	};
	const renderOfftext = (linetext = '', opts = {})=>{
	    const extra = opts.extra || [];
	    const hits = opts.hits || [];
	    const phraselength = opts.phraselength || [];
	    // const [plain,tags]=parseOfftext(linetext);
	    const ot = new Offtext(linetext, opts.line || 0);
	    let postingoffset = 0;
	    const runits = tokenize(ot.plain).map((tk, idx)=>{
	        postingoffset++; //unsearchable token also increase posting offset
	        const ru = new RenderUnit(tk, idx, ot, postingoffset);
	        return ru;
	    });
	    const tagsAt = []; //tags at plain position
	    let phit = 0, pextra = 0;
	    for(let i = 0; i < ot.tags.length; i++){
	        const tag = ot.tags[i];
	        // j<tag.choff+tag.width 的話， 零字長 class 無法作用
	        // 整行標記之後 應有一半行空格，就不會塗到第一個字
	        const width = tag.width ? tag.width : 1;
	        for(let j = tag.choff; j < tag.choff + width; j++){
	            if (!tagsAt[j]) tagsAt[j] = [];
	            tagsAt[j].push(i);
	        }
	    }
	    for(let i = 0; i < runits.length; i++){
	        const ru = runits[i];
	        ru.tags = tagsAt[ru.token.choff] || [];
	        if (extra.length && pextra < extra.length) {
	            if (ru.choff == extra[pextra].choff) {
	                // const tlen=extra[pextra].text.length;
	                ru.extra = extra[pextra];
	                pextra++;
	            }
	        }
	        if (hits && hits.length && phit < hits.length) {
	            if (ru.postingoffset >= hits[phit] && ru.postingoffset < hits[phit] + phraselength[phit] && ru.token.type >= TokenType.SEARCHABLE) {
	                ru.highlight = true;
	            }
	            if (hits[phit] + phraselength[phit] <= ru.postingoffset) phit++;
	            if (ru.highlight) {
	                ru.luminate++;
	                let j = i + 1;
	                while(j < runits.length){
	                    if (runits[j].token.type >= TokenType.SEARCHABLE || j - i < MIN_ABRIDGE) j++;
	                    else break;
	                    if (j < runits.length) runits[j].luminate++;
	                }
	                j = i - 1;
	                while(j > 0){
	                    if (runits[j].token.type >= TokenType.SEARCHABLE || i - j < MIN_ABRIDGE) j--;
	                    else break;
	                    if (j >= 0) runits[j].luminate++;
	                }
	            }
	        }
	        const bracket = closeBracketOf(ru.text);
	        if (ru.hide || ru.tags.length && bracket) {
	            ru.hide = true;
	            const closeAt = findUnitText(runits, bracket, i + 1);
	            if (closeAt) closeAt.hide = true;
	        }
	    }
	    return [
	        runits,
	        ot
	    ];
	};
	const abridgeRenderUnits = (runits, minwidth = 10)=>{
	    const out = [];
	    let abridged = [];
	    const addAbridge = (final = false)=>{
	        if (abridged.length > MIN_ABRIDGE) {
	            out.push([
	                abridged.length,
	                abridged[0],
	                final
	            ]);
	        } else {
	            for(let j = 0; j < abridged.length; j++){
	                out.push(runits[abridged[j]]);
	            }
	        }
	        abridged = [];
	    };
	    if (runits.length < minwidth) return runits;
	    for(let i = 0; i < runits.length; i++){
	        const ru = runits[i];
	        if (ru.luminate) {
	            addAbridge();
	            out.push(ru);
	        } else {
	            abridged.push(i);
	        }
	    }
	    addAbridge(true);
	    return out;
	};

	const m$1 = typeof navigator !== 'undefined' && navigator.userAgent.match(/Chrome\/(\d+)/);
	m$1 && parseInt(m$1[1]) >= 86;

	let _pool = {};
	const poolGet = (name)=>_pool[name];
	const poolAdd = (name, inst)=>_pool[name] = inst;
	const poolDel = (name)=>delete _pool[name];
	const poolGetAll = ()=>{
	    const out = Array();
	    for(const name in _pool){
	        out.push(_pool[name]);
	    }
	    return out;
	};
	const poolParallelPitakas = (ptk)=>{
	    var _ptk_attributes;
	    let align = (_ptk_attributes = ptk.attributes) === null || _ptk_attributes === void 0 ? void 0 : _ptk_attributes.align;
	    if (!align) align = ptk.name.replace(/\-[^-]+$/, '');
	    const out = Array();
	    for(const n in _pool){
	        if (_pool[n].attributes.align == align || n.replace(/\-[^-]+$/, '') == align) {
	            if (ptk.name !== _pool[n].name) out.push(n);
	        }
	    }
	    return out;
	};

	const pagefilename = (page)=>page.toString().padStart(3, '0') + '.js';
	const makePageURI = (folder, page)=>{
	    const fn = folder + '/' + pagefilename(page);
	    return fn;
	};
	async function loadNodeJs(page) {
	    let fn = makePageURI(this.name, page);
	    //try sibling folder
	    if (!fs.existsSync(fn) && fs.existsSync('../' + this.name + '/' + this.name)) {
	        fn = makePageURI('../' + this.name + '/' + this.name, page);
	    }
	    try {
	        const data = await fs.promises.readFile(fn, 'utf8');
	        this.setPage(page, ...parseJsonp(data));
	    } catch (e) {
	        console.error('readFile failed,', fn, e);
	    }
	}
	async function loadRemoteZip(page) {
	    throw "not implement yet";
	}
	async function loadInMemoryZipStore(page) {
	    const fn = this.name + '/' + pagefilename(page);
	    const f = this.zipstore.find(fn);
	    const content = f && new TextDecoder().decode(f.content);
	    content && this.setPage(page, ...parseJsonp(content));
	}
	async function loadFetch(page) {
	    if (this.zip) {
	        const data = await this.zip.readTextFile(this.name + '/' + pagefilename(page));
	        this.setPage(page, ...parseJsonp(data));
	        return;
	    }
	    const uri = makePageURI(this.name, page);
	    try {
	        const res = await fetch(uri);
	        const text = await res.text();
	        const arr = parseJsonp(text);
	        this.setPage(page, ...arr);
	    } catch (e) {
	        this.failed = true;
	    }
	}
	const jsonp = (page, header, _payload)=>{
	    const ptk = poolGet(header.name);
	    ptk.setPage(page, header, _payload);
	};
	function isLoaded(page) {
	    return page == 0 ? this.pagestarts.length : this._pages[page - 1];
	}
	async function loadJSONP(page) {
	    if (isLoaded.call(this, page)) return;
	    if (!typeof window.jsonp !== 'function') {
	        window.jsonp = jsonp;
	    }
	    let tried = 0, timer;
	    const that = this;
	    try {
	        const status = await loadScript(makePageURI(that.name, page), ()=>{
	            if (isLoaded.call(that, page)) return true;
	            //wait for jsonp() to setPage
	            timer = setInterval(()=>{
	                tried++;
	                if (tried > 10 || isLoaded.call(that, page)) {
	                    if (tried > 10) console.error('failed loading page', page, that.name);
	                    clearInterval(timer);
	                }
	            }, 10);
	        });
	    } catch (e) {
	        this.failed = true;
	    }
	}

	function _define_property$7(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	let instancecount = 0;
	const combineRange = (range)=>{
	    const combined = Array();
	    let from = 0;
	    range = range.filter((it)=>!!it);
	    if (Array.isArray(range[0]) && range.length) {
	        range.sort((a, b)=>a - b);
	        from = range[0][0];
	        for(let i = 1; i < range.length; i++){
	            if (range[i][0] > range[i - 1][1]) {
	                combined.push([
	                    from,
	                    range[i - 1][1]
	                ]);
	                from = range[i][0];
	            }
	        }
	        if (range[range.length - 1][1] > from) combined.push([
	            from,
	            range[range.length - 1][1]
	        ]);
	    } else {
	        return range;
	    }
	    return combined;
	};
	class LineBase {
	    async loadAll() {
	        await this.loadLines([
	            [
	                0,
	                this.pagestarts[this.pagestarts.length - 1]
	            ]
	        ]);
	        return this.slice(0, this.pagestarts[this.pagestarts.length - 1]);
	    }
	    inMem() {
	        return this.inmemory || this.zipstore;
	    }
	    pageOfRange([from, to]) {
	        if (from < 0) return [];
	        if (from > to) to += from;
	        let cstart = this.pageOfLine(from);
	        const cend = this.pageOfLine(to);
	        const notloaded = Array();
	        if (cstart > 1) cstart--; //fetch previous page
	        for(let i = cstart; i < cend + 1; i++){
	            if (!this._pages[i]) notloaded.push(i);
	        }
	        return notloaded;
	    }
	    async loadLines(_range) {
	        const that = this; //load a range, or a sequence of line or range.
	        let toload = Array(), range = combineRange(_range);
	        const notincache = {};
	        for(let i = 0; i < range.length; i++){
	            if (Array.isArray(range[i])) {
	                const [from, to] = range[i];
	                toload.push(...this.pageOfRange([
	                    from,
	                    to
	                ]));
	            } else {
	                notincache[this.pageOfLine(range[i])] = true;
	            }
	        }
	        toload.push(...Object.keys(notincache).map((it)=>parseInt(it)));
	        toload = unique(toload.filter((it)=>!that._pages[it]));
	        const jobs = Array();
	        for(let i = 0; i < toload.length; i++){
	            jobs.push(this._loader.call(this, toload[i] + 1));
	        }
	        await Promise.all(jobs);
	    }
	    lineCount() {
	        return this.header.starts[this.header.starts.length - 1];
	    }
	    getPageLineOffset(page, line) {
	        if (page > this._pages.length) return 0;
	        if (line == 0) return 0;
	        if (line > this._lineoffsets[page].length) return this._pages[page].length;
	        return this._lineoffsets[page][line - 1];
	    }
	    getLines(nlines) {
	        if (!nlines.length) return [];
	        let out = Array();
	        let pline = nlines[0];
	        let start = pline;
	        for(let i = 1; i < nlines.length; i++){
	            if (pline + 1 !== nlines[i]) {
	                out = out.concat(this.slice(start, i));
	                start = nlines[i];
	            }
	            pline = nlines[i];
	        }
	        out = out.concat(this.slice(start, pline + 1));
	        return out;
	    }
	    getLine(nline) {
	        return this.slice(nline, nline + 1)[0];
	    }
	    slice(nline, to) {
	        if (!to) to = nline + 1;
	        const p1 = this.pageOfLine(nline);
	        const p2 = this.pageOfLine(to);
	        let out = '';
	        for(let i = p1; i <= p2; i++){
	            if (!this._pages[i]) return out.split('\n'); //page not loaded yet
	            if (i == p1 || i == p2) {
	                let slicefrom = this.getPageLineOffset(i, nline - (p1 > 0 ? this.pagestarts[p1 - 1] : 0));
	                if (nline) slicefrom++; //skip the \n for first line
	                const sliceto = this.getPageLineOffset(i, to - (p2 > 0 ? this.pagestarts[p2 - 1] : 0));
	                if (p2 > p1) {
	                    const append = this._pages[i].slice(0, sliceto);
	                    if (i == p1) out = this._pages[i].slice(slicefrom); //+1 skip the \n
	                    else out += (out && append ? '\n' : '') + append; //add extra \n if append is not null
	                //do not allow empty line become the first line
	                } else {
	                    out += this._pages[i].slice(slicefrom, sliceto);
	                }
	            //} else out+='\n'+this._pages[i];//middle , 2024/9/16 excessive \n for loading tag section
	            } else out += (out.length ? '\n' : '') + this._pages[i]; //dirty workaround
	        }
	        return out.split('\n');
	    }
	    setPage(page, header, payload) {
	        if (page == 0) {
	            this.header = header;
	            this.name = this.header.name;
	            this.pagestarts = header.starts;
	            this.payload = payload || 'nopayload';
	            this.opened = true;
	        } else if (page > 0) {
	            this._pages[page - 1] = payload;
	            this._lineoffsets[page - 1] = lineBreaksOffset(payload);
	        }
	    }
	    isReady() {
	        if (this.payload) return true;
	        const that = this;
	        let timer;
	        return new Promise((resolve)=>{
	            timer = setInterval(()=>{
	                if (that.failed) resolve(false); //set by loadScript, loadFetch
	                else if (that.payload) {
	                    clearInterval(timer);
	                    resolve(true);
	                }
	            }, 50);
	        });
	    }
	    getSection(name) {
	        const [from, to] = this.sectionRange(name);
	        if (from == to) return [];
	        return this.slice(from, to);
	    }
	    sectionRange(sname) {
	        const { sectionnames, sectionstarts } = this.header;
	        if (!sectionnames || !sectionnames.length) return [
	            0,
	            0
	        ];
	        for(let i = 0; i < sectionnames.length; i++){
	            const name = sectionnames[i];
	            if (sname && name == sname) {
	                const endoflastsection = i < sectionstarts.length - 1 ? sectionstarts[i + 1] : this.pagestarts[this.pagestarts.length - 1];
	                return [
	                    sectionstarts[i],
	                    endoflastsection
	                ];
	            }
	        }
	        return [
	            0,
	            0
	        ];
	    }
	    constructor(opts){
	        _define_property$7(this, "_pages", void 0);
	        _define_property$7(this, "_lineoffsets", void 0);
	        _define_property$7(this, "stamp", void 0);
	        _define_property$7(this, "pagestarts", void 0);
	        _define_property$7(this, "header", void 0);
	        _define_property$7(this, "name", void 0);
	        _define_property$7(this, "zip", void 0);
	        _define_property$7(this, "zipstore", void 0);
	        _define_property$7(this, "payload", void 0);
	        _define_property$7(this, "_loader", void 0);
	        _define_property$7(this, "failed", void 0);
	        _define_property$7(this, "inmemory", void 0);
	        _define_property$7(this, "opened", void 0);
	        _define_property$7(this, "pageOfLine", (line)=>{
	            if (line >= this.pagestarts[this.pagestarts.length - 1]) return this.pagestarts.length - 1;
	            return bsearchNumber(this.pagestarts, line);
	        });
	        this.stamp = ++instancecount;
	        this._pages = []; // read time,   line not split
	        this._lineoffsets = []; // lineoffsets of each page
	        this.pagestarts = [];
	        this.header = {
	            starts: Array(),
	            sectionnames: Array(),
	            sectionstarts: Array(),
	            sectiontypes: Array(),
	            preload: Array(),
	            name: ''
	        };
	        this.name = opts.name || '';
	        this.zip = opts.zip;
	        this.zipstore = opts.zipstore;
	        this.payload; //payload in 000.js
	        let protocol = typeof chrome !== 'undefined' ? 'chrome-extension:' : '';
	        //this._loader=()=>{};
	        if (typeof window !== 'undefined') {
	            protocol = window.location.protocol;
	        }
	        if (this.zipstore) {
	            this._loader = loadInMemoryZipStore;
	        } else if (protocol === 'http:' || protocol === 'https:' || protocol === 'chrome-extension:') {
	            this._loader = loadFetch;
	        } else if (protocol == 'file:') {
	            this._loader = loadJSONP;
	        } else {
	            this._loader = this.zip ? loadRemoteZip : loadNodeJs;
	        }
	        this.failed = false;
	        if (opts.contentString) {
	            const [headerstr, len] = extractObject(opts.contentString);
	            const header = JSON.parse(headerstr);
	            const lines = opts.contentString.slice(len).split('\n');
	            const payload = (lines.shift() || '').replace(/\\n/g, '\n');
	            this.setPage(0, header, payload);
	            for(let i = 0; i < header.starts.length; i++){
	                const pagedata = lines.slice(i > 0 ? header.starts[i - 1] : 0, header.starts[i]);
	                this.setPage(i + 1, {}, pagedata.join('\n'));
	            }
	            this.inmemory = true;
	        } else if (!opts.inmemory) {
	            this._loader.call(this, 0);
	        }
	    }
	}

	const MAX_VERROR = 3;
	var VError$1 = /*#__PURE__*/ function(VError) {
	    VError["NoKeys"] = "NO_KEYS";
	    VError["NoKey"] = "NO_KEY";
	    VError["NotANumber"] = "NOT_NUMBER";
	    VError["Empty"] = "EMPTY_BUFFER";
	    VError["Pattern"] = "PATTERN_MISMATCH";
	    VError["NotUnique"] = "NOT_UNIQUE";
	    VError["Mandatory"] = "MANDANTORY";
	    VError["TypeRedef"] = "TYPE_REDEF";
	    VError["MissingTagName"] = "MISSING_TAGNAME";
	    VError["UnknownType"] = "UNKNOWN_TYPE";
	    VError["ExcessiveField"] = "EXCESSIVE_FIELD";
	    VError["PtkNamed"] = "PTK_NAMED";
	    VError["PtkNoName"] = "PTK_NONAME";
	    VError["RedefineChunkTag"] = "REDEFINE_CHUNK_CHUNK_TAG";
	    VError["InvalidLinkAddress"] = "INVALID_LINK_ADDRESS";
	    return VError;
	}({});
	({
	    ["NO_KEYS"]: 'missing keys $1',
	    ["NO_KEY"]: 'missing key $1 for string',
	    ["NOT_NUMBER"]: 'not a number',
	    ["PATTERN_MISMATCH"]: 'pattern mismatch',
	    ["NOT_UNIQUE"]: 'not unique',
	    ["MANDANTORY"]: 'mandatory field',
	    ["TYPE_REDEF"]: 'redefine type',
	    [VError$1.MissingTypedef]: 'mssing typedef',
	    ["EXCESSIVE_FIELD"]: 'excessive field',
	    ["UNKNOWN_TYPE"]: 'unknown type',
	    ["PTK_NAMED"]: 'ptk already named',
	    ["PTK_NONAME"]: 'ptk not named',
	    ["EMPTY_BUFFER"]: 'Empty buffer'
	});

	function _define_property$6(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	class Field {
	    resetUnique() {
	        if (this.unique) this.unique = {};
	    }
	    validate(value, line) {
	        if (this.unique) {
	            if (this.unique[value]) {
	                return [
	                    VError$1.NotUnique,
	                    'tag:' + this.name + ', value:' + value,
	                    this.unique[value]
	                ]; //send ref line
	            } else {
	                this.unique[value] = line; //first occurance
	            }
	        }
	        return [
	            0,
	            value
	        ];
	    }
	    find() {
	        return -1;
	    }
	    constructor(name, def){
	        _define_property$6(this, "type", void 0);
	        _define_property$6(this, "name", void 0);
	        _define_property$6(this, "foreign", void 0);
	        _define_property$6(this, "optional", void 0);
	        _define_property$6(this, "unique", void 0);
	        _define_property$6(this, "caption", void 0);
	        this.name = name;
	        this.foreign = def.foreign || '';
	        this.pattern = def.pattern || null; //regex pattern
	        this.keys = def.keys || [];
	        this.unique = null;
	        this.optional = true;
	        this.caption = '';
	        this.type = def.type || 'string';
	        this.values = []; //number or string value, runtime only
	        this.sortedIndex;
	        for(let n in def){
	            if (!this.hasOwnProperty(n)) {
	                console.log('unknown defining attr', n, 'of', name, def);
	            }
	            this[n] = def[n];
	        }
	        if (def.unique) this.unique = {};
	    }
	}

	const ACTIONPAGESIZE = 5;

	const BRANCH_SEP = '.';
	const parseAction = (action, objform = false)=>{
	    if (!action) return [];
	    const branches = action.split(BRANCH_SEP);
	    const out = Array();
	    for(let i = 0; i < branches.length; i++){
	        const m1 = branches[i].match(/^([a-z_\-]+)#([a-z\d_-]+)$/); // with # id
	        const m2 = branches[i].match(/^([a-z_\-]+)(\d+[a-z\d_-]+)$/); // with number prefix mix id
	        const m3 = branches[i].match(/^([a-z_\-]+)(\d*)$/); // with pure number id
	        if (m1) {
	            out.push([
	                m1[1],
	                m1[2]
	            ]);
	        } else if (m2) {
	            out.push([
	                m2[1],
	                m2[2]
	            ]);
	        } else if (m3) {
	            out.push([
	                m3[1],
	                m3[2]
	            ]);
	        } else {
	            const at = branches[i].indexOf('#');
	            if (at > 0) {
	                out.push([
	                    branches[i].slice(0, at),
	                    branches[i].slice(at + 1)
	                ]);
	            } else {
	                out.push([
	                    'ck',
	                    branches[i]
	                ]); //default			
	            }
	        }
	    }
	    if (objform) {
	        const obj = {};
	        for(let i = 0; i < out.length; i++){
	            const [tag, value] = out[i];
	            obj[tag] = value;
	        }
	        return obj;
	    } else {
	        return out;
	    }
	};
	const makeAddress = (ptkname = '', action = '', from = 0, till = 0, lineoff = 0, choff = 0)=>{
	    if (typeof ptkname == 'object') {
	        const obj = ptkname;
	        ptkname = obj.ptkname;
	        action = obj.action || '';
	        from = obj.from || 0;
	        till = obj.till || 0;
	        lineoff = obj.highlightline || obj.lineoff || 0;
	        choff = obj.choff || 0;
	    }
	    let linechoff = '';
	    if (choff > 0) {
	        linechoff = lineoff + '-' + choff;
	    } else if (lineoff > 0) {
	        linechoff = lineoff.toString();
	    }
	    return (ptkname ? ptkname + ':' : '') + action + (from ? '>' + from : '') + (till ? '<' + till : '') + (linechoff ? ':' + linechoff : '');
	};
	const parseAddress = (address)=>{
	    let m0, ptkname = '', action = '', from = '', till = '', linechoff = ''; //left bound and right bound
	    let m = address.match(PTK_ACTION_FROMTILL);
	    if (m) {
	        [m0, ptkname, action, from, till, linechoff] = m;
	    } else {
	        m = address.match(PTK_FROMTILL);
	        if (m) {
	            [m0, ptkname, from, till, linechoff] = m;
	        } else {
	            m = address.match(FROMTILL);
	            if (m) [m0, from, till, linechoff] = m;
	            else return null;
	        }
	    }
	    from = (from || '').slice(1);
	    till = (till || '').slice(1);
	    linechoff = (linechoff || '').slice(1);
	    if (!from && !till && linechoff) {
	        if (parseInt(linechoff) > ACTIONPAGESIZE) {
	            from = parseInt(linechoff) - Math.floor(ACTIONPAGESIZE / 2);
	            till = from + ACTIONPAGESIZE;
	        }
	    }
	    let choff = 0;
	    const at = linechoff.indexOf('-');
	    if (~at) choff = parseInt(linechoff.slice(at + 1));
	    ptkname = ptkname || '';
	    ptkname = ptkname.slice(0, ptkname.length - 1); //remove :
	    return {
	        ptkname,
	        action,
	        from: Math.abs(parseInt(from)) || 0,
	        till: Math.abs(parseInt(till)) || 0,
	        highlightline: linechoff ? parseInt(linechoff) : -1,
	        lineoff: parseInt(linechoff),
	        choff
	    };
	};
	function rangeOfElementId(eleidarr) {
	    const out = Array(), ptk = this;
	    let from = 0, to = ptk.header.eot;
	    for(let i = 0; i < eleidarr.length; i++){
	        const [ele, id] = eleidarr[i];
	        if (ptk.defines[ele]) {
	            var _ptk_defines_ele;
	            const idtype = (_ptk_defines_ele = ptk.defines[ele]) === null || _ptk_defines_ele === void 0 ? void 0 : _ptk_defines_ele.fields.id;
	            const _id = (idtype === null || idtype === void 0 ? void 0 : idtype.type) == 'number' ? parseInt(id) : id;
	            const startfrom = bsearchNumber(ptk.defines[ele].linepos, from);
	            const at = idtype.values.indexOf(_id, startfrom);
	            const first = ptk.defines[ele].linepos[at] || ptk.defines[ele].linepos[0];
	            let last = ptk.defines[ele].linepos[at + 1] || ptk.header.eot;
	            if (first >= from && idtype.values[at] == _id) {
	                from = first;
	                if (last > to && to !== ptk.header.eot) last = to; //trim it
	                else to = last;
	                out.push([
	                    first,
	                    last
	                ]);
	            } else {
	                return [];
	            //out.push([0,0]);
	            }
	        } else {
	            var _ptk_defines_bk, _ptk_defines_ak;
	            //try book id first, then artbulk id
	            const at = (_ptk_defines_bk = ptk.defines.bk) === null || _ptk_defines_bk === void 0 ? void 0 : _ptk_defines_bk.fields.id.values.indexOf(ele);
	            const at2 = at == -1 ? (_ptk_defines_ak = ptk.defines.ak) === null || _ptk_defines_ak === void 0 ? void 0 : _ptk_defines_ak.fields.id.values.indexOf(ele) : -1;
	            if (i == 0 && (~at || ~at2)) {
	                var _ptk_defines_bk1, _ptk_defines_ak1, _ptk_defines_bk2, _ptk_defines_ak2;
	                const first = ((_ptk_defines_bk1 = ptk.defines.bk) === null || _ptk_defines_bk1 === void 0 ? void 0 : _ptk_defines_bk1.linepos[at]) || ((_ptk_defines_ak1 = ptk.defines.ak) === null || _ptk_defines_ak1 === void 0 ? void 0 : _ptk_defines_ak1.linepos[at2]);
	                let last = ((_ptk_defines_bk2 = ptk.defines.bk) === null || _ptk_defines_bk2 === void 0 ? void 0 : _ptk_defines_bk2.linepos[at + 1]) || ((_ptk_defines_ak2 = ptk.defines.ak) === null || _ptk_defines_ak2 === void 0 ? void 0 : _ptk_defines_ak2.linepos[at2 + 1]);
	                if (!last) last = ptk.header.eot;
	                out.push([
	                    first,
	                    last
	                ]);
	                from = first;
	            }
	        }
	    }
	    //for multple tag range, last should not cross section boundary
	    //workaround for ak range
	    if (eleidarr.length > 1) {
	        const sstarts = ptk.header.sectionstarts;
	        for(let i = 0; i < out.length; i++){
	            let [first, last] = out[i];
	            const at = bsearchNumber(sstarts, first + 1);
	            if (last > sstarts[at]) {
	                out[i][1] = sstarts[at];
	            }
	        }
	    }
	    return out;
	}
	function rangeOfAddress(address) {
	    let addr = address;
	    if (typeof address == 'string') {
	        addr = parseAddress(address);
	    }
	    const { from, till, action, highlightline } = addr;
	    const eleid = parseAction(action);
	    const ranges = rangeOfElementId.call(this, eleid);
	    if (ranges.length) {
	        const [first, last] = ranges[ranges.length - 1];
	        return [
	            first,
	            last,
	            from,
	            till,
	            highlightline
	        ];
	    } else {
	        return [
	            0,
	            0,
	            from,
	            till,
	            highlightline
	        ]; //不存在
	    //數字型不知道終點，預設取一行
	    }
	}
	async function fetchAddress(address) {
	    const r = rangeOfAddress.call(this, address);
	    if (!r || r[0] == r[1]) return [];
	    await this.loadLines([
	        r
	    ]);
	    const lines = this.slice(r[0], r[1]);
	    return lines;
	}
	//for grammar code
	async function fetchAddressExtra(address, ext = 'num') {
	    const r = rangeOfAddress.call(this, address);
	    if (!r || r[0] == r[1]) return [];
	    const sectionname = this.getSectionName(r[0]);
	    const parsectionname = sectionname.replace('off', ext);
	    const start = this.getSectionStart(sectionname);
	    const parstart = this.getSectionStart(parsectionname);
	    if (~parstart) {
	        const r0 = r[0] - start + parstart;
	        const r1 = r[1] - start + parstart;
	        await this.loadLines([
	            r0,
	            r1
	        ]);
	        let lines = this.slice(r0, r1);
	        if (ext == 'num') {
	            lines = lines.map((it)=>unpackInt(it));
	        }
	        return lines;
	    }
	    return [];
	}
	//only display the first level
	function innertext(address) {
	    let addr = address;
	    if (typeof address == 'string') {
	        addr = parseAddress(address);
	    }
	    const { action } = addr;
	    const defines = this.defines;
	    const eleidarr = parseAction(action);
	    const out = [];
	    for(let i = 0; i < eleidarr.length; i++){
	        var _defines_ele_innertext, _defines_ele;
	        const [ele, id] = eleidarr[i];
	        if (!defines[ele] || !defines[ele].fields.id) return '';
	        const at = defines[ele].fields.id.values.indexOf(id);
	        out.push((_defines_ele = defines[ele]) === null || _defines_ele === void 0 ? void 0 : (_defines_ele_innertext = _defines_ele.innertext) === null || _defines_ele_innertext === void 0 ? void 0 : _defines_ele_innertext.get(at));
	    }
	    return out.join('/');
	}
	function makeElementId(ele, id) {
	    return ele + (!isNaN(parseInt(id)) ? '' : '#') + id;
	}
	function tagAtAction(action) {
	    //const [start,end]=this.rangeOfAddress(action);
	    const arr = parseAction(action);
	    const out = Array();
	    let parentlinepos = 0;
	    for(let i = 0; i < arr.length; i++){
	        let [tagname, id] = arr[i];
	        if (!this.defines[tagname]) continue;
	        const taglinepos = this.defines[tagname].linepos;
	        const tagidarr = this.defines[tagname].fields.id.values;
	        const searchfrom = bsearchNumber(taglinepos, parentlinepos);
	        if (typeof tagidarr[0] == 'number') id = parseInt(id);
	        let at = tagidarr.indexOf(id, searchfrom);
	        let rel = at - searchfrom;
	        if (at < 0) at = 0;
	        if (rel < 0) rel = 0;
	        out.push({
	            tagname,
	            at,
	            rel
	        });
	        parentlinepos = taglinepos[at];
	    }
	    return out;
	}
	function getTagById(ele, id) {
	    const E = this.defines[ele];
	    if (!this.defines[ele]) return null;
	    const at = E.fields.id.values.indexOf(id);
	    if (!~at) return null;
	    return this.getTagFields(ele, [
	        at
	    ])[0];
	}
	async function fetchTag(ele, id) {
	    const range = rangeOfElementId.call(this, [
	        [
	            ele,
	            id
	        ]
	    ]);
	    if (range.length) {
	        const [start, end] = range[0];
	        await this.loadLines([
	            start,
	            start + 1
	        ]);
	        const line = this.getLine(start);
	        const [text, tags] = parseOfftext(line);
	        for(let i = 0; i < tags.length; i++){
	            if (tags[i].name == ele && tags[i].attrs.id == id) {
	                return tags[i];
	            }
	        }
	    }
	    return null;
	}
	function tagInRange(ele, from = 0, to = 0) {
	    var _this_defines_ele;
	    if (!to) {
	        to = this.header.eot;
	    }
	    const linepos = (_this_defines_ele = this.defines[ele]) === null || _this_defines_ele === void 0 ? void 0 : _this_defines_ele.linepos;
	    if (!linepos) return [];
	    const at = bsearchNumber(linepos, from);
	    let at2 = bsearchNumber(linepos, to);
	    if (linepos[at2] > to) at2--;
	    return [
	        at,
	        at2
	    ];
	}
	/* count all tag inside address */ function tagCount(address, tag) {
	    const [s, e] = this.rangeOfAddress(address);
	    const [first, last] = this.tagInRange(tag, s, e);
	    return last - first;
	}
	function nearestTag(line, tag, fieldname = '') {
	    if (typeof tag == 'string') tag = this.defines[tag];
	    if (!tag) return -1;
	    const linepos = tag.linepos;
	    if (!linepos) return null;
	    const at = bsearchNumber(linepos, line) - 1;
	    const adjustat = line < linepos[linepos.length - 1] ? at : at + 1;
	    if (!fieldname) return adjustat;
	    else return tag.fields[fieldname].values[adjustat];
	}
	function findClosestTag(typedef, key, value, from = 0) {
	    let at = typedef.fields[key].values.indexOf(value);
	    while(at >= 0 && typedef.linepos[at] < from){
	        at = typedef.fields[key].values.indexOf(value, at + 1);
	    }
	    return at;
	}
	function validId(tagname, id) {
	    var _this_defines_tagname;
	    const V = (_this_defines_tagname = this.defines[tagname]) === null || _this_defines_tagname === void 0 ? void 0 : _this_defines_tagname.fields;
	    if (!V || !V.id) return false;
	    if (V.id.type == 'number' && typeof id !== 'number') id = parseInt(id);
	    return !!~V.id.values.indexOf(id);
	}
	function queryTagFields(tagname, q, fields = []) {
	    const tag = this.defines[tagname];
	    if (!tag) return [];
	    let [qfield, qvalue] = q.split("=");
	    if (!qvalue) {
	        qvalue = qfield;
	        qfield = "id";
	    }
	    const atarr = Array();
	    const tagfield = tag.fields[qfield];
	    if (!tagfield) return [];
	    let at = tagfield.values.indexOf(qvalue);
	    while(~at){
	        atarr.push(at);
	        at = tagfield.values.indexOf(qvalue, at + 1);
	    }
	    return this.getTagFields(tagname, atarr, fields);
	}
	function getTagFields(tagname, atarr = null, fields = null) {
	    const tag = this.defines[tagname];
	    if (!tag) return [];
	    const res = Array();
	    const emitFields = (at)=>{
	        const out = {
	            at
	        };
	        if (fields) {
	            for(let i = 0; i < fields.length; i++){
	                const f = tag.fields[fields[i]];
	                if (f) out[fields[i]] = f.values[at];
	            }
	        } else {
	            for(let field in tag.fields){
	                if (tag.fields[field].values[at]) out[field] = tag.fields[field].values[at];
	            }
	            out["innertext"] = tag.getInnertext(at);
	        }
	        return out;
	    };
	    if (!atarr) {
	        for(let i = 0; i < tag.count; i++){
	            res.push(emitFields(i));
	        }
	    } else {
	        for(let i = 0; i < atarr.length; i++){
	            res.push(emitFields(atarr[i]));
	        }
	    }
	    return res;
	}
	function alignable(fn) {
	    const out = Array();
	    if (!fn) return out;
	    //only off can align with other off
	    if (!fn.endsWith(".off")) fn += ".off";
	    const H = this.header;
	    const at = H.sectionnames.indexOf(fn);
	    if (!~at) return out;
	    const length = H.sectionstarts[at + 1] - H.sectionstarts[at];
	    for(let i = 0; i < H.sectionnames.length; i++){
	        const n = H.sectionnames[i];
	        if (i == at) continue;
	        const len = H.sectionstarts[i + 1] - H.sectionstarts[i];
	        if (len == length && n.match(/^[a-z]/) && n.endsWith('.off') && n !== H.sectionnames[at]) {
	            out.push(n.replace(".off", ""));
	        }
	    }
	    return out;
	}

	/* link to foriegn key */ class LinkField extends Field {
	    validate(value, line) {
	        const addr = parseAddress(value);
	        const act = parseAction(addr.action);
	        if (!this.invertlinks[addr.ptkname]) this.invertlinks[addr.ptkname] = {};
	        let invertlinks = this.invertlinks[addr.ptkname];
	        if (act.length !== 2) ;
	        for(let i = 0; i < act.length; i++){
	            let [ele, id] = act[i];
	            if (i == 0 && !act[i][1]) {
	                ele = 'bk';
	                id = act[i][0];
	            }
	            const eleid = makeElementId(ele, id);
	            if (i == act.length - 1) {
	                if (!invertlinks[ele]) invertlinks[ele] = {};
	                if (!invertlinks[ele][id]) invertlinks[ele][id] = [];
	                invertlinks[ele][id].push(this.count);
	                this.count++;
	            } else {
	                if (!invertlinks[eleid]) {
	                    invertlinks[eleid] = {};
	                }
	                invertlinks = invertlinks[eleid];
	            }
	        }
	        return [
	            0,
	            value
	        ];
	    }
	    serializeLinks(bklinks) {
	        //assuming bk.ck or bk.n , ak.n
	        //反連結只能快速知道某個ck or n 有沒有被連
	        //精確的定位必須讀取原連結 才會取得
	        const out = [];
	        for(let bk in bklinks){
	            const links = bklinks[bk];
	            for(let targettag in links){
	                const arr = [];
	                for(let id in links[targettag]){
	                    arr.push([
	                        id,
	                        links[targettag][id]
	                    ]);
	                }
	                arr.sort(alphabetically0);
	                const chunks = arr.map((it)=>it[0]);
	                const idxarr = arr.map((it)=>it[1]);
	                out.push(bk);
	                out.push(targettag);
	                out.push(chunks.join(LEMMA_DELIMITER));
	                out.push(packInt2d(idxarr));
	            }
	        }
	        return out;
	    }
	    serialize() {
	        const attrs = {};
	        //首先寫入原始連結,之後是反連結
	        let section = [].concat(this.values); //first link is link count of each target ptk
	        for(let ptkname in this.invertlinks){
	            const out = this.serializeLinks(this.invertlinks[ptkname]);
	            attrs[ptkname] = out.length; //每個資料庫的連結總數
	            section = section.concat(out);
	        }
	        attrs['*'] = this.values.length; //連結總數
	        section.push(JSON.stringify(attrs)); //put at the end
	        return section;
	    }
	    deserialize(section, ptk) {
	        const attrs = JSON.parse(section.pop());
	        const valuelen = attrs['*'];
	        let offset = 0;
	        for(let db in attrs){
	            if (db == '*') continue;
	            const datalen = attrs[db];
	            while(offset < datalen){
	                const bk = section[valuelen + offset];
	                const targettagname = section[valuelen + offset + 1];
	                const chunks = new StringArray(section[valuelen + offset + 2], {
	                    sep: LEMMA_DELIMITER
	                });
	                const idxarr = unpackInt2d(section[valuelen + offset + 3]);
	                ptk.addBacklinks(this.name, db, bk, targettagname, chunks, idxarr);
	                offset += 4;
	            }
	        }
	        // the raw @ values
	        const values = section.slice(0, valuelen);
	        section.length = 0;
	        return values;
	    }
	    constructor(name, def){
	        super(name, def);
	        this.invertlinks = {};
	        this.type = 'link';
	        this.count = 0;
	    }
	}

	/* link to foriegn key */ class KeyField extends Field {
	    validate(value, line) {
	        //convert items to key index, try foreign key first, 
	        const keys = this.keys;
	        if (!keys) return [
	            VError$1.NoKeys,
	            value
	        ];
	        if (!value) {
	            return [
	                this.optional ? 0 : VError$1.Mandatory,
	                []
	            ];
	        }
	        const at = bsearch(keys, value);
	        if (keys[at] !== value) {
	            return [
	                VError$1.NoKey,
	                []
	            ];
	        } else {
	            return [
	                0,
	                at
	            ];
	        }
	    }
	    constructor(name, def){
	        super(name, def);
	        this.type = 'key';
	    }
	}

	/* multiple key separated by comma */ class KeysField extends Field {
	    validate(value, line) {
	        //convert items to key index, try foreign key first, 
	        const keys = this.keys;
	        if (!keys) return [
	            VError$1.NoKeys,
	            value
	        ];
	        if (!value) {
	            return [
	                this.optional ? 0 : VError$1.Mandatory,
	                []
	            ];
	        }
	        const items = value.split(',').map((it)=>{
	            if (!it) return 0;
	            const at = bsearch(keys, it);
	            if (keys[at] === it) {
	                return at;
	            } else {
	                return -1;
	            }
	        }).filter((it)=>!!it).sort((a, b)=>a - b);
	        if (items.filter((it)=>it === -1).length) {
	            return [
	                VError$1.NoKey,
	                []
	            ];
	        } else {
	            return [
	                0,
	                items
	            ];
	        }
	    }
	    constructor(name, def){
	        super(name, def);
	        this.type = 'keys';
	    }
	}

	class TextField extends Field {
	    constructor(name, def){
	        super(name, def);
	        this.type = 'text';
	    }
	}

	class NumberField extends Field {
	    _sort() {
	        [this.values, this.sortedIndex] = sortNumberArray(this.values);
	    }
	    find(value) {
	        if (!this.values.length) return -1;
	        if (!this.sortedIndex) this._sort();
	        const at = bsearch(this.values, value);
	        return this.values[at] == value ? this.sortedIndex[at] : -1;
	    }
	    validate(value, line) {
	        const n = parseInt(value);
	        if (n.toString() !== value && (value === null || value === void 0 ? void 0 : value.length)) {
	            return [
	                VError$1.NotANumber,
	                line
	            ]; //default to 0
	        }
	        if (this.pattern && !value.match(this.pattern)) {
	            return [
	                VError$1.Pattern,
	                0
	            ];
	        }
	        if (this.unique && n >= 0) {
	            if (this.unique[value]) {
	                return [
	                    VError$1.NotUnique,
	                    'tag:' + this.name + ', value:' + value,
	                    this.unique[value]
	                ]; //send ref line
	            } else {
	                this.unique[value] = line; //first occurance
	            }
	        }
	        return [
	            0,
	            parseInt(value)
	        ];
	    }
	    constructor(name, def){
	        super(name, def);
	        this.type = 'number';
	        this.name = name;
	        this.sortedIndex = null;
	    }
	}

	class NumbersField extends Field {
	    validate(value, line) {
	        if (typeof value == 'undefined') {
	            console.log('undefined', line);
	        }
	        const items = value.split(',').filter((it)=>!!it);
	        const out = [];
	        for(let i = 0; i < items.length; i++){
	            const v = items[i];
	            const n = parseInt(items[i]);
	            if (n.toString() !== v && v.length) {
	                return [
	                    VError$1.NotANumber,
	                    line
	                ]; //default to 0
	            }
	            if (this.pattern && !v.match(this.pattern)) {
	                return [
	                    VError$1.Pattern,
	                    line
	                ];
	            }
	            out.push(n);
	        }
	        return [
	            0,
	            out
	        ];
	    }
	    constructor(name, def){
	        super(name, def);
	        this.type = 'numbers';
	    }
	}

	class FileLinePosField extends Field {
	    validate(value, line, compiledFiles) {
	        const arr = value.split(',');
	        const out = [];
	        let linestart = 0;
	        for(let i = 0; i < arr.length; i++){
	            const v = parseInt(arr[i]);
	            if (isNaN(v)) {
	                const f = compiledFiles[arr[i]];
	                if (!f) {
	                    throw "no such file " + arr[i];
	                }
	                linestart = f.linestart;
	            } else {
	                out.push(linestart + v);
	            }
	        }
	        return [
	            0,
	            out
	        ];
	    }
	    constructor(name, def){
	        super(name, def);
	        this.type = 'filelinepos';
	        this.prevfn = '';
	    }
	}

	//must by sorted, one per tsv, for categorization
	class GroupField extends Field {
	    validate(value, line) {
	        //convert items to key index, try foreign key first, 
	        if (!value) {
	            return [
	                this.optional ? 0 : VError.Mandatory,
	                []
	            ];
	        }
	        if (!this.ranges[value]) this.ranges[value] = [];
	        this.ranges[value].push(line);
	        if (isNaN(value)) {
	            throw "group index should be numeric";
	        }
	        return [
	            0,
	            parseInt(value)
	        ];
	    }
	    serialize(out) {
	        const keys = Object.keys(this.ranges);
	        keys.sort(alphabetically);
	        out.push(keys.join(LEMMA_DELIMITER));
	        const delta2d = [];
	        for(let i = 0; i < keys.length; i++){
	            delta2d.push(this.ranges[keys[i]]);
	        }
	        out.push(packIntDelta2d(delta2d));
	        out.push();
	    }
	    deserialize(section) {
	        const keys = (section.shift() || '').split(LEMMA_DELIMITER);
	        const arr = unpackIntDelta2d(section.shift());
	        for(let i = 0; i < keys.length; i++){
	            this.ranges[keys[i]] = arr[i];
	        }
	    }
	    constructor(name, def){
	        super(name, def);
	        this.type = def.type || 'range';
	        this.ranges = {};
	    }
	}

	function createField(name, def, primarykeys, ownkeys = false) {
	    if (typeof def !== 'string') {
	        return new Field(name, def);
	    }
	    let v;
	    const m = def.match(/([a-z_]+):?([a-z_]*)\/?(.*)/);
	    if (!m) {
	        return;
	    }
	    const typename = m[1], foreign = m[2];
	    let pat = m[3], pattern;
	    if (pat) {
	        const at2 = pat.lastIndexOf('/');
	        let regopts = '';
	        if (at2 > 0) {
	            regopts = pat.slice(at2 + 1);
	            pat = pat.slice(0, at2);
	        }
	        pattern = new RegExp(pat, regopts);
	    }
	    if (typename === 'number') v = new NumberField(name, {
	        pattern,
	        foreign
	    });
	    else if (typename === 'numbers') v = new NumbersField(name, {
	        pattern,
	        foreign
	    });
	    else if (typename === 'filelinepos') v = new FileLinePosField(name, {
	        pattern,
	        foreign
	    });
	    else if (typename === 'unique_number') v = new NumberField(name, {
	        pattern,
	        unique: true,
	        optional: false,
	        foreign
	    });
	    else if (typename === 'unique') v = new TextField(name, {
	        pattern,
	        unique: true,
	        optional: false,
	        foreign
	    });
	    else if (typename === 'string') v = new Field(name, {
	        pattern,
	        foreign
	    });
	    else if (typename === 'link') v = new LinkField(name, {
	        pattern,
	        foreign
	    });
	    else if (typename === 'text') v = new TextField(name, {
	        pattern
	    });
	    else if (typename === 'key') {
	        const keys = primarykeys && primarykeys[foreign] || ownkeys;
	        v = new KeyField(name, {
	            keys,
	            pattern,
	            foreign,
	            optional: false
	        });
	    } else if (typename === 'keys') {
	        const keys = primarykeys && primarykeys[foreign] || ownkeys;
	        v = new KeysField(name, {
	            keys,
	            pattern,
	            foreign
	        });
	    } else if (typename === 'group') {
	        v = new GroupField(name, {
	            type: typename
	        });
	    } else if (typename === 'note') {
	        const keys = primarykeys && primarykeys[foreign] || ownkeys;
	        v = new Field(name, {
	            type: typename,
	            keys,
	            pattern,
	            foreign
	        });
	    } else if (typename === 'confer') {
	        v = new Field(name, {
	            type: typename,
	            foreign
	        });
	    }
	    if (!v) v = new Field(name, {}); //no validation is perform , just to suppress tag nodef warning
	    return v;
	}
	/* for validate_z only, move to a zField */ // this.toc=[];
	// this.zcount=0;
	// this.prevzline=0;
	// this.prevdepth=0;
	function validate_z(offtext, tag) {
	    const depth = parseInt(tag.name.slice(1, 2), 36) - 10;
	    if (isNaN(depth)) return; //invalid z
	    if (!(depth == this.prevdepth || depth == this.prevdepth + 1 || depth < this.prevdepth)) {
	        const msg = '目彔深度错误 ' + this.prevdepth + '+1!=' + depth;
	        this.errors.push({
	            msg,
	            offset: tag.offset,
	            prev: this.prevzline
	        });
	    }
	    let text = offtext.tagText(tag);
	    const closebracket = closeBracketOf(text);
	    if (text.slice(text.length - 1) == closebracket) text = text.slice(1, text.length - 1);
	    const line = this.compiledLine + this.line;
	    this.toc.push({
	        depth,
	        text,
	        key: this.zcount,
	        line
	    });
	    this.zcount++;
	    this.prevzline = line;
	    this.prevdepth = depth;
	}
	//只是將 ya3 ，tagname "y", id "a3", 存起來，以後再validate
	//TODO , check unique and in order
	function addtag_y(offtext, tag) {
	    const typedef = this.typedefs.y;
	    typedef.linepos.push(this.compiledLine + this.line);
	    const V = typedef.fields.id;
	    V.values.push(tag.name.slice(1) + (tag.attrs.id || ''));
	    let text = removeBracket(offtext.tagText(tag));
	    typedef.innertext.push(text);
	    typedef.count++;
	}
	//內文跳轉
	function addtag_x(offtext, tag) {
	    const typedef = this.typedefs.x;
	    typedef.linepos.push(this.compiledLine + this.line);
	    const V = typedef.fields.id;
	    const id = tag.attrs.id + (tag.attrs.ln ? '@' + tag.attrs.ln : '') || '';
	    V.values.push(tag.name.slice(1) + id);
	    let text = removeBracket(offtext.tagText(tag));
	    typedef.innertext.push(text);
	    //translate 
	    typedef.count++;
	}

	/* store in column oriented */ function _define_property$5(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	class Column {
	    //lexicon :: key(sorted primary key) = payload
	    addColumn(name) {
	        this.fieldnames.push(name);
	        this.fieldvalues.push([]);
	    }
	    tokenizeField(value) {
	        const tokenized = tokenize(value);
	        for(let i = 0; i < tokenized.length; i++){
	            const { text, type } = tokenized[i];
	            if (type > TokenType.SEARCHABLE && !this.tokentable[text]) {
	                this.tokentable[text] = true;
	            }
	        }
	    }
	    addRow(fields, nrow, skipFirstField, compiledFiles) {
	        let i = 0;
	        if (skipFirstField) i++;
	        for(; i < this.fieldsdef.length; i++){
	            const F = this.fieldsdef[i];
	            const [err, value] = F.validate(fields[i], nrow, compiledFiles);
	            if (err) {
	                this.onError && this.onError(err, this.fieldnames[i] + ' ' + fields[i], -1, nrow);
	            }
	            this.fieldvalues[i].push(value || '');
	            if (i + 1 == this.tokenfield) this.tokenizeField(value);
	        }
	    }
	    createFields(typedef) {
	        if (typedef) for(let idx in typedef){
	            const fieldtype = typedef[idx] || 'key=string';
	            const [name, def] = fieldtype.split('=');
	            this.addColumn(name);
	            const field = createField(name, def || {}, this.primarykeys, this.keys);
	            this.fieldsdef.push(field);
	        }
	    }
	    deserialize(section) {
	        var _tags_;
	        if (!section.length) return;
	        const firstline = section.shift();
	        const [text, tags] = parseOfftext(firstline);
	        if (!section.length) return;
	        this.attrs = (_tags_ = tags[0]) === null || _tags_ === void 0 ? void 0 : _tags_.attrs;
	        this.name = this.attrs.name;
	        this.caption = this.attrs.caption;
	        const typedef = text.split('\t'); // typdef of each field , except field 0
	        this.createFields(typedef);
	        if (this.attrs.keytype == 'serial') {
	            this.keys = null;
	        } else {
	            this.keys = new StringArray(section.shift(), {
	                sep: LEMMA_DELIMITER
	            }); //local keys
	        }
	        if (this.attrs.tokenfield) {
	            this.tokenfield = parseInt(this.attrs.tokenfield);
	            this.runtimetokentable = (section.shift() || '').split(LEMMA_DELIMITER);
	            this.runtimetokentable.sort(alphabetically);
	        }
	        let idx = 0, usesection = false;
	        for(let fieldname in this.fieldsdef){
	            const field = this.fieldsdef[fieldname];
	            if (field.type === 'number') {
	                this.fieldvalues[idx] = unpackInt(section.shift());
	            } else if (field.type === 'numbers') {
	                this.fieldvalues[idx] = unpackIntDelta2d(section.shift());
	            } else if (field.type === 'filelinepos') {
	                this.fieldvalues[idx] = unpackIntDelta2d(section.shift());
	            } else if (field.type === 'keys') {
	                this.fieldvalues[idx] = unpackIntDelta2d(section.shift());
	            } else if (field.type === 'key') {
	                this.fieldvalues[idx] = unpackInt(section.shift());
	            } else if (field.type === 'string') {
	                this.fieldvalues[idx] = section.shift().split(LEMMA_DELIMITER);
	            } else if (field.type === 'group') {
	                field.deserialize(section); //deserialize the group index
	                this.fieldvalues[idx] = unpackInt(section.shift()); //deserialize the value
	            } else if (field.type === 'text') {
	                usesection = true;
	                this.fieldvalues[idx] = section;
	            }
	            //short hand
	            if (!this[field.name]) {
	                this[field.name] = this.fieldvalues[idx];
	            }
	            idx++;
	        }
	        if (!usesection && section.length) {
	            console.log('section not consumed');
	        }
	    }
	    fromStringArray(sa, attrs = {}, from = 1, compiledFiles) {
	        const allfields = Array();
	        let line = sa.first();
	        let textstart = 0; // starting of indexable text
	        let skipFirstField = false;
	        while(from > 0){
	            line = sa.next();
	            from--;
	        }
	        while(line || line === ''){
	            const fields = line.split('\t');
	            allfields.push(fields);
	            line = sa.next();
	        }
	        if (attrs.keytype !== 'serial') {
	            allfields.sort(alphabetically0);
	            skipFirstField = true;
	            this.keys = allfields.map((it)=>it[0]);
	        }
	        this.createFields(this.typedef);
	        if (attrs.tokenfield) {
	            this.tokenfield = parseInt(attrs.tokenfield || -1);
	            //simply build token table without posting
	            this.tokentable = {};
	            if (this.tokenfield === 0) this.tokenizeField(this.keys.join(LEMMA_DELIMITER));
	        }
	        if (!this.fieldnames.length) {
	            throw "missing typedef";
	        }
	        for(let i = 0; i < allfields.length; i++){
	            this.addRow(allfields[i], i + 1, skipFirstField, compiledFiles); //one base
	        }
	        const out = Array();
	        if (this.keys) out.push(this.keys.join(LEMMA_DELIMITER));
	        if (this.tokenfield > -1) {
	            out.push(Object.keys(this.tokentable).join(LEMMA_DELIMITER));
	        }
	        for(let i = 0; i < this.fieldnames.length; i++){
	            const V = this.fieldsdef[i];
	            if (V.type == 'number' || V.type == 'line') {
	                const numbers = this.fieldvalues[i].map((it)=>parseInt(it) || 0) || [];
	                //convert line to text line at runtime
	                out.push(packInt(numbers));
	            } else if (V.type == 'numbers' || V.type == 'filelinepos') {
	                const numbers = this.fieldvalues[i] || [];
	                if (numbers.length == 1) {
	                    throw "must have more than one array";
	                }
	                // console.log(numbers)
	                out.push(packIntDelta2d(numbers));
	            } else if (V.type == 'keys') {
	                const numnums = this.fieldvalues[i] || [];
	                out.push(packIntDelta2d(numnums));
	            } else if (V.type == 'key') {
	                const nums = this.fieldvalues[i] || [];
	                out.push(packInt(nums));
	            } else if (V.type == 'string') {
	                out.push(this.fieldvalues[i].join(LEMMA_DELIMITER));
	            } else if (V.type == 'group') {
	                V.serialize(out);
	                out.push(packInt(this.fieldvalues[i]));
	            } else if (V.type == 'text') {
	                if (i !== this.fieldnames.length - 1) {
	                    throw "multiline text fieldtype must be the last, " + this.fieldnames[i];
	                }
	                textstart = out.length;
	                for(let j = 0; j < this.fieldvalues[i].length; j++){
	                    out.push(this.fieldvalues[i][j]);
	                }
	            } else if (V.type) {
	                this.onError && this.onError(VError$1.UnknownType, V.type);
	            }
	        }
	        if (textstart == 0) textstart = out.length; //no indexable text
	        return [
	            out,
	            textstart
	        ];
	    }
	    fromTSV(buffer, attrs, from = 1) {
	        const sa = new StringArray(buffer, {
	            sequencial: true
	        });
	        return this.fromStringArray(sa, attrs, from, this.compiledFiles);
	    }
	    toTSV() {
	        if (!this.keys) return '';
	        let key = this.keys.first();
	        let at = 0;
	        const out = Array();
	        while(key){
	            const rows = [
	                key
	            ];
	            for(let i = 1; i < this.fieldvalues.length; i++){
	                rows.push(this.fieldvalues[i][at]);
	            }
	            key = this.keys.next();
	            at++;
	            out.push(rows.join('\t'));
	        }
	        return out.join('\n');
	    }
	    findKey(key) {
	        if (this.keys) {
	            return this.keys.find(key.toString());
	        } else {
	            return parseInt(key) - 1;
	        }
	    }
	    fieldsByKey(key) {
	        const at = this.findKey(key);
	        if (!key) return null;
	        if (~at) {
	            const out = {
	                key
	            };
	            for(let i = 0; i < this.fieldvalues.length; i++){
	                out[this.fieldnames[i]] = this.fieldvalues[i][at];
	            }
	            return out;
	        } else return null;
	    }
	    fieldByKey(key, fieldname) {
	        const at = this.findKey(key);
	        if (!key) return null;
	        if (~at) {
	            const at2 = this.fieldnames.indexOf(fieldname);
	            if (~at2) {
	                return this.fieldvalues[at2][at];
	            } else {
	                return this.fieldvalues[1][at];
	            }
	        } else return null;
	    }
	    getKey(i) {
	        if (this.keys) {
	            return this.keys.get(i);
	        } else {
	            return (i + 1).toString();
	        }
	    }
	    constructor(opts = {}){
	        _define_property$5(this, "fieldvalues", void 0);
	        _define_property$5(this, "fieldnames", void 0);
	        _define_property$5(this, "fieldsdef", void 0);
	        _define_property$5(this, "name", void 0);
	        _define_property$5(this, "attrs", void 0);
	        _define_property$5(this, "caption", void 0);
	        _define_property$5(this, "keys", void 0);
	        _define_property$5(this, "primarykeys", void 0);
	        _define_property$5(this, "onError", void 0);
	        _define_property$5(this, "tokenfield", void 0);
	        _define_property$5(this, "tokentable", void 0);
	        _define_property$5(this, "runtimetokentable", void 0);
	        _define_property$5(this, "typedef", void 0);
	        this.fieldvalues = [];
	        this.fieldnames = [];
	        this.fieldsdef = [];
	        this.name = '';
	        this.keys = null; //keys, null if keytype==serial 
	        this.primarykeys = opts.primarykeys || {};
	        this.onError = opts.onError;
	        this.typedef = opts.typedef;
	        this.tokenfield = -1; // 0 tokenize the key field, 1 first field 
	        this.tokentable = {}; //快速知道有沒有這個token，免去除, runtime 是 Object
	        this.runtimetokentable = Array();
	    }
	}

	var SourceType = /*#__PURE__*/ function(SourceType) {
	    SourceType["Offtext"] = "txt";
	    SourceType["TSV"] = "tsv";
	    SourceType["Unknown"] = "unknown";
	    return SourceType;
	}({});

	function _define_property$4(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	/* types of attributes defined by ^:  */ const reservedAttributes = {
	    caption: true,
	    lazy: false,
	    key: true,
	    field: true,
	    text: true,
	    type: true //name of painter
	};
	class Typedef {
	    resetChildTag() {
	        if (this.attrs.reset) {
	            const resetting = this.attrs.reset.split(',');
	            for(let i = 0; i < resetting.length; i++){
	                const childtypedef = this.typedefs[resetting[i]];
	                if (childtypedef) {
	                    for(let fieldname in childtypedef.fields){
	                        const field = childtypedef.fields[fieldname];
	                        if (field.unique) {
	                            // console.log('reset',childtypedef.tagname,fieldname)
	                            field.resetUnique();
	                        }
	                    }
	                }
	            }
	        }
	    }
	    validateFields(tag, line, onError, compiledFiles) {
	        let touched = false, newtag;
	        this.count++;
	        // for (let aname in tag.attrs) {
	        for(let aname in this.attrs){
	            const V = this.fields[aname];
	            let value = tag.attrs[aname];
	            if (V && !V.foreign) V.values.push(tag.attrs[aname]);
	            let [err, newvalue, refline] = V && V.validate(tag.attrs[aname], line, compiledFiles) || [
	                0,
	                value,
	                -1
	            ];
	            if (err) {
	                onError(err, newvalue, refline);
	            } else {
	                if (!touched) {
	                    newtag = Object.assign({}, tag);
	                    newtag.attrs = Object.assign({}, tag.attrs);
	                }
	                if (Array.isArray(newvalue)) newvalue = newvalue.join(',');
	                newtag.attrs[aname] = newvalue;
	                touched = true;
	            }
	        }
	        return newtag;
	    }
	    validateTag(offtext, tag, line, compiledLine, compiledFiles, onError) {
	        if (this.fields.id || this.fields['@'] || this.fields.ln || this.attrs.savelinepos) {
	            this.linepos.push(compiledLine + line);
	        }
	        if (this.attrs.bracket) {
	            let tagtext = offtext.tagText(tag);
	            if (!tagtext) {
	                tagtext = offtext.plain.trim() || "noname";
	            }
	            if (this.attrs.bracket !== 'true') tagtext = removeBracket(tagtext);
	            this.innertext.push(tagtext.slice(0, 15));
	        //if (this.tagname=='ak'||this.tagname=='bk') console.log(tagtext,tag)
	        }
	        for(let aname in this.mandatory){
	            if (!tag.attrs.hasOwnProperty(aname) && this.mandatory[aname]) {
	                onError(VError$1.Mandatory, tag.name + ' ' + aname);
	            }
	        }
	        this.resetChildTag();
	        const newtag = this.validateFields(tag, line, onError, compiledFiles);
	        return newtag;
	    }
	    deserialize(section, ptk, sectionmame) {
	        const attrline = section.shift();
	        const attrs = attrline ? attrline.split(LEMMA_DELIMITER) : [];
	        if (section.length > attrs.length) {
	            this.linepos = unpackIntDelta(section.shift());
	            this.count = this.linepos.length;
	        }
	        if (!section.length) return;
	        if (this.fields.bracket) {
	            this._innertext = new StringArray(section.shift() || '', {
	                sep: LEMMA_DELIMITER
	            });
	        }
	        for(let i = 0; i < attrs.length; i++){
	            const aname = attrs[i];
	            const V = this.fields[aname];
	            if (!V) {
	                console.error("unknown type " + aname);
	                continue;
	            }
	            if ((V === null || V === void 0 ? void 0 : V.type) === 'number') {
	                V.values = unpackInt(section.shift());
	            } else if ((V === null || V === void 0 ? void 0 : V.type) === 'text') {
	                V.values = section.length ? (section.shift() || '').split('\t') : [];
	            } else if (V === null || V === void 0 ? void 0 : V.deserialize) {
	                V.values = V.deserialize(section, ptk);
	            }
	        }
	        if (section.length) {
	            console.log("unconsumed section lines", section.length, sectionmame);
	        }
	    }
	    serialize() {
	        const attrs = Array(), out = Array();
	        if (!this.count) return null;
	        if (this.linepos.length || this.fields.bracket) {
	            //if innertext exists , must pack linepos even if empty
	            out.push(packIntDelta(this.linepos));
	        }
	        if (this.fields.bracket) {
	            out.push((this.innertext || []).join(LEMMA_DELIMITER));
	        }
	        for(let aname in this.fields){
	            const V = this.fields[aname];
	            if (V.foreign) continue;
	            if (V.type == 'number') {
	                attrs.push(aname);
	                out.push(packInt(V.values.map((it)=>parseInt(it) || 0)));
	            } else if (V.type == 'text') {
	                attrs.push(aname);
	                out.push(V.values.join('\t'));
	            } else if (V.serialize) {
	                attrs.push(aname);
	                const arr = V.serialize();
	                for(let i = 0; i < arr.length; i++){
	                    out.push(arr[i]);
	                }
	            }
	        }
	        out.unshift(attrs.join(LEMMA_DELIMITER));
	        return out.length ? out.join('\n') : null;
	    }
	    getInnertext(i) {
	        var _this__innertext;
	        return ((_this__innertext = this._innertext) === null || _this__innertext === void 0 ? void 0 : _this__innertext.get(i)) || '';
	    }
	    constructor(attrs, tagname, primarykeys, typedefs){
	        _define_property$4(this, "count", void 0);
	        _define_property$4(this, "fields", void 0);
	        _define_property$4(this, "mandatory", void 0);
	        _define_property$4(this, "tagname", void 0);
	        _define_property$4(this, "linepos", void 0);
	        _define_property$4(this, "innertext", void 0);
	        //this is not good, runtime and 
	        _define_property$4(this, "_innertext", void 0);
	        _define_property$4(this, "typedefs", void 0);
	        _define_property$4(this, "column", void 0);
	        _define_property$4(this, "attrs", void 0);
	        this.fields = {}; /* attribute might have validator */ 
	        this.mandatory = {};
	        this.tagname = tagname;
	        this.linepos = [];
	        this.typedefs = typedefs; //to other typedefs
	        this.innertext = [];
	        for(let aname in attrs){
	            const def = attrs[aname];
	            const opts = typeof def == 'string' ? def : {
	                optional: false
	            };
	            const V = createField(tagname, opts, primarykeys);
	            if (V) this.fields[aname] = V;
	            if (V && !V.optional && !reservedAttributes[aname]) this.mandatory[aname] = true;
	        }
	        this.attrs = attrs;
	        this.column = ''; //backing column of this tag , see basket/pitaka.ts::init()
	        this.count = 0;
	        if (this.attrs.resetby) {
	            const resettingparents = this.attrs.resetby.split(',');
	            for(let i = 0; i < resettingparents.length; i++){
	                const parent = this.typedefs[resettingparents[i]];
	                if (parent) {
	                    if (!parent.attrs.reset) {
	                        parent.attrs.reset = tagname;
	                    } else {
	                        const arr = parent.attrs.reset.split(',');
	                        arr.push(tagname);
	                        parent.attrs.reset = unique(arr).join(',');
	                    }
	                } else {
	                    console.log("not such parent tag", resettingparents[i]);
	                }
	            }
	        }
	    }
	}

	/* todo , pb defined resetby=bk  */ const predefines = {
	    generic: `^:ak<id=unique bracket=false reset=n>
^:bk<id=unique heading=text bracket=false reset=ck,dk,juan aligncaption=text>
^:ck<id=unique heading=text bracket=false>
^:dk<id=unique>
^:h<id=text>
^:cb<id=text>
^:end<id=text>
^:p<id=text>
^:b<bracket=false>
^:n<id=number>
^:pn<id=text>
^:lb<id=text>
^:ii<bracket=false>
^:quote
^:fig<bracket=false>
^:image
^:quotei
^:s<bracket=false>
^:pb<id=unique resetby=bk>
^:folio<id=unique reset=pb lines=number bracket=false>
^:m<id=text>
^:juan<id=number>
^:o<@=link>
^:j<@=link>
^:k<id=text>
^:wiki
^:png<id=text src=text>
^:svg<id=text>
^:uiicon<id=text>
^:jpg<src=text>
^:ad
^:bc
^:gatha
^:au
^:cut
^:paste
^:notranslation
^:ver<savelinepos=true>
^:f<id=text>
^:i<bracket=false @=text savelinepos=true>
^:sponsor<savelinepos=true>
^:https<bracket=false onclick=gourl>
^:fn<id=text>
^:t
^:x<id=text @=text bracket=false savelinepos=true>
^:y<id=unique bracket=false savelinepos=true>
^:connect<source=text target=text book=text>
^:ln<from=text to=text pin=text>
^:bb
^:audio
^:clip
^:img
^:sz
^:sc
^:missing
^:misalign
^:ff
^:part
^:vaggo
^:errorpunc
^:puncerror
^:error
^:doubt
^:tofix
^:add
^:pg
^:swap
^:move
^:baidu
^:note
^:miss
^:person
^:diff
^:corr`,
	    cbeta: `^:ak<id=unique bracket=false>
^:bk<id=unique heading=text bracket=false reset=ck,p>
^:ck<id=unique heading=text bracket=false>
^:https<bracket=false onclick=gourl>
^:p<id=text>
^:f<id=text>
^:ver<savelinepos=true>
^:fn<id=number>
^:fm<id=text>
^:k<id=text>
^:j<@=link>
^:v
^:h
^:mc
^:l`,
	    cs: `^:ak<id=unique bracket=false>
^:bk<id=unique heading=text bracket=false>
^:ck<id=unique heading=text bracket=false>
^:n<id=unique resetby=bk>
^:p<id=number>
^:ti<id=number heading=text bracket=false>
^:f<id=number>
^:h
^:sz
^:ckan
^:cksn
^:https<bracket=false onclick=gourl>
^:t`,
	    zidian: `^:ak<id=unique bracket=false reset=ck>
^:bk<id=unique heading=text bracket=false reset=n>
^:ck<id=unique heading=text bracket=false>
^:f<id=number>
^:https<bracket=false onclick=gourl>
^:j<@=link>
^:o<@=link>
`,
	    subtitle: `^:ak<id=unique bracket=false reset=n>
^:bk<id=unique heading=text bracket=false reset=ck>
^:ck<id=unique heading=text bracket=false>
^:mpeg<id=text savelinepos=true>
^:ts<id=range>
^:ver<savelinepos=true>`
	};

	/*以文字連結注釋
	^ck5
	^f<@釋目>(顯示文字)     word 顯

	tsv footnote=ck
	5.釋目  解釋

	兩種不能混用
	*/ const groupnotes = (notekeys)=>{
	    const Notes = {};
	    for(let i = 0; i < notekeys.length; i++){
	        const m = notekeys[i].match(/(\d+)\.(.+)/);
	        if (!m) throw "invalid note " + notekeys[i] + " filename:" + filename;
	        if (!Notes[m[1]]) Notes[m[1]] = {};
	        if (Notes[m[1]][m[2]]) {
	            throw "repeat note " + notekeys[i];
	        }
	        Notes[m[1]][m[2]] = 0;
	    }
	    return Notes;
	};
	//檢查每個內文及 tsv 是否能對映
	function checkInlineFootnote(attrs, notekeys) {
	    //group notekeys
	    const Notes = groupnotes(notekeys);
	    const tagname = attrs.footnote || 'bk';
	    const tag = this.typedefs[tagname];
	    const itag = this.typedefs.i;
	    for(let i = 0; i < tag.fields.id.values.length; i++){
	        const groupid = tag.fields.id.values[i];
	        const from = tag.linepos[i];
	        const to = tag.linepos[i + 1];
	        const start = bsearchNumber(itag.linepos, from);
	        let end = bsearchNumber(itag.linepos, to);
	        if (itag.linepos[start] < from) continue;
	        if (!end || itag.linepos[end] < to) end = itag.linepos.length //fix last item
	        ;
	        const offtextfootnote = itag.innertext.slice(start, end);
	        for(let j = start; j < end; j++){
	            if (itag.fields.ln && itag.fields.ln.values[j]) {
	                offtextfootnote[j - start] = itag.fields.ln.values[j];
	            }
	        }
	        for(let j = 0; j < offtextfootnote.length; j++){
	            let gid = groupid; // use local chunk id if not specified
	            let f = offtextfootnote[j];
	            let at = f.indexOf('.');
	            if (at > 0) {
	                gid = f.slice(0, at);
	                f = f.slice(at + 1);
	                if (!f) {
	                    f = itag.innertext[j + start];
	                }
	            }
	            if (!Notes[gid]) {
	                console.log('no such id', gid, f, tagname, tag.fields.id.values);
	                continue;
	            }
	            if (Notes[gid].hasOwnProperty(f)) {
	                Notes[gid][f]++;
	            } else {
	                console.log(tagname + '#' + groupid, 'not found', offtextfootnote[j], j);
	            }
	        }
	    // console.log(groupid,start,end,offtextfootnote);
	    }
	}
	/*以id連結注釋
	^f11    
	tsv footnote=bk
	11   解釋
	*/ function checkFootnote(attrs, notekeys, filename1) {
	    if (!attrs.footnote) return;
	    const tagname = attrs.footnote || 'bk'; //default name same with bk
	    const tag = this.typedefs[tagname];
	    const ftag = this.typedefs.f;
	    if (!tag) {
	        console.log('unknown tag', tag, 'checkfootnote');
	        return;
	    }
	    if (this.typedefs.i) {
	        checkInlineFootnote.call(this, attrs, notekeys);
	    }
	    if (!ftag) {
	        console.log('no f tag in source');
	        return;
	    }
	    if (tagname == 'bk') {
	        //note tsv name == bk name
	        const at = tag.fields.id.values.indexOf(attrs.name);
	        const from = tag.linepos[at];
	        const to = tag.linepos[at + 1] || this.compiledLine; //assuming foot note just after off
	        const start = bsearchNumber(ftag.linepos, from);
	        let end = bsearchNumber(ftag.linepos, to);
	        if (ftag.linepos[start] > from) {
	            if (!end || ftag.linepos[end] < to) end = ftag.linepos.length //fix last item
	            ;
	            const offtextfootnote = ftag.fields.id.values.slice(start, end).sort(alphabetically);
	            if (offtextfootnote.join() !== notekeys.join()) {
	                console.log(filename1, 'footnote missing match', arraydiff(notekeys, offtextfootnote), notekeys.join());
	            }
	        }
	    } else {
	        const Notes = groupnotes(notekeys);
	        for(let key in Notes){
	            const notes = Notes[key];
	            const at = tag.fields.id.values.indexOf(key);
	            const from = tag.linepos[at];
	            const to = tag.linepos[at + 1] || this.compiledLine; //assuming foot note just after off
	            const start = bsearchNumber(ftag.linepos, from);
	            let end = bsearchNumber(ftag.linepos, to);
	            const offtextfootnote = ftag.fields.id.values.slice(start, end).sort(alphabetically);
	            for(let i = 0; i < offtextfootnote.length; i++){
	                const id = offtextfootnote[i];
	                if (!notes.hasOwnProperty(id)) {
	                    console.log('no note for ^f' + id, 'in ^' + tagname + key);
	                } else notes[id]++;
	            }
	        }
	    }
	}

	function _define_property$3(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	const sourceType = (firstline, filename = '')=>{
	    const at = firstline.indexOf('\n');
	    let lazy = true, name = '', caption = '', tag;
	    let consumed = false;
	    let sourcetype = SourceType.Unknown;
	    if (filename) {
	        if (filename.endsWith('.tsv')) sourcetype = SourceType.TSV;
	        if (filename.endsWith('.off')) sourcetype = SourceType.Offtext;
	    }
	    firstline = at > -1 ? firstline.slice(0, at) : firstline;
	    const [text, tags] = parseOfftext(firstline);
	    if (tags.length && tags[0].name == ':') {
	        var _tags__attrs_type;
	        const attrs = tags[0].attrs;
	        if (attrs.hasOwnProperty("lazy")) lazy = !!attrs.lazy;
	        sourcetype = ((_tags__attrs_type = tags[0].attrs.type) === null || _tags__attrs_type === void 0 ? void 0 : _tags__attrs_type.toLowerCase()) || sourcetype;
	        name = attrs.name;
	        caption = attrs.caption;
	        consumed = true;
	        if (sourcetype == 'tsv') {
	            consumed = false;
	            lazy = false;
	        }
	        tag = tags[0];
	    }
	    // console.log(filename,sourcetype);
	    return {
	        sourcetype,
	        tag,
	        lazy,
	        name,
	        caption,
	        consumed
	    };
	};
	class Compiler {
	    reset(opts = {}) {
	        //this.ptkname=''; do not reset ptkname
	        this.compilingname = '';
	        this.line = 0;
	        this.compiledLine = 0;
	        this.compiledFiles = {};
	        this.primarykeys = {};
	        this.errors = [];
	        this.typedefs = {};
	        this.stopcompile = false;
	        this.tagdefs = []; // defines provided by the library, will be added to 000.js payload
	        this.backtransclusions = {};
	        //for y tag
	        //for z tag
	        this.toc = [];
	        this.zcount = 0;
	        this.prevzline = 0;
	        this.prevdepth = 0;
	    }
	    onError(code, msg, refline = -1, line) {
	        this.errors.push({
	            name: this.compilingname,
	            line: line || this.line,
	            code,
	            msg,
	            refline
	        });
	        if (this.errors.length >= MAX_VERROR) this.stopcompile = true;
	    }
	    setPredefine(name = "generic") {
	        const predefine = predefines[name] || '';
	        this.compileOfftext(predefine, this.tagdefs);
	    }
	    compileOfftext(str, tagdefs) {
	        const at = str.indexOf('^');
	        if (at == -1) return str; //nothing to do
	        const ot = new Offtext(str);
	        for(let i = 0; i < ot.tags.length; i++){
	            const tag = ot.tags[i];
	            let tagstr = str.slice(tag.offset, tag.end);
	            if (tag.name[0] == ':' && tag.name.length > 1) {
	                const newtagname = tag.name.slice(1);
	                if (this.typedefs[newtagname]) {
	                    this.onError(VError$1.TypeRedef, newtagname);
	                } else {
	                    this.typedefs[newtagname] = new Typedef(tag.attrs, newtagname, this.primarykeys, this.typedefs);
	                }
	                tagdefs.push(tagstr);
	            } else {
	                if (tag.name[0] == 'z') {
	                    validate_z.call(this, ot, tag);
	                } else if (tag.name[0] == 'y') {
	                    addtag_y.call(this, ot, tag);
	                } else if (tag.name[0] == 'x') {
	                    addtag_x.call(this, ot, tag);
	                } else if (tag.name !== ':') {
	                    if (!tag.name) {
	                        const innertext = ot.tagText(tag, true);
	                        const [t, link] = parseTransclusion('^[' + innertext + ']');
	                        if (!this.backtransclusions[link]) {
	                            this.backtransclusions[link] = new Array;
	                        }
	                        this.backtransclusions[link].push(this.compiledLine + this.line);
	                    } else {
	                        const typedef = this.typedefs[tag.name];
	                        if (!typedef) {
	                            console.error('unknown tag\n', tag.name);
	                        //this.onError(VError.TypeTagName);
	                        } else {
	                            const newtag = typedef.validateTag(ot, tag, this.line, this.compiledLine, this.compiledFiles, this.onError.bind(this));
	                            if (newtag) {
	                                str = updateOfftext(str, tag, newtag);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return str;
	    }
	    clearCompiled(filename) {
	        delete this.compiledFiles[filename];
	    }
	    compileBuffer(buffer, filename) {
	        if (!buffer) return this.onError(VError$1.Empty);
	        if (!filename) return this.onError(VError$1.PtkNoName);
	        let samepage = false, tagdefs = Array(), attributes = {};
	        const sa = new StringArray(buffer, {
	            sequencial: true
	        });
	        const firstline = sa.first() || '';
	        const { sourcetype, tag, lazy, name, caption, consumed } = sourceType(firstline, filename); //only first tag on first line
	        if (sourcetype == 'txt' && consumed) tagdefs.push(firstline);
	        let compiledname = name || filename; //name of this section
	        let textstart = 0; //starting line of indexable text
	        this.compilingname = filename;
	        this.stopcompile = false;
	        let processed = Array();
	        // if (!tag) console.log(firstline,filename);
	        if ((tag === null || tag === void 0 ? void 0 : tag.name) == ':') {
	            if (tag.attrs.ptk) {
	                if (this.ptkname && this.ptkname !== tag.attrs.ptk) {
	                    this.onError(VError$1.PtkNamed, this.ptkname);
	                } else {
	                    this.ptkname = tag.attrs.ptk;
	                }
	            }
	            //do not set predefine for tsv
	            if (tag.attrs.type === 'txt' || filename == '0.off') {
	                this.setPredefine(tag.attrs.define || tag.attrs.template);
	            }
	            attributes = tag.attrs;
	        }
	        if (!Object.keys(this.tagdefs).length) {
	            this.setPredefine(); //use generic incase 0.off not exists
	        }
	        const linestart = this.compiledLine;
	        if (sourcetype === SourceType.TSV) {
	            var _tags_;
	            const [text, tags] = parseOfftext(firstline);
	            // if (!tags.length) {
	            // 	throw "invalid tsv, first line must be ^:"
	            // }
	            const attrs = ((_tags_ = tags[0]) === null || _tags_ === void 0 ? void 0 : _tags_.attrs) || {};
	            const typedef = text.split('\t'); // typdef of each field , except field 0
	            const columns = new Column({
	                typedef,
	                primarykeys: this.primarykeys,
	                onError: this.onError.bind(this)
	            });
	            const [serialized, _textstart] = columns.fromStringArray(sa, attrs, 1, this.compiledFiles); //build from TSV, start from line 1
	            if (!attrs.hasOwnProperty("nocheck")) {
	                checkFootnote.call(this, attrs, columns.keys, filename);
	            }
	            textstart = _textstart;
	            if (serialized) {
	                compiledname = (attrs === null || attrs === void 0 ? void 0 : attrs.name) || filename; //use filename if name is not specified
	                serialized.unshift(firstline); //keep the first line
	                //primary key can be refered by other tsv
	                if (attrs === null || attrs === void 0 ? void 0 : attrs.name) this.primarykeys[attrs.name] = columns.keys;
	                this.compiledLine += serialized.length;
	                processed = serialized;
	                textstart++; //add the first line
	                samepage = true; //store in same page
	            } else {
	                processed = [];
	            }
	        } else if (sourcetype === SourceType.Offtext) {
	            const out = Array();
	            let linetext = sa.first();
	            if (consumed) linetext = sa.next();
	            this.line = 0; //for debugging showing line from begining of offtext file
	            while(linetext || linetext === ''){
	                const o = this.compileOfftext(linetext, tagdefs);
	                if (o || o == '') {
	                    out.push(o);
	                    this.line++;
	                }
	                linetext = sa.next();
	                if (this.stopcompile) break;
	            }
	            this.compiledLine += out.length;
	            processed = out;
	        } else {
	            if (compiledname.endsWith('.num')) {
	                let linetext = sa.first();
	                const out = Array();
	                while(linetext || linetext === ''){
	                    const o = packInt(linetext.split(',').map((it)=>parseInt(it || '0')));
	                    out.push(o);
	                    linetext = sa.next();
	                    if (this.stopcompile) break;
	                }
	                this.compiledLine += out.length;
	                textstart = out.length; //do not index it
	                processed = out;
	            } else {
	                throw "unknown extension " + compiledname;
	            }
	        }
	        this.compiledFiles[filename] = {
	            name: compiledname,
	            caption,
	            lazy,
	            sourcetype,
	            processed,
	            textstart,
	            errors: this.errors,
	            samepage,
	            tagdefs,
	            attributes,
	            linestart
	        };
	        return this.compiledFiles[filename];
	    }
	    constructor(opts = {}){
	        _define_property$3(this, "typedefs", void 0);
	        _define_property$3(this, "ptkname", void 0);
	        _define_property$3(this, "compilingname", void 0);
	        _define_property$3(this, "line", void 0);
	        _define_property$3(this, "compiledLine", void 0);
	        _define_property$3(this, "compiledFiles", void 0);
	        _define_property$3(this, "primarykeys", void 0);
	        _define_property$3(this, "errors", void 0);
	        _define_property$3(this, "stopcompile", void 0);
	        _define_property$3(this, "toc", void 0);
	        _define_property$3(this, "zcount", void 0);
	        _define_property$3(this, "prevzline", void 0);
	        _define_property$3(this, "prevdepth", void 0);
	        _define_property$3(this, "tagdefs", void 0);
	        _define_property$3(this, "backtransclusions", void 0);
	        this.reset(opts);
	    }
	}

	function _define_property$2(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	class TableOfContent {
	    constructor(section){
	        _define_property$2(this, "lines", void 0);
	        _define_property$2(this, "depths", void 0);
	        _define_property$2(this, "texts", void 0);
	        this.lines = unpackIntDelta(section.shift());
	        this.depths = unpackInt(section.shift());
	        this.texts = new StringArray(section.shift());
	    }
	}
	//chunk as toc
	const depthOfId = (str)=>{
	    return str.split(/(\d+)/).filter((it)=>!!it).length;
	};
	function buildTocTag(toctags) {
	    for(let i = 0; i < toctags.length; i++){
	        const toctag = toctags[i];
	        const out = Array();
	        if (!this.defines[toctag]) {
	            console.log('not such tag', toctag);
	            continue;
	        }
	        const values = this.defines[toctag].fields.id.values;
	        for(let j = 0; j < values.length; j++){
	            out.push(depthOfId(values[j]));
	        }
	        this.defines[toctag].depths = out;
	    }
	}

	const nop = ()=>{
	    return [];
	};
	const addTemplate = (name, template)=>{
	    Templates[name] = template;
	    if (!template.getFilters) template.getFilters = nop;
	    if (!template.runFilter) template.runFilter = nop;
	    if (!template.getCorrespondence) template.getCorrespondence = nop;
	};
	const Templates = {};
	addTemplate('generic', {});

	function _define_property$1(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	class Pitaka extends LineBase {
	    async init() {
	        var _compiler_compiledFiles_0off;
	        if (!this.payload) return;
	        const compiler = new Compiler();
	        compiler.compileBuffer(this.payload, '0.off');
	        this.defines = compiler.typedefs;
	        this.attributes = (_compiler_compiledFiles_0off = compiler.compiledFiles['0.off']) === null || _compiler_compiledFiles_0off === void 0 ? void 0 : _compiler_compiledFiles_0off.attributes;
	        this.lang = this.attributes.lang || 'zh';
	        this.template = Templates[this.attributes.template] || Templates.generic;
	        const ranges = Array();
	        //load required section data
	        for(let i = 0; i < this.header.preload.length; i++){
	            const r = this.sectionRange(this.header.preload[i]);
	            if (r && r[1] > r[0]) ranges.push(r);
	        }
	        for(let n in this.defines){
	            if (!this.defines[n].fields.lazy) {
	                const r = this.sectionRange('^' + n);
	                if (r && r[1] > r[0]) ranges.push(r);
	            }
	        }
	        if (!this.inmemory) await this.loadLines(ranges);
	        for(let i = 0; i < this.header.preload.length; i++){
	            const section = this.getSection(this.header.preload[i]);
	            if (section.length) this.deserialize(section, this.header.preload[i]);
	        // else console.error('empty section',this.header.preload[i]);
	        }
	        for(const n in this.defines){
	            if (!this.defines[n].fields.lazy) {
	                const section = this.getSection('^' + n);
	                if (section && section.length) {
	                    this.defines[n].deserialize(section, this, n); //call typedef.ts:deserialize
	                } else {
	                    this.defines[n].empty = true;
	                }
	            }
	            for(let attr in this.defines[n].fields){
	                const A = this.defines[n].fields[attr];
	                if (A.foreign && this.primarykeys[A.foreign]) {
	                    A.keys = this.primarykeys[A.foreign];
	                }
	            }
	        }
	        for(const n in this.defines){
	            if (this.defines[n].empty) delete this.defines[n];
	        }
	        //link column and define
	        for(const n in this.columns){
	            var _this_columns_n_attrs;
	            const tagname = (_this_columns_n_attrs = this.columns[n].attrs) === null || _this_columns_n_attrs === void 0 ? void 0 : _this_columns_n_attrs.tagname;
	            if (tagname && this.defines[tagname]) {
	                this.defines[tagname].column = n;
	            }
	        }
	    }
	    deserialize(section, sectionname) {
	        if (!section.length) return;
	        if (!section[0]) section.shift();
	        if (!section.length) return;
	        const firstline = section[0];
	        sourceType(firstline);
	        const at = this.header.sectionnames.indexOf(sectionname);
	        const sourcetype = this.header.sectiontypes[at];
	        if (sourcetype === 'tsv') {
	            const column = new Column();
	            column.deserialize(section);
	            this.columns[column.name] = column;
	            this.primarykeys[column.name] = column.keys;
	        }
	    }
	    typedefOf(tagname) {
	        return this.defines[tagname]; //.fields;
	    }
	    getSectionStart(name) {
	        const at = this.header.sectionnames.indexOf(name);
	        if (~at) {
	            return this.header.sectionstarts[at];
	        }
	        return -1;
	    }
	    getSectionName(line) {
	        const at = bsearchNumber(this.header.sectionstarts, line + 1) - 1;
	        return this.header.sectionnames[at];
	    }
	    constructor(opts){
	        super(opts), _define_property$1(this, "defines", void 0), _define_property$1(this, "primarykeys", void 0), _define_property$1(this, "columns", void 0), _define_property$1(this, "attributes", void 0), _define_property$1(this, "tocs", void 0), _define_property$1(this, "rangeOfAddress", void 0), _define_property$1(this, "tagAtAction", void 0), _define_property$1(this, "innertext", void 0), _define_property$1(this, "inverted", void 0), _define_property$1(this, "lang", void 0), _define_property$1(this, "template", void 0);
	        this.defines = {};
	        this.attributes = {};
	        this.primarykeys = {};
	        this.columns = {};
	        this.inverted = null;
	        this.lang = '';
	    }
	}

	const makeUint8Array = (thing)=>new Uint8Array(thing.buffer || thing);
	const wasm = "AGFzbQEAAAABCgJgAABgAn9/AXwDAwIAAQUDAQACBwkCAW0CAAFjAAEIAQAKlQECSQEDfwNAIAEhAEEAIQIDQCAAQQF2IABBAXFBoIbi7X5scyEAIAJBAWoiAkEIRw0ACyABQQJ0IAA2AgAgAUEBaiIBQYACRw0ACwtJAQF/IAFBf3MhAUGAgAQhAkGAgAQgAGohAANAIAFB/wFxIAItAABzQQJ0KAIAIAFBCHZzIQEgAkEBaiICIABJDQALIAFBf3O4Cw";
	const instance$Q = new WebAssembly.Instance(new WebAssembly.Module(Uint8Array.from(atob(wasm), (c)=>c.charCodeAt(0))));
	const { c, m } = instance$Q.exports;
	// Someday we'll have BYOB stream readers and encodeInto etc.
	// When that happens, we should write into this buffer directly.
	const pageSize = 0x10000 // 64 kB
	;
	makeUint8Array(m).subarray(pageSize);

	var ZipConst = /*#__PURE__*/ function(ZipConst) {
	    ZipConst[ZipConst["fileHeaderSignature"] = 1347093252] = "fileHeaderSignature";
	    ZipConst[ZipConst["descriptorSignature"] = 1347094280] = "descriptorSignature";
	    ZipConst[ZipConst["centralHeaderSignature"] = 1347092738] = "centralHeaderSignature";
	    ZipConst[ZipConst["endSignature"] = 1347093766] = "endSignature";
	    ZipConst[ZipConst["fileHeaderLength"] = 30] = "fileHeaderLength";
	    ZipConst[ZipConst["centralHeaderLength"] = 46] = "centralHeaderLength";
	    ZipConst[ZipConst["endLength"] = 22] = "endLength";
	    ZipConst[ZipConst["descriptorLength"] = 16] = "descriptorLength";
	    return ZipConst;
	}({});

	/*
	   No Async, No comment, no disk/network io, no compression, no crc checking, 32bits only.
	   No Checking of local file header
	   allow lazy loading of file content.
	   Silent if not a zip
	*/ function _define_property(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, {
	            value: value,
	            enumerable: true,
	            configurable: true,
	            writable: true
	        });
	    } else {
	        obj[key] = value;
	    }
	    return obj;
	}
	class ZipStore {
	    loadFiles(fileCount, centralSize, centralOffset) {
	        //calculate centraloffset from end of buffer , 
	        //an partial zip buf is smaller than value specified in endRecord
	        const coffset = this.zipbuf.length - ZipConst.endLength - centralSize;
	        // const centralbuf=new DataView(this.zipbuf.slice(coffset,coffset+centralSize).buffer);
	        const buf = new DataView(this.zipbuf.buffer);
	        let p = coffset;
	        for(let i = 0; i < fileCount; i++){
	            const signature = buf.getUint32(p);
	            if (signature !== ZipConst.centralHeaderSignature) {
	                break;
	            }
	            const size = buf.getUint32(p + 20, true);
	            const namelen = buf.getUint16(p + 28, true);
	            const extra = buf.getUint16(p + 30, true);
	            const commentlen = buf.getUint16(p + 32, true);
	            let offset = buf.getUint32(p + 42, true);
	            p += ZipConst.centralHeaderLength;
	            const encodedName = this.zipbuf.subarray(p, p + namelen);
	            const name = new TextDecoder().decode(encodedName);
	            p += namelen;
	            p += extra + commentlen;
	            if (i === 0) this.zipStart = offset; //before zipstart is RedBean 
	            offset += ZipConst.fileHeaderLength + namelen; //skip the local file header
	            let content;
	            const inbuf = centralOffset - coffset;
	            if (offset - inbuf >= 0) {
	                content = this.zipbuf.subarray(offset - inbuf, offset - inbuf + size);
	            } // else host will do lazy loading
	            this.files.push({
	                name,
	                offset,
	                size,
	                content
	            }); //offset and size of actual data in the zip image
	        }
	    }
	    find(name) {
	        for(let i = 0; i < this.files.length; i++){
	            if (this.files[i].name == name) {
	                return this.files[i];
	            }
	        }
	    }
	    loadEndRecord() {
	        const endRecord = {
	            signature: 0,
	            fileCount: 0,
	            centralSize: 0,
	            centralOffset: 0
	        };
	        //cannot use subarray here
	        const buf = new DataView(this.zipbuf.buffer); //this.zipbuf.slice(this.zipbuf.length-ZipConst.endLength).buffer);
	        // console.log(endbuf)
	        const endpos = this.zipbuf.length - ZipConst.endLength;
	        endRecord.signature = buf.getUint32(endpos);
	        if (endRecord.signature !== ZipConst.endSignature) {
	            console.log('endrecord signature', endRecord.signature, 'zipbuf length', this.zipbuf.length);
	            throw "wrong endRecord signature";
	        }
	        endRecord.fileCount = buf.getUint16(endpos + 8, true);
	        endRecord.centralSize = buf.getUint32(endpos + 12, true);
	        endRecord.centralOffset = buf.getUint32(endpos + 16, true);
	        return endRecord;
	    }
	    constructor(zipbuf){
	        //zipbuf should at least include the Central records.
	        _define_property(this, "zipbuf", void 0);
	        _define_property(this, "files", void 0);
	        _define_property(this, "zipStart", void 0);
	        //may pass in nodejs readFile result
	        if (zipbuf instanceof ArrayBuffer) {
	            zipbuf = new Uint8Array(zipbuf);
	        }
	        this.zipbuf = zipbuf instanceof Uint8Array ? zipbuf : new Uint8Array(zipbuf.buffer);
	        this.files = [];
	        this.zipStart = 0; //begining first file including header (PK)
	        const { fileCount, centralSize, centralOffset } = this.loadEndRecord();
	        if (fileCount) {
	            this.loadFiles(fileCount, centralSize, centralOffset);
	        }
	    }
	}

	const openPtk = async (name, cachedimage = null)=>{
	    let ptk = usePtk(name);
	    if (ptk) return ptk;
	    if (!name) return null;
	    const opts = {
	        name
	    };
	    if (cachedimage) {
	        opts["zipstore"] = new ZipStore(cachedimage);
	    }
	    ptk = new Pitaka(opts);
	    poolAdd(name, ptk); //add to pool for jsonp to work.
	    if (await ptk.isReady()) {
	        await ptk.init();
	        /*
			const poolptk=poolGetAll();
			for (let i=0;i<poolptk.length;i++) {
				poolptk[i].addForeignLinks(ptk);
			}
			*/ return ptk;
	    } else {
	        poolDel(name);
	    }
	};
	const usePtk = (name)=>{
	    if (!name) return null;
	    return poolGet(name);
	};

	//import { bsearchNumber ,parseOfftext,splitUTF32Char,CJKRangeName} from "../nodebundle.cjs";
	const VALIDPUNCS = "「」『』。，；：、！？";
	const tidyFolioText = (text)=>{
	    //方括號的文字不算
	    return text.replace(/【([^】]*)】/g, (m, m1)=>'【' + '-'.repeat(m1.length) + '】');
	};
	const toFolioText = (lines)=>{
	    if (!lines || !lines.length) return [];
	    let firstline = lines[0];
	    firstline.match(/(\^pb\d+)/);
	    const text = tidyFolioText(lines.join('\t'))//.replace(/\^folio#[a-z\d]+【([^】]+?)】/g,'')// 只作為 foliolist 的名字，查字典內文用不到
	    .replace(/(..)\^pb/g, '$1^lb^pb') //replace in middle pb
	    .split('^lb');
	    // if (remain) text.push(remain);
	    return text;
	};
	const countFolioChar = (linetext)=>{
	    let prev = 0, textsnip = '', count = 0;
	    const consumeChar = ()=>{
	        if (prev && textsnip[0] == '【') {
	            textsnip = textsnip.replace(/【([^】]*)】/, (m, m1)=>'【' + '-'.repeat(m1.length) + '】');
	        }
	        const chars = splitUTF32Char(textsnip);
	        let i = 0;
	        while(i < chars.length){
	            const r = CJKRangeName(chars[i]);
	            if (r || chars[i] == '　') {
	                count++;
	            }
	            i++;
	        }
	    };
	    linetext.replace(OFFTAG_REGEX_G, (m4, rawName, rawAttrs, offset)=>{
	        textsnip = linetext.slice(prev, offset);
	        consumeChar();
	        prev = offset + m4.length;
	    });
	    textsnip = linetext.slice(prev);
	    consumeChar();
	    return count;
	};
	const folioPosFromAddress = async (ptk, address)=>{
	    const { choff, lineoff, action } = parseAddress(address);
	    const [start, end] = ptk.rangeOfAddress(action);
	    if (!end) return {};
	    const folio = ptk.defines.folio;
	    let folioat = bsearchNumber(ptk.defines.folio.linepos, start + 1) - 1;
	    if (folioat == -1) folioat = 0;
	    const ckat = bsearchNumber(ptk.defines.ck.linepos, start + 1) - 1;
	    const id = folio.fields.id.values[folioat];
	    if (!id) return {};
	    const ck = ptk.defines.ck.fields.id.values[ckat];
	    const ft = new FolioText(ptk);
	    await ft.load(id);
	    const [pb, line, ch] = ft.toFolioPos(ck, lineoff, choff);
	    return {
	        id,
	        pb,
	        line,
	        ch
	    };
	};
	class FolioText {
	    toFolioPos(ck = '1', lineoff = 0, choff = 0) {
	        const [ckstart, ckend] = this.chunkRange(ck);
	        const str = this.offtext.slice(ckstart, ckend);
	        let p = 0;
	        while(lineoff > 0 && p < str.length){
	            if (str.charAt(p) == '\n') lineoff--;
	            p++;
	        }
	        const start = ckstart + p + choff; // ckline 的起點 
	        const pbat = bsearchNumber(this.pbpos, start + choff + 1) - 1;
	        const [pbstart, pbend] = this.pbRange(this.pbs[pbat]);
	        const end = Math.min(start, pbend);
	        let pbstr = this.offtext.slice(pbstart, end);
	        if (this.offtext.slice(end, end + 3) == '^lb') {
	            //if start is end of folioline, add one more lb to increase pblines.length
	            //and ch will be zero
	            //so that first folio char is markable 
	            pbstr += '^lb';
	        }
	        const pblines = pbstr.split('^lb');
	        const line = pblines.length;
	        const ch = this.countFolioChar(pblines[pblines.length - 1]);
	        return [
	            this.pbs[pbat],
	            line - 1,
	            ch
	        ];
	    }
	    folioPageText(pb) {
	        const [start, end] = this.pbRange(pb);
	        return toFolioText(this.offtext.slice(start, end).split('\n'));
	    }
	    countFolioChar(linetext) {
	        return countFolioChar(linetext);
	    }
	    skipFolioChar(linetext, ch) {
	        if (!linetext) return 0;
	        let prev = 0, textlen = 0, textsnip = '';
	        const consumeChar = ()=>{
	            if (prev && textsnip[0] == '【') {
	                textsnip = textsnip.replace(/【([^】]*)】/, (m, m1)=>'【' + '-'.repeat(m1.length) + '】');
	            }
	            const chars = splitUTF32Char(textsnip);
	            let i = 0;
	            while(ch > -1 && i < chars.length){
	                const r = CJKRangeName(chars[i]);
	                if (r || chars[i] == '　') {
	                    ch--;
	                }
	                if (ch >= 0) textlen += chars[i].codePointAt(0) >= 0x20000 ? 2 : 1;
	                i++;
	            }
	        };
	        let taglens = 0;
	        linetext.replace(OFFTAG_REGEX_G, (m4, rawName, rawAttrs, offset)=>{
	            textsnip = linetext.slice(prev, offset);
	            consumeChar();
	            if (ch <= 0) return;
	            prev = offset + m4.length;
	            taglens += m4.length;
	        });
	        textsnip = linetext.slice(prev);
	        consumeChar();
	        return textlen + taglens;
	    }
	    fromFolioPos(foliopos, line = 0, ch = 0) {
	        let pbid = foliopos;
	        if (typeof foliopos == 'object') {
	            [pbid, line, ch] = foliopos;
	        }
	        const [pbstart, pbend] = this.pbRange(pbid);
	        const pbstr = tidyFolioText(this.offtext.slice(pbstart, pbend));
	        const pblines = pbstr.split('^lb');
	        let start = pbstart || 0;
	        for(let i = 0; i < line; i++){
	            var _pblines_i;
	            start += (((_pblines_i = pblines[i]) === null || _pblines_i === void 0 ? void 0 : _pblines_i.length) || 0) + (i > 0 ? 3 : 0); //\n and "^lb".length after first line
	        }
	        const pbchoff = this.skipFolioChar(pbstr.slice(start - pbstart), ch); //與 pblinestart 的距離
	        start += pbchoff;
	        let ckat = bsearchNumber(this.chunkpos, start + 1) - 1;
	        const ckid = this.chunks[ckat < 0 ? 0 : ckat];
	        const [ckstart, ckend] = this.chunkRange(ckid);
	        const str = this.offtext.slice(ckstart, ckend);
	        const cklines = str.split('\n');
	        let p = ckstart || 0;
	        let lineoff = 0, choff = 0, i = 0;
	        for(i = 0; i < cklines.length; i++){
	            if (p + cklines[i].length >= start) {
	                //從 ckline 起算的 距離(real ch offset)
	                choff = start - p;
	                break;
	            }
	            lineoff++;
	            p += cklines[i].length + 1;
	        }
	        const ptkline = this.from + this.chunklinepos[ckat] + lineoff;
	        const linecount = this.chunklinepos[ckat + 1] - this.chunklinepos[ckat];
	        const at = bsearchNumber(this.ptk.defines.ck.linepos, ptkline + 1) - 1;
	        const chunk = this.ptk.getChunk(at + 1);
	        return {
	            ckid,
	            lineoff,
	            choff,
	            linetext: cklines[i] || '',
	            ptkline,
	            linecount,
	            at,
	            ck: chunk
	        };
	    }
	    chunkRange(ckid) {
	        const at = this.chunks.indexOf(ckid);
	        if (at == -1) return [
	            0,
	            0
	        ];
	        return [
	            this.chunkpos[at],
	            this.chunkpos[at + 1]
	        ];
	    }
	    chunkText(ckid) {
	        const [s, e] = this.chunkRange(ckid);
	        return this.offtext.slice(s, e);
	    }
	    pbRange(pb) {
	        if (typeof pb == 'number') pb = pb.toString();
	        const at = this.pbs.indexOf(pb);
	        if (at == -1) return [
	            0,
	            0
	        ];
	        return [
	            this.pbpos[at],
	            this.pbpos[at + 1]
	        ];
	    }
	    async load(bkfolio) {
	        const ptk = this.ptk;
	        let bk = '', folio = bkfolio;
	        if (bkfolio.match(/\d$/)) {
	            bk = bkfolio.replace(/\d+$/g, '');
	        } else {
	            folio = '';
	            bk = bkfolio;
	        }
	        let from, to;
	        const addr = (bk ? "bk#" + bk : '') + (folio ? '.' : '') + (folio ? 'folio#' + folio : ''); //+(pb?".pb#"+pb:'');
	        [from, to] = ptk.rangeOfAddress(addr);
	        if (from == to) {
	            return [
	                '',
	                from,
	                to
	            ];
	        }
	        await ptk.loadLines([
	            from,
	            to
	        ]);
	        this.folio = folio;
	        this.offtext = ptk.slice(from, to).join('\n');
	        this.from = from;
	        this.to = to;
	        let p = 0, linecount = 0;
	        while(p < this.offtext.length){
	            const ch3 = this.offtext.slice(p, p + 3);
	            if (ch3 == '^pb') {
	                this.pbpos.push(p);
	                p += 3;
	                const m = this.offtext.slice(p).match(/([\d]+)/);
	                this.pbs.push(m[1]);
	                p += m[1].length;
	            } else if (ch3 == '^ck') {
	                this.chunkpos.push(p);
	                p += 3;
	                if (this.offtext.charAt(p) == '#') p++;
	                const m = this.offtext.slice(p).match(/([a-z\d]+)/);
	                this.chunks.push(m[1]);
	                this.chunklinepos.push(linecount);
	                p += m[1].length;
	            } else {
	                if (ch3[0] == '\n') linecount++;
	                p++;
	            }
	        }
	        this.pbpos.push(this.offtext.length - 1);
	        this.chunkpos.push(this.offtext.length - 1);
	        this.chunklinepos.push(linecount + 1);
	    }
	    constructor(ptk){
	        this.ptk = ptk;
	        this.offtext = '';
	        this.pbs = [];
	        this.pbpos = []; //pb 的起點，不算標記本身
	        this.chunks = [];
	        this.chunkpos = []; //chunk 的起點，不算標記本身
	        this.chunklinepos = []; //chunk 所在行，從this.from 起算
	        this.ck = ptk.defines.ck;
	    }
	}
	const extractPuncPos = (foliopagetext, foliolines = 5, validpuncs = VALIDPUNCS)=>{
	    const puncs = [];
	    for(let i = 0; i < foliopagetext.length; i++){
	        let ch = 0, ntag = 0, textsum = 0;
	        let [text, tags] = parseOfftext(foliopagetext[i]);
	        const isgatha = !!tags.filter((it)=>it.name == 'gatha').length;
	        if (i >= foliolines) break;
	        if (isgatha) {
	            text = text.replace(/[？；，。．]/g, '　');
	        }
	        const chars = splitUTF32Char(text);
	        for(let j = 0; j < chars.length; j++){
	            while(ntag < tags.length && textsum > tags[ntag].choff){
	                if (tags[ntag].name == 'ck') {
	                    puncs.push({
	                        line: i,
	                        ch,
	                        text: styledNumber(parseInt(tags[ntag].attrs.id), '①')
	                    });
	                } else if (tags[ntag].name == 'n') {
	                    puncs.push({
	                        line: i,
	                        ch,
	                        text: 'n' + parseInt(tags[ntag].attrs.id)
	                    });
	                }
	                ntag++;
	            }
	            textsum += chars[j].length;
	            if (~validpuncs.indexOf(chars[j])) {
	                let text = toVerticalPunc(chars[j]);
	                puncs.push({
	                    line: i,
	                    ch,
	                    text
	                });
	            }
	            const r = CJKRangeName(chars[j]);
	            if (r || chars[j] == '　') {
	                ch++;
	            }
	        }
	    }
	    return puncs;
	};

	const getBookColumnText = (ptk, bk, key)=>{
	    const col = ptk.columns[bk];
	    if (!col || !col.keys) return [
	        -1,
	        ''
	    ];
	    const at = col.keys.indexOf(key);
	    if (at == -1) return [
	        -1,
	        ''
	    ];
	    const dk = col.dkat[at];
	    const [s, e] = ptk.rangeOfAddress('bk#' + bk + '.dk#' + dk);
	    return [
	        dk,
	        ptk.slice(s, e).join('\n'),
	        bk
	    ];
	};
	const getAnyColumnText = (ptk, book, key)=>{
	    if (!key) return [
	        -1,
	        ''
	    ];
	    if (book) {
	        return getBookColumnText(ptk, book, key);
	    } else {
	        let at, text;
	        for (let bk of Object.keys(ptk.columns)){
	            [at, text] = getBookColumnText(ptk, bk, key);
	            if (at > -1) return [
	                at,
	                text,
	                bk
	            ];
	        }
	        return [
	            -1,
	            ''
	        ];
	    }
	};
	const TRANSCLUSION_INDIRECT_REGEX = /@(.+)$/;
	const getColumnText = (ptk, bk, key)=>{
	    let [at, content, book] = getAnyColumnText(ptk, bk, key);
	    //book may overwrite bk if empty
	    let m = content.match(TRANSCLUSION_INDIRECT_REGEX);
	    while(m){
	        content = '';
	        key = m[1];
	        if (m) {
	            [at, content] = getAnyColumnText(ptk, bk, m[1]);
	        } else break;
	        m = content.match(/@([^ <>\[\]\{\}]+)$/);
	    }
	    return [
	        content,
	        [
	            {
	                key
	            }
	        ],
	        at,
	        0
	    ];
	};
	const columnTextByKey = (ptk, key, bk = '')=>{
	    return getColumnText(ptk, bk, key);
	};
	//return term key given entry,  
	function keyOfEntry(entry) {
	    let [at, text] = getAnyColumnText(this, '', entry);
	    let key = entry, m;
	    while(m = text.match(TRANSCLUSION_INDIRECT_REGEX)){
	        key = m[1];
	        [at, text] = getAnyColumnText(this, '', key);
	    }
	    return key;
	}
	const entriesOfKey = (ptk, key, firstonly = false)=>{
	    const out1 = [];
	    for (let bk of Object.keys(ptk.columns)){
	        const col = ptk.columns[bk];
	        if (!col.dkat) continue;
	        for(let j = 0; j < col.dkat.length; j++){
	            const [s, e] = ptk.rangeOfAddress("bk#" + bk + ".dk#" + col.dkat[j]);
	            const text = ptk.slice(s, e).join('\n');
	            if (text.endsWith('@' + key)) {
	                out1.push(col.keys.get(j));
	            }
	        }
	    }
	    if (out1.length == 0) {
	        return key;
	    } else return firstonly ? out1[0] || '' : out1;
	};

	function columnField(name1, field, idx) {
	    const column = this.columns[name1];
	    const at = column.fieldnames.indexOf(field);
	    return column.fieldvalues[at][idx];
	}
	async function inlineNote(tagname, noteid) {
	    const typedef = this.defines[tagname];
	    const col = this.columns[typedef.fields.type.foreign];
	    if (!col) return;
	    const at = col.findKey(noteid);
	    const textfield = typedef.attrs.text;
	    const at2 = col.fieldnames.indexOf(textfield);
	    //can await in the future
	    const values = col.fieldvalues[at2];
	    return values && values[at] || '';
	}
	function rowOf(rowname, idx, field = -1) {
	    const column = this.columns[rowname];
	    if (typeof field == 'string') {
	        field = column.fieldnames.indexOf(field);
	    }
	    const out = [];
	    if (field > 0) {
	        out.push({
	            name,
	            typedef: column.fieldsdef[field],
	            value: column.fieldvalues[field][idx]
	        });
	    } else {
	        for(let i = 0; i < column.fieldnames.length; i++){
	            const name1 = column.fieldnames[i];
	            out.push({
	                name: name1,
	                typedef: column.fieldsdef[i],
	                value: column.fieldvalues[i][idx]
	            });
	        }
	    }
	    return out;
	}
	const getCacheKey = (name1, field, tofind)=>{
	    return name1 + ':' + field + '=' + tofind;
	};
	function searchColumnField(name1, field, tofind) {
	    const simtofind = fromSim(tofind);
	    let cachekey = getCacheKey(name1, field, tofind);
	    let cache = this.scanCache[cachekey];
	    if (!cache && simtofind !== tofind) {
	        cache = this.scanCache[getCacheKey(name1, field, simtofind)];
	    }
	    if (!cache) {
	        const array = this.columns[name1][field];
	        if (!array) {
	            console.log('missing field', field, 'in column', name1);
	            return null;
	        }
	        let contain = indexOfs(array, tofind);
	        if (!contain.length && simtofind !== tofind) {
	            contain = indexOfs(array, simtofind);
	            if (contain.length) {
	                cachekey = getCacheKey(name1, field, simtofind);
	            }
	        }
	        const caption = this.columns[name1].caption || name1;
	        cache = {
	            name: name1,
	            field: field,
	            caption,
	            contain
	        };
	        this.scanCache[cachekey] = cache;
	    }
	    return cache;
	}
	function scanColumnFields(tofind) {
	    const out = [];
	    if (!tofind) return [];
	    for(let name1 in this.columns){
	        if (!this.columns[name1].attrs.scan) continue;
	        const scans = this.columns[name1].attrs.scan.split(",");
	        for(let i = 0; i < scans.length; i++){
	            const cache = searchColumnField.call(this, name1, scans[i], tofind);
	            out.push(cache);
	        }
	    }
	    for(let name1 in this.primarykeys){
	        if (!this.columns[name1].attrs.bme) continue;
	        const cachekey = name1 + '=' + tofind;
	        let cache = this.scanCache[cachekey];
	        if (!cache) {
	            const sa = this.primarykeys[name1];
	            const start = sa.enumStart(tofind);
	            const middle = sa.enumMiddle(tofind);
	            const end = sa.enumEnd(tofind);
	            const caption = this.columns[name1].caption || name1;
	            cache = {
	                name: name1,
	                caption,
	                start,
	                middle,
	                end
	            };
	            this.scanCache[cachekey] = cache;
	        }
	        out.push(cache);
	    }
	    return out;
	}

	function findFootmarkInBook(ptk, id, line) {
	    const ck = ptk.nearestChunk(line);
	    const fntag = ptk.defines.fn;
	    const closestfn = ptk.findClosestTag(fntag, 'id', id, line);
	    if (~closestfn) {
	        return ptk.name + ':bk#' + ck.bk.id + '.fm' + id;
	    }
	}
	function footNoteAddress(id, line) {
	    const ptk = this;
	    //先找同頁注
	    const fnaddr = findFootmarkInBook(ptk, id, line);
	    if (fnaddr) return fnaddr;
	    //異頁注
	    const ck = ptk.nearestChunk(line);
	    const chunktag = ptk.defines.ck;
	    const bktag = ptk.defines.bk;
	    const footbk = 'fn_' + ck.bkid;
	    const at = bktag.fields.id.values.indexOf(footbk);
	    if (at == -1) return ptk.name + ':' + ck.bk.id + '.fm' + id;
	    const booknotebkline = bktag.linepos[at];
	    const closestchunk = ptk.findClosestTag(chunktag, 'id', ck.id, booknotebkline);
	    const chunk = chunktag.fields.id.values[closestchunk];
	    const address = ptk.name + ':' + footbk + '.' + 'ck' + (parseInt(chunk) ? chunk : '#' + chunk) + '.fn' + id;
	    return address;
	}
	function footNoteInTSV(id, line) {
	    const ptk = this;
	    let ck = '', hasck = false;
	    if (!id) return '';
	    if (id && ~id.indexOf('.')) {
	        ck = ptk.getChunk(id.slice(0, id.indexOf('.')));
	        hasck = true;
	    } else {
	        ck = ptk.nearestChunk(line);
	    }
	    if (!ck) return '';
	    let bkid = ck.bkid + "-note"; //優先
	    let footnotecol = ptk.columns[bkid];
	    if (!footnotecol) {
	        bkid = ck.bkid;
	        footnotecol = ptk.columns[bkid]; //each tsv has one book
	    }
	    if (!footnotecol) return '--no note--';
	    if (footnotecol.attrs.footnote == 'ck' && !hasck) {
	        id = ck.id + '.' + id;
	    }
	    let o = footnotecol.fieldByKey(id, "note") || '';
	    if (!o) {
	        const key = ck.id + '.' + id;
	        const r = getBookColumnText(ptk, bkid, key);
	        o = r[1];
	    }
	    return o;
	}
	function footNoteByAddress(id, line) {
	    const ptk = this;
	    const ck = ptk.nearestChunk(line);
	    const chunktag = ptk.defines.ck;
	    const bktag = ptk.defines.ck;
	    const footnotetag = ptk.defines.f;
	    let footbk = ck.bkid.replace('_fn', '');
	    const at = bktag.fields.id.values.indexOf(footbk);
	    if (at == 0) footbk = '';
	    else footbk += '.'; //not needed to specified chunk    
	    const booknotebkline = bktag.linepos[at];
	    const closestchunk = ptk.findClosestTag(chunktag, 'id', ck.id, booknotebkline);
	    const chunk = chunktag.fields.id.values[closestchunk];
	    const footnoteat = ptk.findClosestTag(footnotetag, 'id', parseInt(id), chunktag.linepos[closestchunk]);
	    const footnoteline = footnotetag.linepos[footnoteat];
	    const highlightline = footnoteline - chunktag.linepos[closestchunk];
	    const address = footbk + 'ck' + chunk + (highlightline ? ":" + highlightline : '');
	    return address;
	}

	const bookPrefix = (bookname)=>{
	    let prefix = bookname;
	    const at = bookname.lastIndexOf('_');
	    if (~at) prefix = bookname.slice(0, at);
	    return prefix;
	};
	function getParallelLine(sourceptk, line, remote = false) {
	    const chunk = sourceptk.nearestChunk(line + 1);
	    if (!chunk) return [];
	    const bk = this.defines.bk;
	    const books = this.getParallelBook(chunk.bkid, remote);
	    const bookats = books.map((id)=>bk.fields.id.values.indexOf(id));
	    //同名 被 getParallelBook 去除，加回去
	    // if (!~books.indexOf(chunk.bkat)) bookats.push(chunk.bkat);
	    const bookstart = sourceptk.defines.bk.linepos[chunk.bkat];
	    const sourcelineoff = line - bookstart;
	    const out = [];
	    for(let i = 0; i < bookats.length; i++){
	        const bkid = bk.fields.id.values[bookats[i]];
	        const [start, end] = this.rangeOfAddress('bk#' + bkid + '.ck#' + chunk.id);
	        const bookstart = bk.linepos[bookats[i]];
	        const theline = bookstart + sourcelineoff;
	        if (theline <= end) {
	            out.push([
	                this,
	                start - bookstart,
	                theline
	            ]);
	        }
	    }
	    return out;
	}
	function getParallelBook(bookname, remote) {
	    if (typeof bookname == 'number') {
	        bookname = this.defines.bk.fields.id.values[bookname];
	    }
	    if (!bookname) return [];
	    const prefix = bookPrefix(bookname);
	    //如果不是remote，那不能同名
	    const books = this.defines.bk.fields.id.values.filter((it)=>bookPrefix(it) == prefix && (remote || bookname !== it));
	    return books;
	}
	//see compiler/linkfield.ts  for structure
	function foreignLinksAtTag(tagname, line) {
	    const tag = this.defines[tagname];
	    const linepos = tag === null || tag === void 0 ? void 0 : tag.linepos;
	    if (!tag || !linepos) return [];
	    const at = bsearchNumber(linepos, line);
	    const val = tag.fields.id.values[at].toString(); //
	    const out = [];
	    for(let sptkname in this.foreignlinks){
	        const sptk = poolGet(sptkname);
	        const linkarr = this.foreignlinks[sptkname];
	        for(let i = 0; i < linkarr.length; i++){
	            const [srctag, bk, targettagname, idStrArr, idxarr] = linkarr[i];
	            if (targettagname !== tagname) continue;
	            const srclinepos = sptk.defines[srctag].linepos;
	            const at2 = idStrArr.find(val);
	            const tagvalues = this.defines[srctag].fields['@'].values;
	            const arr = idxarr[at2];
	            for(let j = 0; j < (arr === null || arr === void 0 ? void 0 : arr.length); j++){
	                const address = tagvalues[arr[j]];
	                const line = srclinepos[arr[j]];
	                const ck = sptk.nearestChunk(line + 1);
	                out.push({
	                    text: address,
	                    line,
	                    ck,
	                    basket: sptkname
	                });
	            // console.log(at,address);
	            }
	        }
	    }
	    return out;
	}
	function enumParallelsPtk(address) {
	    const ptk = this;
	    const range = ptk.rangeOfAddress(address);
	    const ck = ptk.nearestChunk(range[0] + 1);
	    if (!ck) return [];
	    const paralleladdress = 'bk#' + ck.bkid + '.ck#' + ck.id;
	    const ptks = poolParallelPitakas(ptk);
	    const out = [
	        ptk.header.name
	    ];
	    for(let i = 0; i < ptks.length; i++){
	        const ptk2 = poolGet(ptks[i]);
	        const [start, end] = ptk2.rangeOfAddress(paralleladdress);
	        if (end > 0) {
	            out.push(ptks[i]);
	        }
	    }
	    return out;
	}

	function addBacklinks(tagname, tptk, bk, targettagname, chunks, nlinks) {
	    if (!tptk) tptk = '*'; //any ptk
	    if (!this.backlinks[tptk]) this.backlinks[tptk] = {};
	    if (!this.backlinks[tptk][this.name]) {
	        this.backlinks[tptk][this.name] = [];
	    }
	    this.backlinks[tptk][this.name].push([
	        tagname,
	        bk,
	        targettagname,
	        chunks,
	        nlinks
	    ]);
	}
	function addForeignLinks(fptk) {
	    for(let tptk in fptk.backlinks){
	        if (tptk == this.name || tptk === '*') {
	            for(let sptk in fptk.backlinks[tptk]){
	                this.foreignlinks[sptk] = fptk.backlinks[tptk][sptk];
	            }
	        }
	    }
	}

	function backLinksOf(bk, line) {
	    const BK = this.LocalBackLinks[bk];
	    if (!BK) return [];
	    return BK[line] || [];
	}
	function backTransclusionOf(entry) {
	    const ptk = this;
	    if (!ptk.backtransclusions) return [];
	    const key = ptk.keyOfEntry(entry);
	    const items = ptk.backtransclusions[key] || [];
	    return items.map((it)=>entriesOfKey(ptk, it, true)).filter((it)=>!!it);
	}
	function guessBookId(t) {
	    t = removeBracket(t);
	    const m = t.match(CJKWordBegin_Reg);
	    if (m) {
	        return this.BookIdByName[m[1]];
	    }
	}
	const buildBookNames = (ptk)=>{
	    var _ptk_defines_bk;
	    for(let i = 0; i < ((_ptk_defines_bk = ptk.defines.bk) === null || _ptk_defines_bk === void 0 ? void 0 : _ptk_defines_bk.linepos.length); i++){
	        const id = ptk.defines.bk.fields.id.values[i];
	        const t = ptk.defines.bk.getInnertext(i);
	        if (!t) continue;
	        ptk.BookIdByName[t] = id;
	        ptk.BookIdByName[toSim$1(t)] = id;
	        ptk.BookNameById[id] = t;
	    }
	};
	function bookNameById(id) {
	    const tag = this.getTagById('bk', id);
	    return this.defines.bk.getInnertext(tag === null || tag === void 0 ? void 0 : tag.at);
	}
	const findEntryByDk = (ptk, dkid, bk)=>{
	    Object.keys(ptk.columns);
	    if (bk && ptk.columns[bk]) {
	        const at = ptk.columns[bk].dkat.indexOf(parseInt(dkid));
	        if (~at) return ptk.columns[bk].keys.get(at);
	    } else {
	        for(let col in ptk.columns){
	            var _ptk_columns_col_dkat;
	            const at = (_ptk_columns_col_dkat = ptk.columns[col].dkat) === null || _ptk_columns_col_dkat === void 0 ? void 0 : _ptk_columns_col_dkat.indexOf(dkid);
	            if (~at) return ptk.columns[col].keys.get(at);
	        }
	    }
	    return '';
	};
	function buildBackTransclusions(ptk) {
	    const section = ptk.getSection('_backtransclusions');
	    if (!section.length) return {};
	    const out = {};
	    const keys = new StringArray(section.shift(), {
	        sep: LEMMA_DELIMITER
	    });
	    const dk = ptk.defines.dk;
	    if (!dk) return out;
	    for(let i = 0; i < keys.len(); i++){
	        const linepos = unpackIntDelta(section.shift());
	        //convert linepos to entry
	        const entries = [];
	        for(let j = 0; j < linepos.length; j++){
	            const dkat = dk.linepos.indexOf(linepos[j]);
	            if (~dkat) {
	                const bk = ptk.nearestTag(linepos[j], 'bk', 'id');
	                const dkid = dk.fields.id.values[dkat];
	                const e = findEntryByDk(ptk, dkid, bk);
	                if (e) entries.push(e);
	            }
	        }
	        //resolve the key from entry, which is not determine at compile time
	        const [content, objarr] = columnTextByKey(ptk, keys.get(i));
	        const key = objarr[0].key;
	        if (!out[key]) out[key] = entries;
	        else {
	            out[key].concat(entries);
	            out[key].sort();
	        }
	    }
	    return out;
	}
	function buildLocalBacklinks(ptk) {
	    const X = ptk.defines.x;
	    const Y = ptk.defines.y;
	    const L = {};
	    if (!X || !Y) return;
	    const XID = X.fields.id.values;
	    const Xlinepos = ptk.defines.x.linepos;
	    for(let i = 0; i < XID.length; i++){
	        let [page, book, line] = parsePageBookLine(XID[i]);
	        if (!book) {
	            const innertext = X.getInnertext(i);
	            book = guessBookId.call(ptk, innertext);
	        }
	        const sbook = ptk.nearestTag(Xlinepos[i], 'bk', 'id');
	        if (!book) book = sbook;
	        const addr = 'bk#' + book + '.y#' + page;
	        const [s, e] = ptk.rangeOfAddress(addr);
	        //console.log(page,book,line,addr,s,e);
	        if (!L[book]) L[book] = {};
	        if (!L[book][s + line]) L[book][s + line] = [];
	        L[book][s + line].push(Xlinepos[i]);
	    }
	    return L;
	}
	const enableBacklinkFeature = (ptk)=>{
	    ptk.BookIdByName = {};
	    ptk.BookNameById = {};
	    ptk.guessBookId = guessBookId;
	    ptk.bookNameById = bookNameById;
	    //initial build
	    ptk.backLinksOf = backLinksOf;
	    ptk.backTransclusionOf = backTransclusionOf;
	    ptk.keyOfEntry = keyOfEntry;
	    buildBookNames(ptk);
	    ptk.LocalBackLinks = buildLocalBacklinks(ptk);
	    ptk.backtransclusions = buildBackTransclusions(ptk);
	};

	function postingLine(posting) {
	    return plContain(posting, this.inverted.tokenlinepos)[0];
	}
	const enableFTSFeature = (ptk)=>{
	    const section = ptk.getSection("_tokens");
	    if (!ptk.inverted && section && section.length) {
	        section.shift();
	        const postingstart = ptk.sectionRange('_postings')[0];
	        ptk.queryCache = {};
	        ptk.inverted = new Inverted(section, postingstart);
	        ptk.loadPostings = loadPostings;
	        ptk.loadPostingsSync = loadPostingsSync;
	        ptk.getPostings = getPostings;
	        ptk.postingline = postingLine;
	        ptk.searchSentenceSync = searchSentenceSync;
	        ptk.searchSentence = searchSentence;
	        ptk.parseQuery = parseQuery;
	        ptk.scanText = scanText;
	        ptk.hitsOfLine = hitsOfLine;
	        ptk.scoreLine = scoreLine;
	    }
	};

	const enableTOCFeature = (ptk)=>{
	    //build chunk toc
	    const section = ptk.getSection("toc");
	    if (ptk.attributes.toctag && section && section.length > 1) {
	        const firstline = section.shift();
	        const { name } = sourceType(firstline);
	        if (!ptk.tocs) ptk.tocs = {};
	        ptk.tocs[name || '*'] = new TableOfContent(section, name);
	        const toctags = ptk.attributes.toctag.split(',');
	        buildTocTag.call(ptk, toctags);
	    }
	};

	function getCaption(at, short = false) {
	    var _chunktag_fields_id, _chunktag_fields;
	    const chunktag = this.defines.ck;
	    let caption = chunktag === null || chunktag === void 0 ? void 0 : chunktag.getInnertext(at);
	    const id = chunktag === null || chunktag === void 0 ? void 0 : (_chunktag_fields = chunktag.fields) === null || _chunktag_fields === void 0 ? void 0 : (_chunktag_fields_id = _chunktag_fields.id) === null || _chunktag_fields_id === void 0 ? void 0 : _chunktag_fields_id.values[at];
	    const onChunkCaption = this.template.onChunkCaption;
	    if (!caption) {
	        var _this_columns_chunktag_column_keys, _this_columns_chunktag_column;
	        caption = ((_this_columns_chunktag_column = this.columns[chunktag === null || chunktag === void 0 ? void 0 : chunktag.column]) === null || _this_columns_chunktag_column === void 0 ? void 0 : (_this_columns_chunktag_column_keys = _this_columns_chunktag_column.keys) === null || _this_columns_chunktag_column_keys === void 0 ? void 0 : _this_columns_chunktag_column_keys.get(at)) || '';
	        if (!caption && onChunkCaption) caption = onChunkCaption(id);
	    }
	    const at2 = caption === null || caption === void 0 ? void 0 : caption.indexOf(";");
	    let shortcaption = caption || '';
	    if (~at2) {
	        shortcaption = caption.slice(at2);
	        caption = caption.slice(0, at2);
	    }
	    return short ? shortcaption : caption;
	}
	function caption(at) {
	    //return onChunkCaption?caption:id+'.'+caption;
	    let caption = this.getCaption(at);
	    let depth = 0;
	    while(caption && caption.endsWith('-')){
	        depth++;
	        caption = caption.slice(0, caption.length - 1);
	    }
	    let at2 = at, parents = [];
	    while(at2 > 0 && depth){
	        at2--;
	        const par = this.getCaption(at2).split(/[- ]+/);
	        const pdepth = par.length;
	        while(!par[par.length - 1])par.pop();
	        if (pdepth - 1 > depth) ; else if (par.length > 1 || pdepth == 1) {
	            while(par.length && depth){
	                parents.unshift('-' + par.pop());
	                depth--;
	            }
	        }
	    }
	    return caption + parents.join('');
	}
	function nearestChunk(line) {
	    const chunktag = this.defines.ck || this.defines.dk;
	    const at = this.nearestTag(line, chunktag);
	    return this.getChunk(at);
	}
	function getHeading(line) {
	    var _chunktag_fields_id, _chunktag_fields;
	    if (!line) return '';
	    const chunktag = this.defines.ck;
	    const booktag = this.defines.bk;
	    const linepos = (chunktag === null || chunktag === void 0 ? void 0 : chunktag.linepos) || [];
	    const at = bsearchNumber(linepos, line + 1) - 1;
	    const lineoff = line - linepos[at];
	    const id = chunktag === null || chunktag === void 0 ? void 0 : (_chunktag_fields = chunktag.fields) === null || _chunktag_fields === void 0 ? void 0 : (_chunktag_fields_id = _chunktag_fields.id) === null || _chunktag_fields_id === void 0 ? void 0 : _chunktag_fields_id.values[at];
	    const bkat = this.nearestTag(line + 1, booktag);
	    const bk = getBookInfo.call(this, bkat);
	    const bkid = bk === null || bk === void 0 ? void 0 : bk.id;
	    /* TODO
	if caption has leading - , trace back to fetch ancestor node,
	this is suitable for tree structure with less branches,
	not suitable for dictionary wordheads
	*/ const caption = this.caption(at);
	    return {
	        id,
	        tagname: 'ck',
	        caption,
	        lineoff,
	        bk,
	        bkid
	    };
	}
	function getBookInfo(at) {
	    var _booktag_fields_heading;
	    const booktag = this.defines.bk;
	    const bkid = booktag.fields.id.values[at];
	    let bkcaption = booktag === null || booktag === void 0 ? void 0 : booktag.getInnertext(at);
	    let short = bkcaption.slice(0, 2);
	    const bkheading = (booktag === null || booktag === void 0 ? void 0 : (_booktag_fields_heading = booktag.fields.heading) === null || _booktag_fields_heading === void 0 ? void 0 : _booktag_fields_heading.values[at]) || (booktag === null || booktag === void 0 ? void 0 : booktag.getInnertext(at));
	    const at2 = bkcaption.indexOf(";");
	    if (~at2) {
	        short = bkcaption.slice(at2 + 1);
	        bkcaption = bkcaption.slice(0, at2);
	    }
	    return {
	        id: bkid,
	        caption: bkcaption,
	        short,
	        heading: bkheading,
	        at
	    };
	}
	function getChunk(at) {
	    at = parseInt(at);
	    const chunktag = this.defines.ck || this.defines.dk;
	    const booktag = this.defines.bk;
	    if (at < 0) return null;
	    if (at >= chunktag.fields.id.values.length) return null;
	    const line = chunktag.linepos[at];
	    const bkat = this.nearestTag(line + 1, booktag);
	    const bk = getBookInfo.call(this, bkat);
	    const bkid = bk.id; //legacy
	    const id = chunktag.fields.id.values[at];
	    const innertext = chunktag.getInnertext(at);
	    const caption = this.caption(at);
	    const depth = chunktag.depths ? chunktag.depths[at] || 1 : 1;
	    return {
	        bk,
	        bkid,
	        bkat,
	        caption,
	        at,
	        id,
	        depth,
	        line: chunktag.linepos[at],
	        lineend: chunktag.linepos[at + 1] || -1,
	        innertext
	    };
	}
	const resetBy = (ptk, tagname)=>{
	    for(let t in ptk.defines){
	        var _tag_attrs_reset;
	        const tag = ptk.defines[t];
	        if (((_tag_attrs_reset = tag.attrs.reset) === null || _tag_attrs_reset === void 0 ? void 0 : _tag_attrs_reset.split(',').indexOf(tagname)) > -1) {
	            return t;
	        }
	    }
	    return null;
	};
	function ancestorChunks(at, start) {
	    const chunktag = this.defines.ck;
	    if (!chunktag.depths) return [];
	    let line = chunktag.linepos[at];
	    let depth = chunktag.depths[at];
	    const out = [];
	    while(line > start && depth > 1){
	        if (depth > chunktag.depths[at]) {
	            out.unshift(at);
	            depth--;
	        }
	        at--;
	        line = chunktag.linepos[at];
	    }
	    return out;
	}
	function prevsiblingChunk(at, start) {
	    let p = at - 1;
	    const chunktag = this.defines.ck;
	    if (!chunktag.depths && at > 0) return at - 1;
	    while(p > 0){
	        if (chunktag.depths[p] == chunktag.depths[at]) return p;
	        else if (chunktag.depths[p] < chunktag.depths[at]) break;
	        p--;
	        if (start < chunktag.linepos[p]) break;
	    }
	    return -1;
	}
	function nextsiblingChunk(at, end) {
	    let p = at + 1;
	    const chunktag = this.defines.ck;
	    if (!chunktag.depths && at < end) return at + 1;
	    while(p < chunktag.linepos.length){
	        if (chunktag.depths[p] == chunktag.depths[at]) return p;
	        else if (chunktag.depths[p] < chunktag.depths[at]) break;
	        p++;
	        if (chunktag.linepos[p] >= end) break;
	    }
	    return -1;
	}
	function firstChildChunk(at) {
	    const chunktag = this.defines.ck;
	    if (!chunktag.depths) return -1;
	    if (chunktag.depths[at + 1] == chunktag.depths[at] + 1) return at + 1;
	    return -1;
	}
	function neighborChunks(at) {
	    const ptk = this;
	    // const chunktag=this.defines.ck
	    // const ck=this.nearestChunk( chunktag.linepos[at] );   
	    // at=ck.at-1;
	    const resettag = this.defines[resetBy(this, 'ck')];
	    const nearest = resettag ? this.nearestTag(at, resettag) - 1 : 0;
	    const start = resettag ? resettag.linepos[nearest] : 0;
	    const end = resettag ? resettag.linepos[nearest + 1] || ptk.header.eot : ptk.header.eot;
	    const ancestors = ancestorChunks.call(this, at, start);
	    const out = ancestors.map((it)=>ptk.getChunk.call(ptk, it));
	    const prev = prevsiblingChunk.call(this, at);
	    if (prev > -1 && (!ancestors.length || ancestors[ancestors.length - 1] < prev)) {
	        out.push(this.getChunk(prev));
	    }
	    out.push(this.getChunk(at));
	    //add bookname
	    const first = firstChildChunk.call(this, at, start);
	    if (first > -1) out.push(this.getChunk(first));
	    const next = nextsiblingChunk.call(this, at, end);
	    if (next > -1) out.push(this.getChunk(next));
	    return out;
	}

	function humanName(short, lang = 'zh') {
	    let n = this.attributes[lang] || this.name;
	    const at = n.indexOf('|');
	    if (at == -1) return n;
	    return short ? n.slice(0, at) : n.slice(at + 1);
	}
	const enableTagFeature = (ptk)=>{
	    ptk.innertext = innertext;
	    ptk.humanName = humanName;
	    ptk.fetchAddress = fetchAddress;
	    ptk.fetchAddressExtra = fetchAddressExtra;
	    ptk.findClosestTag = findClosestTag;
	    ptk.validId = validId;
	    ptk.nearestTag = nearestTag;
	    ptk.getTagFields = getTagFields;
	    ptk.queryTagFields = queryTagFields;
	    ptk.tagInRange = tagInRange;
	    ptk.tagCount = tagCount;
	    ptk.fetchTag = fetchTag;
	    ptk.getTagById = getTagById;
	    ptk.rangeOfAddress = rangeOfAddress;
	    ptk.rangeOfElementId = rangeOfElementId;
	    ptk.nearestChunk = nearestChunk;
	    ptk.getChunk = getChunk;
	    ptk.neighborChunks = neighborChunks;
	    ptk.getCaption = getCaption;
	    ptk.getHeading = getHeading;
	    ptk.caption = caption;
	    ptk.alignable = alignable;
	};

	const enableFootnoteFeature = (ptk)=>{
	    ptk.inlineNote = inlineNote;
	    ptk.footNoteAddress = footNoteAddress;
	    ptk.footNoteByAddress = footNoteByAddress;
	    ptk.footNoteInTSV = footNoteInTSV;
	};
	const enableAccelon23Features = (ptk)=>{
	    //check fields
	    enableTagFeature(ptk);
	    enableTOCFeature(ptk);
	    enableFTSFeature(ptk);
	    enableBacklinkFeature(ptk);
	    enableFootnoteFeature(ptk);
	    ptk.scanColumnFields = scanColumnFields;
	    ptk.searchColumnField = searchColumnField;
	    ptk.tagAtAction = tagAtAction;
	    ptk.scanCache = {};
	    ptk.queryCache = {};
	    ptk.columnField = columnField;
	    ptk.foreignLinksAtTag = foreignLinksAtTag;
	    ptk.getParallelBook = getParallelBook;
	    ptk.getParallelLine = getParallelLine;
	    ptk.enumParallelsPtk = enumParallelsPtk;
	    ptk.taggedLines = {};
	    ptk.foreignlinks = {};
	    ptk.addForeignLinks = addForeignLinks;
	    ptk.addBacklinks = addBacklinks;
	    ptk.backlinks = {};
	    ptk.rowOf = rowOf;
	    ptk.parallels = {}; //parallels showing flag, ptkname:string, onoff:boolean
	};

	const parallelWithDiff = (ptk, line, includeself = false, local = true, remote = false)=>{
	    const out = [];
	    if (!ptk) return out;
	    //因為nearesttag 返回 0 表示 出現在第一個bk 之前
	    const bkat = ptk.nearestTag(line + 1, 'bk');
	    const bookstart = ptk.defines.bk.linepos[bkat];
	    if (includeself) {
	        out.push([
	            ptk,
	            bookstart,
	            line
	        ]);
	    }
	    const lineoff = line - bookstart;
	    const bkid = ptk.defines.bk.fields.id.values[bkat];
	    const books = ptk.getParallelBook(bkid);
	    if (local) {
	        for(let i = 0; i < books.length; i++){
	            const [start, end] = ptk.rangeOfAddress('bk#' + books[i]);
	            if (lineoff <= end - start) {
	                //假設每一行都對齊，所以返回 書的行差
	                out.push([
	                    ptk,
	                    start - bookstart,
	                    start + lineoff
	                ]);
	            }
	        }
	    }
	    if (remote) {
	        const parallelPitakas = poolParallelPitakas(ptk);
	        for(let i = 0; i < parallelPitakas.length; i++){
	            const pptk = usePtk(parallelPitakas[i]);
	            // const lineoff=line-bkstart;
	            // const [start]=pptk.rangeOfAddress('bk#'+bkid);
	            const lines = pptk.getParallelLine(ptk, line, true);
	            lines.forEach((it)=>out.push([
	                    ...it
	                ]));
	        }
	    }
	    return out;
	};
	const getParallelLines = async (ptk, line, _out, opts = {})=>{
	    const lines = parallelWithDiff(ptk, line, true, opts.local, opts.remote);
	    const out = [];
	    for(let i = 0; i < lines.length; i++){
	        const [ptk, bookstart, line] = lines[i];
	        await ptk.loadLines([
	            line
	        ]);
	        const linetext = ptk.getLine(line);
	        const heading = ptk.getHeading(line);
	        out.push({
	            ptk,
	            heading,
	            linetext,
	            line
	        });
	    }
	    if (_out) _out.push(...out);
	    return out;
	};

	const stylestring = (f)=>{
	    return `left:${f.left}px;width:${f.width}px;top:${f.top}px;height:${f.height}px`;
	};

	const AppPrefix = 'YLZ.';
	const loadSettings = ()=>{
	    const activefolioid = 'pphs'; //localStorage.getItem(AppPrefix+'activefolioid')||'pphs';  
	    const autodict = localStorage.getItem(AppPrefix + 'autodict') || 'off';
	    const newbie = localStorage.getItem(AppPrefix + 'newbie') || 'on';
	    const playnextjuan = localStorage.getItem(AppPrefix + 'playnextjuan') || 'on';
	    const showpunc = localStorage.getItem(AppPrefix + 'showpunc') || 'on';
	    const showsponsor = localStorage.getItem(AppPrefix + 'showsponsor') || 'off';
	    const showyoutube = localStorage.getItem(AppPrefix + 'showyoutube') || 'off';
	    const heightratio = parseFloat(localStorage.getItem(AppPrefix + 'heightratio') || '1') || 1;
	    const textsize = parseInt(localStorage.getItem(AppPrefix + 'textsize') || '150') || 150;
	    const playrate = parseInt(localStorage.getItem(AppPrefix + 'playrate') || '100') || 100;
	    const vip = localStorage.getItem(AppPrefix + 'vip') || '';
	    const tosim = localStorage.getItem(AppPrefix + 'tosim') || '0';
	    let _favorites = localStorage.getItem(AppPrefix + 'favorites') || '{}';
	    let _preferaudio = localStorage.getItem(AppPrefix + 'preferaudio') || '{}';
	    let _tofindhistory = localStorage.getItem(AppPrefix + 'tofindhistory') || '["淨信",""]';
	    let favorites = {}, preferaudio = {}, tofindhistory = [];
	    try {
	        favorites = JSON.parse(_favorites);
	        preferaudio = JSON.parse(_preferaudio);
	        tofindhistory = JSON.parse(_tofindhistory);
	    } catch (e) {
	        console.log(e);
	        favorites = {};
	        preferaudio = {};
	    }
	    return {
	        tosim,
	        vip,
	        activefolioid,
	        heightratio,
	        tofindhistory,
	        playrate,
	        textsize,
	        showsponsor,
	        showyoutube,
	        autodict,
	        newbie,
	        favorites,
	        playnextjuan,
	        preferaudio,
	        showpunc
	    };
	};
	const saveSettings = ()=>{
	    for(let key in settingsToBeSave){
	        localStorage.setItem(key, settingsToBeSave[key]);
	        delete settingsToBeSave[key];
	    }
	    clearTimeout(updateTimer);
	// console.log('settings autosaved on',new Date())
	};
	let updateTimer;
	const settingsToBeSave = {};
	const updateSettings = (_settings)=>{
	    let updated = false, oldval;
	    for(let key in _settings){
	        if (_settings.hasOwnProperty(key)) {
	            if (settings[key] !== _settings[key]) {
	                let val = _settings[key];
	                if (typeof val == 'object') {
	                    val = JSON.stringify(_settings[key]);
	                    oldval = JSON.stringify(localStorage.getItem(key));
	                }
	                if (val !== oldval) {
	                    settingsToBeSave[AppPrefix + key] = val;
	                    if (typeof _settings[key] == 'object') {
	                        settings[key] = JSON.parse(JSON.stringify(_settings[key]));
	                    } else {
	                        settings[key] = _settings[key];
	                    }
	                    updated = true;
	                }
	            }
	        }
	    }
	    if (updated) {
	        clearTimeout(updateTimer);
	        updateTimer = setTimeout(saveSettings, 5000); //autosave in 5 seconds
	    }
	};
	const settings = loadSettings();

	const subscriber_queue = [];
	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#writable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Writable<T>}
	 */ function writable(value, start = noop) {
	    /** @type {import('./public.js').Unsubscriber} */ let stop;
	    /** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */ const subscribers = new Set();
	    /** @param {T} new_value
		 * @returns {void}
		 */ function set(new_value) {
	        if (safe_not_equal(value, new_value)) {
	            value = new_value;
	            if (stop) {
	                // store is ready
	                const run_queue = !subscriber_queue.length;
	                for (const subscriber of subscribers){
	                    subscriber[1]();
	                    subscriber_queue.push(subscriber, value);
	                }
	                if (run_queue) {
	                    for(let i = 0; i < subscriber_queue.length; i += 2){
	                        subscriber_queue[i][0](subscriber_queue[i + 1]);
	                    }
	                    subscriber_queue.length = 0;
	                }
	            }
	        }
	    }
	    /**
		 * @param {import('./public.js').Updater<T>} fn
		 * @returns {void}
		 */ function update(fn) {
	        set(fn(value));
	    }
	    /**
		 * @param {import('./public.js').Subscriber<T>} run
		 * @param {import('./private.js').Invalidator<T>} [invalidate]
		 * @returns {import('./public.js').Unsubscriber}
		 */ function subscribe(run, invalidate = noop) {
	        /** @type {import('./private.js').SubscribeInvalidateTuple<T>} */ const subscriber = [
	            run,
	            invalidate
	        ];
	        subscribers.add(subscriber);
	        if (subscribers.size === 1) {
	            stop = start(set, update) || noop;
	        }
	        run(value);
	        return ()=>{
	            subscribers.delete(subscriber);
	            if (subscribers.size === 0 && stop) {
	                stop();
	                stop = null;
	            }
	        };
	    }
	    return {
	        set,
	        update,
	        subscribe
	    };
	}

	const CacheName = 'v1::ylz';
	const APPVER = '26.2.6';

	let ptk;
	const silence = {
	    vid: '',
	    performer: '-靜默-'
	};
	const audiofolder = '/baudio/';
	const setTimestampPtk = (_ptk)=>{
	    ptk = _ptk;
	};
	const fetchAudioList = async (activeid, store, showyoutube = false)=>{
	    let out = [];
	    if (!ptk) return out;
	    const ts = ptk.columns.timestamp;
	    if (!ts) return out;
	    const cache = await caches.open(CacheName);
	    const keys = await cache.keys();
	    const incaches = keys.map((it)=>it.url.slice(window.location.origin.length + audiofolder.length).replace('.mp3', ''));
	    for(let i = 0; i < ts.keys.len(); i++){
	        const aid = ts.keys.get(i);
	        const audiohost = ts.videohost[i];
	        let performer = ts.performer[i];
	        let youtube = '';
	        const at = performer.indexOf('|');
	        if (~at) {
	            if (showyoutube) youtube = performer.slice(at + 1);
	            performer = performer.slice(0, at);
	        }
	        const timestamp = ts.timestamp[i];
	        const bookid = ts.bookid[i];
	        const incache = 1 - !~incaches.indexOf(aid.replace(/\^\d+$/, ''));
	        activeid == bookid && out.push({
	            aid,
	            performer,
	            youtube,
	            incache,
	            bookid,
	            timestamp,
	            audiohost
	        });
	    }
	    //sort by name
	    out.sort((a, b)=>a.performer == b.performer ? 0 : a.performer < b.performer ? -1 : 1);
	    const cacheno = out.filter((it)=>!it.incache).concat();
	    out = out.filter((it)=>it.incache).concat(cacheno);
	    out.unshift(silence);
	    if (store) store.set(out);
	    return out;
	};

	const online = writable(navigator.onLine);
	const thezip = writable(null);
	const activePtk = writable('ylz-prjn');
	const folioincache = writable({});
	const loadingfolio = writable(false); //loadFolio done
	const loadingzip = writable(false); //load the folio zip
	const autodict = writable(settings.autodict);
	const activepb = writable('1');
	const activefolioid = writable(settings.activefolioid);
	const maxfolio = writable(0);
	const downloading = writable(0);
	const sharing = writable(false);
	const favorites = writable(settings.favorites);
	const preferaudio = writable(settings.preferaudio);
	const showpunc = writable(settings.showpunc);
	const showsponsor = writable(settings.showsponsor);
	const showyoutube = writable(settings.showyoutube);
	const landscape = writable(false);
	const isAndroid = writable(false);
	const searchable = writable('');
	const leftmode = writable('folio');
	const foliotext = writable(null);
	const tofind = writable('');
	const tofindhistory = writable(settings.tofindhistory);
	const heightratio = writable(settings.heightratio);
	const textsize = writable(settings.textsize);
	const vip = writable(settings.vip);
	const tosim = writable(settings.tosim);
	const hasupdate = writable(true);
	const playrate = writable(settings.playrate);
	let player;
	const setplayer = (p)=>player = p;
	// export const foliorawtexts=writable([]);
	// export const foliostartfrom=writable(0)
	const mediaurls = writable([
	    silence
	]);
	const notificationmessage = writable('');
	const bookByFolio = (fid, ptk)=>{
	    if (ptk) {
	        const folio = dc.defines.folio;
	        const bk1 = dc.defines.bk;
	        const at = folio.fields.id.values.indexOf(fid);
	        if (!~at) return '';
	        const line = folio.linepos[at] + 1;
	        const at2 = bsearchNumber(bk1.linepos, line) - 1; //closest bk
	        return bk1.fields.id.values[at2];
	    } else {
	        return fid.replace(/\d+$/, '');
	    }
	};
	const audioid = writable('');
	const curPtk = ()=>{
	    return usePtk(get_store_value(activePtk));
	};
	const folioLines = function(_fid) {
	    var _ptk_defines_folio_fields_id;
	    const ptk = usePtk(get_store_value(activePtk));
	    const fid = _fid || get_store_value(activefolioid);
	    const at = (_ptk_defines_folio_fields_id = ptk.defines.folio.fields.id) === null || _ptk_defines_folio_fields_id === void 0 ? void 0 : _ptk_defines_folio_fields_id.values.indexOf(fid);
	    if (~at) {
	        return ptk.defines.folio.fields.lines.values[at] || 5;
	    }
	    return 5;
	};
	const folioChars = writable(17);
	const playing = writable(false);
	const continueplay = writable(false);
	const playnextjuan = writable(settings.playnextjuan); //自動播放下一卷
	const tapmark = writable([
	    '2',
	    0,
	    0
	]); // folio*folioLines*folioChar+offset
	const remainrollback = writable(-1); //infinite
	const newbie = writable(settings.newbie);
	const idlecount = writable(0);
	const showpaiji = writable(false);
	const ptks = [
	    'ylz-prjn',
	    'ylz-tg',
	    'ylz_sanskrit',
	    'ylz-rite',
	    'dc'
	];
	const allptks = [
	    'ylz-prjn',
	    'ylz-tg',
	    'ylz-svk',
	    'ylz-vny',
	    'ylz-rite',
	    'ylz_sanskrit',
	    'dc'
	];
	const reverseswipe = writable(false);
	activefolioid.subscribe((activefolioid)=>updateSettings({
	        activefolioid
	    }));
	autodict.subscribe((autodict)=>updateSettings({
	        autodict
	    }));
	newbie.subscribe((newbie)=>updateSettings({
	        newbie
	    }));
	showpunc.subscribe((showpunc)=>updateSettings({
	        showpunc
	    }));
	showsponsor.subscribe((showsponsor)=>updateSettings({
	        showsponsor
	    }));
	showyoutube.subscribe((showyoutube)=>updateSettings({
	        showyoutube
	    }));
	favorites.subscribe((favorites)=>updateSettings({
	        favorites
	    }));
	playrate.subscribe((playrate)=>updateSettings({
	        playrate
	    }));
	preferaudio.subscribe((preferaudio)=>updateSettings({
	        preferaudio
	    }));
	tofindhistory.subscribe((tofindhistory)=>updateSettings({
	        tofindhistory
	    }));
	heightratio.subscribe((heightratio)=>updateSettings({
	        heightratio
	    }));
	tosim.subscribe((tosim)=>updateSettings({
	        tosim
	    }));
	reverseswipe.subscribe((reverseswipe)=>{
	    updateSettings({
	        reverseswipe
	    });
	});
	textsize.subscribe((textsize)=>{
	    const tsz = (textsize / 100).toFixed(2) + 'em';
	    document.documentElement.style.setProperty('--textsize', tsz);
	    updateSettings({
	        textsize
	    });
	});
	vip.subscribe((vip)=>updateSettings({
	        vip
	    }));
	const findByAudioId = (id, column = 'timestamp')=>{
	    const ptk = usePtk('dc');
	    if (!ptk.columns[column]) return null;
	    const ts = ptk.columns[column].fieldsByKey(id);
	    return {
	        id,
	        ...ts
	    };
	};
	const stopAudio = ()=>{
	    if (player && player.paused) player === null || player === void 0 ? void 0 : player.pause();
	    playing.set(false);
	    remainrollback.set(-1);
	};
	const idletime = 30;
	const hasVariorum = (bkid)=>{
	    const ptk = usePtk('ylz_sanskrit');
	    const at = bkid.indexOf('_');
	    if (~at) bkid = bkid.slice(0, at);
	    return ~ptk.defines.bk.fields.id.values.indexOf(bkid + '_variorum');
	};
	const hasSanskrit = (bkid)=>{
	    const ptk = usePtk('ylz_sanskrit');
	    const at = bkid.indexOf('_');
	    if (~at) bkid = bkid.slice(0, at);
	    const at2 = ptk.defines.bk.fields.id.values.indexOf(bkid);
	    return ~at2;
	};
	const hasTranslation = (ptk, bkid)=>{
	    const books = ptk.getParallelBook(bkid);
	    return books.length;
	};
	const makeAddressFromFolioPos = (pbid, cx = 0, cy = 0)=>{
	    if (typeof pbid !== 'string') {
	        cx = pbid[1];
	        cy = pbid[2];
	        pbid = pbid[0];
	    }
	    const ft = get_store_value(foliotext);
	    if (!ft || !ft.fromFolioPos) return '';
	    const { ckid, lineoff, choff } = ft.fromFolioPos(pbid, cx, cy);
	    const address = makeAddress('', 'bk#' + bookByFolio(get_store_value(activefolioid)) + '.ck#' + ckid, 0, 0, lineoff, choff);
	    return address;
	};
	const tapAddress = ()=>makeAddressFromFolioPos(get_store_value(tapmark));
	const parallelFolios = (ptk, folioid)=>{
	    folioid = folioid || get_store_value(activefolioid);
	    const folio = ptk.defines.folio;
	    const at = folioid.indexOf('_');
	    const prefix = (~at ? folioid.slice(0, at) : folioid).replace(/1$/, ''); //only accept juan 1
	    const out = [], idarr = folio.fields.id.values;
	    for(let i = 0; i < idarr.length; i++){
	        if (~idarr[i].indexOf('_variorum')) continue;
	        if (idarr[i].startsWith(prefix + '_') && idarr[i] !== folioid && !idarr[i].replace(/1$/, '').match(/\d$/)) {
	            out.push(i);
	        }
	    }
	    return out;
	};
	const selectmedia = (aid, restart)=>{
	    if (get_store_value(remainrollback) == 0) remainrollback.set(-1);
	    if (!aid) stopAudio();
	    else {
	        const prefer = get_store_value(preferaudio);
	        prefer[get_store_value(activefolioid)] = aid;
	        preferaudio.set(Object.assign({}, prefer));
	        playing.set(true);
	    }
	    audioid.set(aid || '');
	    if (restart) activepb.set('1');
	    setTimeout(()=>{
	        player.play();
	    }, 100);
	};
	const sideWidth = ()=>{
	    const w = window.innerHeight * 0.45; //  folio image W720 /H1600 = 0.45
	    const r = (w * 100 / window.innerWidth).toFixed(2);
	    return 'left:' + r + 'vw;width:' + (100 - r) + 'vw';
	};
	const folioHolderWidth = (ls, ratio = 1, _swiper)=>{
	    let style = '100vw';
	    ratio = ratio || 1;
	    if (get_store_value(landscape)) {
	        const w = window.innerHeight * 0.45 * ratio;
	        const r = (w * 100 / window.innerWidth).toFixed(2);
	        style = r + 'vw';
	    }
	    if (_swiper && (_swiper === null || _swiper === void 0 ? void 0 : _swiper.update)) setTimeout(()=>{
	        (_swiper === null || _swiper === void 0 ? void 0 : _swiper.update) && (_swiper === null || _swiper === void 0 ? void 0 : _swiper.update());
	    }, 100);
	    return style;
	};
	const paijitexts = [
	    '施主※陳碧吟',
	    '施主※甯耀南',
	    '施主※葉雅柏',
	    '施主※李玉媚'
	];
	const isSidePaiji = ()=>{
	    const m = sideWidth().match(/width:(\d+)/);
	    const sidepaiji = m && m[1] && parseInt(m[1]) > 20;
	    return sidepaiji;
	};
	const favortypes = [
	    '♡',
	    '🤍',
	    '❤️',
	    '💚',
	    '💙',
	    '💜',
	    '🖤'
	];
	const shareAddress = (addr)=>{
	    if (!addr) addr = makeAddressFromFolioPos(get_store_value(tapmark));
	    return location.origin + location.pathname + '#' + addr;
	};
	const addTofind = (tf)=>{
	    tf = tf.trim().slice(0, 20);
	    if (!tf) return;
	    let arr = get_store_value(tofindhistory);
	    if (arr[0] == tf) return;
	    arr = removeTofind(tf);
	    arr.unshift(tf);
	    while(arr.length > 10)arr.pop();
	    tofindhistory.set(arr.slice(0, arr.length));
	};
	const removeTofind = (tf)=>{
	    const arr = get_store_value(tofindhistory);
	    const at = arr.indexOf(tf);
	    if (~at) {
	        arr.splice(at, 1);
	        tofindhistory.set(arr.slice(0, arr.length));
	    }
	    return arr;
	};

	const url2folioid = (url)=>url.slice(url.indexOf('folio/') + 6).replace('.zip', '');
	const fetchFolioList = async (store)=>{
	    const cache = await caches.open(CacheName);
	    const keys = await cache.keys();
	    const out = keys.filter((it)=>it.url.endsWith('.zip') && ~it.url.indexOf('folio/')).map((it)=>url2folioid(it.url));
	    if (store) {
	        const cached = {};
	        for(let i = 0; i < out.length; i++){
	            cached[out[i]] = true;
	        }
	        store.set(cached);
	    } else {
	        return out;
	    }
	};
	const ptkInCache$1 = async ()=>{
	    const cache = await caches.open(CacheName);
	    const keys = await cache.keys();
	    const out = keys.filter((it)=>~it.url.indexOf('.ptk')).map((it)=>it.url.match(/([a-z\-_]+)\.ptk/)[1]);
	    return out;
	};
	const getTocItems = (ptk, folioid, loading)=>{
	    if (loading) return [];
	    const out = [];
	    const bk = bookByFolio(folioid);
	    const bookaddr = 'bk#' + bk;
	    const [from, to] = ptk.rangeOfAddress(bookaddr);
	    const ck = ptk.defines.ck;
	    const at = bsearchNumber(ck.linepos, from);
	    const at2 = bsearchNumber(ck.linepos, to);
	    for(let i = at; i < at2; i++){
	        out.push({
	            caption: ck._innertext.get(i),
	            at: i,
	            id: ck.fields.id.values[i]
	        });
	    }
	    return out;
	};
	const getAllFolio = (ptk, folioid)=>{
	    const out = [];
	    const bk = bookByFolio(folioid);
	    const bookaddr = 'bk#' + bk;
	    const [from, to] = ptk.rangeOfAddress(bookaddr);
	    const folio = ptk.defines.folio;
	    const at = bsearchNumber(folio.linepos, from);
	    const at2 = bsearchNumber(folio.linepos, to);
	    for(let i = at; i < at2; i++){
	        out.push(folio.fields.id.values[i]);
	    }
	    return out;
	};

	const CURSORMARK = '◆';
	const goPb = (pbid, ck)=>{
	    activepb.set(pbid);
	    if (ck) {
	        const ft = get_store_value(foliotext);
	        const [pbid, cx, cy] = ft.toFolioPos(ck);
	        tapmark.set([
	            pbid,
	            cx,
	            cy
	        ]);
	        updateUrl(tapAddress());
	    }
	};
	const goPbAt = async (ptk, at)=>{
	    const ck = ptk.defines.ck;
	    const pb = ptk.defines.pb;
	    const ckline = ck.linepos[at];
	    const pbtag = ptk.nearestTag(ckline + 1, 'pb');
	    const pbid = pb.fields.id.values[pbtag];
	    goPb(pbid, ck.fields.id.values[at]);
	};
	const loadFolio = (folioid, func)=>{
	    let timer = 0;
	    // console.log('loading folio',folioid)
	    if (folioid == get_store_value(activefolioid)) func && func(folioid);
	    else {
	        stopAudio();
	        audioid.set('');
	        loadingfolio.set(true);
	        loadingzip.set(true);
	        activefolioid.set(folioid);
	        timer = setInterval(()=>{
	            if (!get_store_value(loadingzip)) {
	                clearInterval(timer);
	                setTimeout(()=>{
	                    func && func(folioid);
	                    loadingfolio.set(false);
	                    updateUrl(tapAddress());
	                    setTimeout(()=>{
	                        fetchFolioList(folioincache); //update cache
	                    }, 100);
	                }, 100);
	            }
	        }, 30);
	    }
	};
	const allJuan = (ptk, folioid)=>{
	    folioid = folioid || get_store_value(activefolioid);
	    const arrfolioid = ptk.defines.folio.fields.id.values;
	    const m = folioid.match(/([a-z\_]+)(\d+$)/);
	    const juans = [];
	    if (!m) return [];
	    for(let i = 0; i < arrfolioid.length; i++){
	        if (arrfolioid[i].startsWith(m[1])) {
	            const j = arrfolioid[i].slice(m[1].length);
	            if (parseInt(j)) juans.push(j);
	        }
	    }
	    return juans;
	};
	const markChunk = (ckid)=>{
	    const fpos = get_store_value(foliotext).toFolioPos(ckid);
	    activepb.set(fpos[0]);
	    tapmark.set(fpos);
	};
	const goChunk = (ptk, bkid, ckid, direction = 0)=>{
	    const ft = get_store_value(foliotext);
	    if (direction !== 0) {
	        const ck = ptk.defines.ck;
	        const [bkstart, bkend] = ptk.rangeOfAddress('bk#' + bkid);
	        const [start, end] = ptk.rangeOfAddress('bk#' + bkid + '.ck#' + ckid);
	        const newck = ptk.nearestChunk(start + 1);
	        const newat = newck.at + direction;
	        const linepos = ck.linepos[newat];
	        if (linepos < bkend && linepos >= bkstart) {
	            ckid = ck.fields.id.values[newat];
	        }
	    }
	    const at = ft.chunks.indexOf(ckid);
	    if (at == -1) {
	        const folioid = folioByChunk(ptk, get_store_value(activefolioid), ckid);
	        loadFolio(folioid, ()=>markChunk(ckid));
	    } else {
	        markChunk(ckid);
	    }
	};
	const folioByChunk = (ptk, folioid, ckid)=>{
	    const [start] = ptk.rangeOfAddress('bk#' + bookByFolio(folioid) + '.ck#' + ckid);
	    const newfolioid = ptk.nearestTag(start + 1, 'folio', 'id');
	    return newfolioid;
	};
	const folioPosFromPtkLine = (ptk, line)=>{
	    const folio = ptk.defines.folio;
	    const ck = ptk.defines.ck;
	    const folioat = bsearchNumber(folio.linepos, line + 1) - 1;
	    const ckat = bsearchNumber(ck.linepos, line + 1) - 1;
	    let folioid = '', ckid = '', lineoff = 0;
	    if (~folioat && folio.linepos[folioat + 1] > line) {
	        folioid = folio.fields.id.values[folioat];
	        ckid = ck.fields.id.values[ckat];
	        lineoff = line - ck.linepos[ckat];
	    }
	    return {
	        folioid,
	        ckid,
	        lineoff
	    };
	};
	const goPtkLine = (ptk, line, choff = 0)=>{
	    const { folioid, ckid, lineoff } = folioPosFromPtkLine(ptk, line);
	    loadFolio(folioid, ()=>{
	        const foliopos = get_store_value(foliotext).toFolioPos(ckid, lineoff, choff);
	        tapmark.set(foliopos);
	        activepb.set(foliopos[0]);
	    });
	};
	const loadAddress = async (address)=>{
	    if (!address) return;
	    const allptks = poolGetAll();
	    let addr = {};
	    for(let i = 0; i < allptks.length; i++){
	        const ptk = allptks[i];
	        if (!ptk || !ptk.defines.folio) continue;
	        addr = await folioPosFromAddress(ptk, address);
	        if (addr.id) {
	            if (!get_store_value(foliotext)) {
	                const ftext = new FolioText(ptk); //fetchFolioText(ptk,$activefolioid);
	                await ftext.load(addr.id);
	                foliotext.set(ftext);
	                addr = await folioPosFromAddress(ptk, address);
	            }
	            if (get_store_value(activePtk) !== ptk.name) {
	                activePtk.set(ptk.name);
	            }
	            break;
	        }
	    }
	    if (addr.id) {
	        activefolioid.set(addr.id);
	        const { pb, line, ch } = addr;
	        activepb.set(pb);
	        tapmark.set([
	            pb,
	            line,
	            ch
	        ]);
	    }
	};

	const file$N = "src\\transcriptlayer.svelte";
	function get_each_context$m(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[16] = list[i];
	    child_ctx[18] = i;
	    return child_ctx;
	}
	// (133:0) {#if $playing && findByAudioId($audioid) }
	function create_if_block$p(ctx) {
	    let previous_key = /*$activepb*/ (ctx[3], /*$audioid*/ ctx[1]);
	    let key_block_anchor;
	    let key_block = create_key_block$b(ctx);
	    const block = {
	        c: function create() {
	            key_block.c();
	            key_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            key_block.m(target, anchor);
	            insert_dev(target, key_block_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*$activepb, $audioid*/ 10 && safe_not_equal(previous_key, previous_key = /*$activepb*/ (ctx[3], /*$audioid*/ ctx[1]))) {
	                key_block.d(1);
	                key_block = create_key_block$b(ctx);
	                key_block.c();
	                key_block.m(key_block_anchor.parentNode, key_block_anchor);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(key_block_anchor);
	            }
	            key_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$p.name,
	        type: "if",
	        source: "(133:0) {#if $playing && findByAudioId($audioid) }",
	        ctx
	    });
	    return block;
	}
	// (136:4) {#each strips as strip,idx}
	function create_each_block$m(ctx) {
	    let div;
	    const block = {
	        c: function create() {
	            div = element("div");
	            attr_dev(div, "class", "strip");
	            attr_dev(div, "id", 'strip' + /*idx*/ ctx[18]);
	            attr_dev(div, "style", /*stripstyle*/ ctx[5](/*idx*/ ctx[18], /*strip*/ ctx[16]));
	            add_location(div, file$N, 136, 8, 4653);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	        },
	        p: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$m.name,
	        type: "each",
	        source: "(136:4) {#each strips as strip,idx}",
	        ctx
	    });
	    return block;
	}
	// (134:0) {#key $activepb,$audioid}
	function create_key_block$b(ctx) {
	    let div;
	    let div_style_value;
	    let each_value = ensure_array_like_dev(/*strips*/ ctx[4]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            div = element("div");
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            attr_dev(div, "class", "transcript");
	            attr_dev(div, "style", div_style_value = stylestring(/*frame*/ ctx[0]));
	            add_location(div, file$N, 134, 0, 4560);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div, null);
	                }
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*stripstyle, strips*/ 48) {
	                each_value = ensure_array_like_dev(/*strips*/ ctx[4]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$m(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$m(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div, null);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	            if (dirty & /*frame*/ 1 && div_style_value !== (div_style_value = stylestring(/*frame*/ ctx[0]))) {
	                attr_dev(div, "style", div_style_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$b.name,
	        type: "key",
	        source: "(134:0) {#key $activepb,$audioid}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$P(ctx) {
	    let show_if = /*$playing*/ ctx[2] && findByAudioId(/*$audioid*/ ctx[1]);
	    let if_block_anchor;
	    let if_block = show_if && create_if_block$p(ctx);
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*$playing, $audioid*/ 6) show_if = /*$playing*/ ctx[2] && findByAudioId(/*$audioid*/ ctx[1]);
	            if (show_if) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block$p(ctx);
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$P.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$P($$self, $$props, $$invalidate) {
	    let $audioid;
	    let $mediaurls;
	    let $playnextjuan;
	    let $activefolioid;
	    let $playing;
	    let $activepb;
	    validate_store(audioid, 'audioid');
	    component_subscribe($$self, audioid, ($$value)=>$$invalidate(1, $audioid = $$value));
	    validate_store(mediaurls, 'mediaurls');
	    component_subscribe($$self, mediaurls, ($$value)=>$$invalidate(10, $mediaurls = $$value));
	    validate_store(playnextjuan, 'playnextjuan');
	    component_subscribe($$self, playnextjuan, ($$value)=>$$invalidate(11, $playnextjuan = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(12, $activefolioid = $$value));
	    validate_store(playing, 'playing');
	    component_subscribe($$self, playing, ($$value)=>$$invalidate(2, $playing = $$value));
	    validate_store(activepb, 'activepb');
	    component_subscribe($$self, activepb, ($$value)=>$$invalidate(3, $activepb = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Transcriptlayer', slots, []);
	    let { frame = {}, totalpages } = $$props;
	    let { foliopage = [] } = $$props;
	    let { ptk } = $$props;
	    const strips = new Array(folioLines());
	    const timers = [];
	    onDestroy(()=>{
	        destroyTimer();
	    });
	    const rollback = ()=>{
	        continueplay.set(false);
	        activepb.set('1');
	        let r = get_store_value(remainrollback);
	        if (r > 0) {
	            r--;
	            remainrollback.set(r);
	        }
	        if (r == 0) stopAudio();
	    };
	    const playnext = ()=>{
	        const juans = allJuan(ptk);
	        const folioid = $activefolioid;
	        const vid = $audioid;
	        //get the media index in this juan
	        const thisaudiolist = $mediaurls;
	        let performer = '';
	        for(let i = 0; i < thisaudiolist.length; i++){
	            if (thisaudiolist[i].vid == vid) performer = thisaudiolist[i].performer;
	        }
	        if ($playnextjuan == 'on' && juans.length > 1) {
	            const juannow = folioid.match(/(\d+)$/)[1];
	            if (parseInt(juannow) == juans.length) {
	                rollback();
	            } else {
	                const nextfolioid = folioid.replace(juannow, parseInt(juannow) + 1);
	                // console.log('loading next juan',nextfolioid)
	                loadFolio(nextfolioid, function() {
	                    const audiolist = $mediaurls;
	                    // console.log('audiolist',audiolist,nextfolioid)
	                    if (audiolist) {
	                        const sameperformer = audiolist.filter((it)=>it.performer == performer);
	                        const vid = sameperformer.length ? sameperformer[0].vid : audiolist[0].vid;
	                        selectmedia(vid);
	                    }
	                });
	            }
	        } else {
	            rollback();
	        }
	    };
	    const stripstyle = (i, strip)=>{
	        if (i == 0) {
	            destroyTimer();
	        }
	        //duplicate repaint after continueplay is on
	        let fl = folioLines();
	        let fc = get_store_value(folioChars);
	        const w = frame.width / fl;
	        let out = [];
	        out.push('position:absolute');
	        out.push('left:' + Math.floor((fl - i - 1) * w) + 'px');
	        out.push('top:0px');
	        out.push('width:' + Math.floor(w) + 'px');
	        out.push('height:0px');
	        const { timestamp } = findByAudioId($audioid);
	        if (!timestamp) {
	            return out.join(';'); //cannot play
	        }
	        const line = (parseInt(get_store_value(activepb)) - 1) * fl;
	        if (!timestamp[line] && i == 0) {
	            //read the end
	            playnext();
	        }
	        const playertime = player === null || player === void 0 ? void 0 : player.currentTime;
	        let timedelta = playertime - timestamp[line] / 100; //player 跑得比較快。（因換頁動畫時間），需修正
	        if (Math.abs(timedelta) > 3) {
	            //不會差這麼多，是快速滑輪造成。getCurrentTime 未切到
	            timedelta = 0.02;
	        }
	        if (i == 0) {
	            //翻頁timer
	            const lastlinet = timestamp[line + fl] / 100 || timestamp[timestamp.length - 1] / 100;
	            const nextpagetime = (lastlinet - timestamp[line] / 100 - timedelta) * 1000;
	            timers.push(setTimeout(()=>{
	                if (parseInt(get_store_value(activepb)) < totalpages) {
	                    continueplay.set(true); //auto swipe , do not trigger 
	                    activepb.set((parseInt(get_store_value(activepb)) + 1).toString());
	                    setTimeout(()=>{
	                        continueplay.set(false); // user swipe manually
	                    }, 500);
	                } else {
	                    playnext();
	                }
	            }, nextpagetime));
	        }
	        let delay = (timestamp[line + i] / 100 - timestamp[line] / 100 - timedelta) * 1000;
	        if (i == 0 && delay < 30) delay = 30; // too small value  cause immediate trigger fire
	        // console.log(i,'delay',delay)
	        const fire = (function() {
	            if (this.folio != get_store_value(activepb)) return;
	            // console.log('fire',this.idx, 'folio',this.folio, 'activepb',get(activepb))
	            const ele = document.getElementById('strip' + this.idx);
	            if (!ele) return;
	            const chcount = get_store_value(foliotext).countFolioChar(foliopage[i] || '');
	            ele.style.height = Math.floor(chcount * (frame.height / fc)) + 'px';
	        }).bind({
	            idx: i,
	            folio: get_store_value(activepb)
	        });
	        timers.push(setTimeout(fire, delay));
	        let duration = timestamp[line + i + 1] / 100 - timestamp[line + i] / 100;
	        if (duration == 0 && i + 1 < fl) {
	            //empty line , try next line
	            duration = timestamp[line + i + 2] / 100 - timestamp[line + i] / 100;
	        }
	        out.push('transition:height ' + duration + 's  linear'); //
	        return out.join(';');
	    };
	    const destroyTimer = ()=>{
	        timers.forEach((it)=>clearTimeout(it));
	        timers.length = 0;
	    };
	    $$self.$$.on_mount.push(function() {
	        if (totalpages === undefined && !('totalpages' in $$props || $$self.$$.bound[$$self.$$.props['totalpages']])) {
	            console.warn("<Transcriptlayer> was created without expected prop 'totalpages'");
	        }
	        if (ptk === undefined && !('ptk' in $$props || $$self.$$.bound[$$self.$$.props['ptk']])) {
	            console.warn("<Transcriptlayer> was created without expected prop 'ptk'");
	        }
	    });
	    const writable_props = [
	        'frame',
	        'totalpages',
	        'foliopage',
	        'ptk'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Transcriptlayer> was created with unknown prop '${key}'`);
	    });
	    $$self.$$set = ($$props)=>{
	        if ('frame' in $$props) $$invalidate(0, frame = $$props.frame);
	        if ('totalpages' in $$props) $$invalidate(6, totalpages = $$props.totalpages);
	        if ('foliopage' in $$props) $$invalidate(7, foliopage = $$props.foliopage);
	        if ('ptk' in $$props) $$invalidate(8, ptk = $$props.ptk);
	    };
	    $$self.$capture_state = ()=>({
	            stylestring,
	            activepb,
	            audioid,
	            folioLines,
	            foliotext,
	            folioChars,
	            playing,
	            selectmedia,
	            mediaurls,
	            stopAudio,
	            remainrollback,
	            player,
	            continueplay,
	            findByAudioId,
	            playnextjuan,
	            activefolioid,
	            get: get_store_value,
	            onDestroy,
	            allJuan,
	            loadFolio,
	            frame,
	            totalpages,
	            foliopage,
	            ptk,
	            strips,
	            timers,
	            rollback,
	            playnext,
	            stripstyle,
	            destroyTimer,
	            $audioid,
	            $mediaurls,
	            $playnextjuan,
	            $activefolioid,
	            $playing,
	            $activepb
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('frame' in $$props) $$invalidate(0, frame = $$props.frame);
	        if ('totalpages' in $$props) $$invalidate(6, totalpages = $$props.totalpages);
	        if ('foliopage' in $$props) $$invalidate(7, foliopage = $$props.foliopage);
	        if ('ptk' in $$props) $$invalidate(8, ptk = $$props.ptk);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        frame,
	        $audioid,
	        $playing,
	        $activepb,
	        strips,
	        stripstyle,
	        totalpages,
	        foliopage,
	        ptk
	    ];
	}
	class Transcriptlayer extends SvelteComponentDev {
	    get frame() {
	        throw new Error("<Transcriptlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set frame(value) {
	        throw new Error("<Transcriptlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get totalpages() {
	        throw new Error("<Transcriptlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set totalpages(value) {
	        throw new Error("<Transcriptlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get foliopage() {
	        throw new Error("<Transcriptlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set foliopage(value) {
	        throw new Error("<Transcriptlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get ptk() {
	        throw new Error("<Transcriptlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set ptk(value) {
	        throw new Error("<Transcriptlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$P, create_fragment$P, safe_not_equal, {
	            frame: 0,
	            totalpages: 6,
	            foliopage: 7,
	            ptk: 8
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Transcriptlayer",
	            options,
	            id: create_fragment$P.name
	        });
	    }
	}

	const file$M = "src\\punclayer.svelte";
	function get_each_context$l(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[9] = list[i];
	    return child_ctx;
	}
	// (48:0) {#each puncs as punc}
	function create_each_block$l(ctx) {
	    let span;
	    let t_value = /*formatPuncText*/ ctx[2](/*punc*/ ctx[9].text) + "";
	    let t;
	    let span_style_value;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "class", "punc");
	            attr_dev(span, "style", span_style_value = /*puncStyle*/ ctx[3](/*punc*/ ctx[9].line, /*punc*/ ctx[9].ch, /*punc*/ ctx[9].text));
	            add_location(span, file$M, 48, 0, 1501);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*puncs*/ 2 && t_value !== (t_value = /*formatPuncText*/ ctx[2](/*punc*/ ctx[9].text) + "")) set_data_dev(t, t_value);
	            if (dirty & /*puncs*/ 2 && span_style_value !== (span_style_value = /*puncStyle*/ ctx[3](/*punc*/ ctx[9].line, /*punc*/ ctx[9].ch, /*punc*/ ctx[9].text))) {
	                attr_dev(span, "style", span_style_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$l.name,
	        type: "each",
	        source: "(48:0) {#each puncs as punc}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$O(ctx) {
	    let div;
	    let div_style_value;
	    let each_value = ensure_array_like_dev(/*puncs*/ ctx[1]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            div = element("div");
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            attr_dev(div, "class", "puncs");
	            attr_dev(div, "style", div_style_value = stylestring(/*frame*/ ctx[0]));
	            add_location(div, file$M, 46, 0, 1431);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div, null);
	                }
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*puncStyle, puncs, formatPuncText*/ 14) {
	                each_value = ensure_array_like_dev(/*puncs*/ ctx[1]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$l(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$l(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div, null);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	            if (dirty & /*frame*/ 1 && div_style_value !== (div_style_value = stylestring(/*frame*/ ctx[0]))) {
	                attr_dev(div, "style", div_style_value);
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$O.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$O($$self, $$props, $$invalidate) {
	    let $folioChars;
	    validate_store(folioChars, 'folioChars');
	    component_subscribe($$self, folioChars, ($$value)=>$$invalidate(4, $folioChars = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Punclayer', slots, []);
	    let { frame = {} } = $$props;
	    let { puncs = [] } = $$props;
	    const fl = folioLines(), fc = $folioChars;
	    const unitw = frame.width / fl, unith = frame.height / fc;
	    const formatPuncText = (text)=>{
	        if (isPunc(text[0])) {
	            return text;
	        } else if (text[0] == 'n') {
	            return text.slice(1);
	        }
	        return text;
	    };
	    const puncStyle = (line, ch, text)=>{
	        let fontsize = unith * 0.9, yinc = unith * 0.2, xinc = -unitw * 0.1, extrastyle = '';
	        if (text == '？' || text == '！') {
	            fontsize = fontsize / 1.5;
	            yinc += unith * 0.4;
	        } else if (text == '﹁' || text == '﹃') {
	            xinc += -unitw * 0.3;
	            yinc += unith * 0.40;
	        } else if (text == '﹄' || text == '﹂') {
	            xinc += -unitw * 0.6;
	            yinc += unith * 0.4;
	        } else if (!isPunc(text[0])) {
	            //ck marker or n marker
	            if (text[0] == 'n') {
	                //經號
	                xinc -= unitw * 0.5;
	                extrastyle = 'background:var(--n)';
	                text = text.slice(1);
	                yinc += unith;
	            } else {
	                yinc += unith;
	            }
	            fontsize = fontsize / 1.5;
	        }
	        const style = 'left:' + Math.floor(xinc + unitw * (fl - line) - unitw * 0.25) + 'px; top:' + Math.floor(yinc + unith * (ch - 1) - unith * 0.2) + 'px;font-size:' + fontsize + 'px;' + extrastyle;
	        return style;
	    };
	    const writable_props = [
	        'frame',
	        'puncs'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Punclayer> was created with unknown prop '${key}'`);
	    });
	    $$self.$$set = ($$props)=>{
	        if ('frame' in $$props) $$invalidate(0, frame = $$props.frame);
	        if ('puncs' in $$props) $$invalidate(1, puncs = $$props.puncs);
	    };
	    $$self.$capture_state = ()=>({
	            text,
	            frame,
	            puncs,
	            folioChars,
	            folioLines,
	            stylestring,
	            fl,
	            fc,
	            unitw,
	            unith,
	            isPunc,
	            formatPuncText,
	            puncStyle,
	            $folioChars
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('frame' in $$props) $$invalidate(0, frame = $$props.frame);
	        if ('puncs' in $$props) $$invalidate(1, puncs = $$props.puncs);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        frame,
	        puncs,
	        formatPuncText,
	        puncStyle
	    ];
	}
	class Punclayer extends SvelteComponentDev {
	    get frame() {
	        throw new Error("<Punclayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set frame(value) {
	        throw new Error("<Punclayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get puncs() {
	        throw new Error("<Punclayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set puncs(value) {
	        throw new Error("<Punclayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$O, create_fragment$O, safe_not_equal, {
	            frame: 0,
	            puncs: 1
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Punclayer",
	            options,
	            id: create_fragment$O.name
	        });
	    }
	}

	const file$L = "src\\tapmark.svelte";
	function create_fragment$N(ctx) {
	    let span;
	    const block = {
	        c: function create() {
	            span = element("span");
	            attr_dev(span, "class", "punc");
	            attr_dev(span, "style", /*styleString*/ ctx[0]());
	            add_location(span, file$L, 14, 0, 488);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	        },
	        p: noop,
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$N.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$N($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Tapmark', slots, []);
	    let { mark = [], frame, pb = '' } = $$props;
	    let { folioChars = 17, folioLines = 5 } = $$props;
	    const unitw = frame.width / folioLines, unith = frame.height / folioChars;
	    //assuming frame.left ==0
	    const styleString = ()=>{
	        const [pbmark, line, ch] = mark;
	        if (pb != pbmark) return '';
	        return 'left:' + Math.floor(unitw * (folioLines - line - 1)) + 'px; top:' + +Math.floor(frame.top + unith * ch) + 'px;width:' + unitw + 'px;height:' + unith + 'px;background:var(--pinmark);border-radius:5px;pointer-events:none';
	    };
	    $$self.$$.on_mount.push(function() {
	        if (frame === undefined && !('frame' in $$props || $$self.$$.bound[$$self.$$.props['frame']])) {
	            console.warn("<Tapmark> was created without expected prop 'frame'");
	        }
	    });
	    const writable_props = [
	        'mark',
	        'frame',
	        'pb',
	        'folioChars',
	        'folioLines'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tapmark> was created with unknown prop '${key}'`);
	    });
	    $$self.$$set = ($$props)=>{
	        if ('mark' in $$props) $$invalidate(1, mark = $$props.mark);
	        if ('frame' in $$props) $$invalidate(2, frame = $$props.frame);
	        if ('pb' in $$props) $$invalidate(3, pb = $$props.pb);
	        if ('folioChars' in $$props) $$invalidate(4, folioChars = $$props.folioChars);
	        if ('folioLines' in $$props) $$invalidate(5, folioLines = $$props.folioLines);
	    };
	    $$self.$capture_state = ()=>({
	            mark,
	            frame,
	            pb,
	            folioChars,
	            folioLines,
	            unitw,
	            unith,
	            styleString
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('mark' in $$props) $$invalidate(1, mark = $$props.mark);
	        if ('frame' in $$props) $$invalidate(2, frame = $$props.frame);
	        if ('pb' in $$props) $$invalidate(3, pb = $$props.pb);
	        if ('folioChars' in $$props) $$invalidate(4, folioChars = $$props.folioChars);
	        if ('folioLines' in $$props) $$invalidate(5, folioLines = $$props.folioLines);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        styleString,
	        mark,
	        frame,
	        pb,
	        folioChars,
	        folioLines
	    ];
	}
	class Tapmark extends SvelteComponentDev {
	    get mark() {
	        throw new Error("<Tapmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set mark(value) {
	        throw new Error("<Tapmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get frame() {
	        throw new Error("<Tapmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set frame(value) {
	        throw new Error("<Tapmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get pb() {
	        throw new Error("<Tapmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set pb(value) {
	        throw new Error("<Tapmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get folioChars() {
	        throw new Error("<Tapmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set folioChars(value) {
	        throw new Error("<Tapmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get folioLines() {
	        throw new Error("<Tapmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set folioLines(value) {
	        throw new Error("<Tapmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$N, create_fragment$N, safe_not_equal, {
	            mark: 1,
	            frame: 2,
	            pb: 3,
	            folioChars: 4,
	            folioLines: 5
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Tapmark",
	            options,
	            id: create_fragment$N.name
	        });
	    }
	}

	const file$K = "src\\3rd\\swipe.svelte";
	function get_each_context$k(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[49] = list[i];
	    child_ctx[51] = i;
	    return child_ctx;
	}
	// (326:2) {#if showIndicators}
	function create_if_block$o(ctx) {
	    let div;
	    let each_value = ensure_array_like_dev(/*indicators*/ ctx[2]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            div = element("div");
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            attr_dev(div, "class", "swipe-indicator swipe-indicator-inside svelte-17g4ceu");
	            add_location(div, file$K, 326, 4, 8604);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div, null);
	                }
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*activeIndicator, changeItem, indicators*/ 38) {
	                each_value = ensure_array_like_dev(/*indicators*/ ctx[2]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$k(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$k(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div, null);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$o.name,
	        type: "if",
	        source: "(326:2) {#if showIndicators}",
	        ctx
	    });
	    return block;
	}
	// (328:6) {#each indicators as x, i}
	function create_each_block$k(ctx) {
	    let span;
	    let span_class_value;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[23](/*i*/ ctx[51]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", span_class_value = "dot " + /*activeIndicator*/ (ctx[1] == /*i*/ ctx[51] ? 'is-active' : '') + " svelte-17g4ceu");
	            add_location(span, file$K, 328, 8, 8698);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty[0] & /*activeIndicator*/ 2 && span_class_value !== (span_class_value = "dot " + /*activeIndicator*/ (ctx[1] == /*i*/ ctx[51] ? 'is-active' : '') + " svelte-17g4ceu")) {
	                attr_dev(span, "class", span_class_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$k.name,
	        type: "each",
	        source: "(328:6) {#each indicators as x, i}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$M(ctx) {
	    let div4;
	    let div2;
	    let div1;
	    let div0;
	    let t0;
	    let div3;
	    let t1;
	    let current;
	    let mounted;
	    let dispose;
	    const default_slot_template = /*#slots*/ ctx[21].default;
	    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
	    let if_block = /*showIndicators*/ ctx[0] && create_if_block$o(ctx);
	    const block = {
	        c: function create() {
	            div4 = element("div");
	            div2 = element("div");
	            div1 = element("div");
	            div0 = element("div");
	            if (default_slot) default_slot.c();
	            t0 = space();
	            div3 = element("div");
	            t1 = space();
	            if (if_block) if_block.c();
	            attr_dev(div0, "class", "swipeable-slot-wrapper svelte-17g4ceu");
	            add_location(div0, file$K, 319, 6, 8384);
	            attr_dev(div1, "class", "swipeable-total_elements svelte-17g4ceu");
	            add_location(div1, file$K, 318, 4, 8339);
	            attr_dev(div2, "class", "swipe-item-wrapper svelte-17g4ceu");
	            add_location(div2, file$K, 317, 2, 8277);
	            attr_dev(div3, "aria-hidden", "true");
	            attr_dev(div3, "class", "swipe-handler svelte-17g4ceu");
	            add_location(div3, file$K, 324, 2, 8473);
	            attr_dev(div4, "class", "swipe-panel svelte-17g4ceu");
	            add_location(div4, file$K, 316, 0, 8249);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div4, anchor);
	            append_dev(div4, div2);
	            append_dev(div2, div1);
	            append_dev(div1, div0);
	            if (default_slot) {
	                default_slot.m(div0, null);
	            }
	            /*div2_binding*/ ctx[22](div2);
	            append_dev(div4, t0);
	            append_dev(div4, div3);
	            append_dev(div4, t1);
	            if (if_block) if_block.m(div4, null);
	            current = true;
	            if (!mounted) {
	                dispose = [
	                    listen_dev(div3, "touchstart", /*onMoveStart*/ ctx[4], false, false, false, false),
	                    listen_dev(div3, "mousedown", /*onMoveStart*/ ctx[4], false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (default_slot) {
	                if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
	                    update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[20]) : get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null), null);
	                }
	            }
	            if (/*showIndicators*/ ctx[0]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block$o(ctx);
	                    if_block.c();
	                    if_block.m(div4, null);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(default_slot, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(default_slot, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div4);
	            }
	            if (default_slot) default_slot.d(detaching);
	            /*div2_binding*/ ctx[22](null);
	            if (if_block) if_block.d();
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$M.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$M($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Swipe', slots, [
	        'default'
	    ]);
	    let { transitionDuration = 200 } = $$props;
	    let { showIndicators = false } = $$props;
	    let { autoplay = false } = $$props;
	    let { delay = 1000 } = $$props;
	    let { defaultIndex = 0 } = $$props;
	    let { active_item = 0 } = $$props;
	    let { is_vertical = false } = $$props;
	    let { allow_infinite_swipe = false } = $$props;
	    let activeIndicator = 0, indicators, total_elements = 0, availableSpace = 0, availableMeasure = 0, swipeElements, availableDistance = 0, swipeItemsWrapper, swipeWrapper, pos_axis = 0, page_axis = is_vertical ? 'pageY' : 'pageX', axis, longTouch, last_axis_pos;
	    let played;
	    let run_interval = false;
	    let fire = createEventDispatcher();
	    let movingcount = 0;
	    function init() {
	        swipeItemsWrapper = swipeWrapper.querySelector('.swipeable-slot-wrapper');
	        swipeElements = swipeItemsWrapper.querySelectorAll('.swipeable-item');
	        $$invalidate(18, total_elements = swipeElements.length);
	        if (allow_infinite_swipe) {
	            swipeItemsWrapper.prepend(swipeElements[total_elements - 1].cloneNode(true));
	            swipeItemsWrapper.append(swipeElements[0].cloneNode(true));
	            swipeElements = swipeItemsWrapper.querySelectorAll('.swipeable-item');
	        }
	        update();
	    }
	    function update() {
	        let { offsetWidth, offsetHeight } = swipeWrapper.querySelector('.swipeable-total_elements');
	        availableSpace = is_vertical ? offsetHeight : offsetWidth;
	        setElementsPosition({
	            init: true,
	            elems: [
	                ...swipeElements
	            ],
	            availableSpace,
	            has_infinite_loop: allow_infinite_swipe
	        });
	        availableDistance = 0;
	        availableMeasure = availableSpace * (total_elements - 1);
	        if (defaultIndex) {
	            changeItem(defaultIndex);
	        }
	    }
	    // helpers
	    function setElementsPosition({ elems = [], availableSpace = 0, pos_axis = 0, has_infinite_loop = false, distance = 0, moving = false, init = false, end = false, reset = false }) {
	        elems.forEach((element, i)=>{
	            let idx = has_infinite_loop ? i - 1 : i;
	            if (init) {
	                element.style.transform = generateTranslateValue(availableSpace * idx);
	            }
	            if (moving) {
	                element.style.cssText = generateTouchPosCss(availableSpace * idx - distance);
	            }
	            if (end) {
	                element.style.cssText = generateTouchPosCss(availableSpace * idx - pos_axis, true);
	            }
	            if (reset) {
	                element.style.cssText = generateTouchPosCss(availableSpace * idx - pos_axis);
	            }
	        });
	    }
	    function eventDelegate(type) {
	        let delegationTypes = {
	            add: 'addEventListener',
	            remove: 'removeEventListener'
	        };
	        if (typeof window !== 'undefined') {
	            window[delegationTypes[type]]('mousemove', onMove);
	            window[delegationTypes[type]]('mouseup', onEnd);
	            window[delegationTypes[type]]('touchmove', onMove, {
	                passive: false
	            });
	            window[delegationTypes[type]]('touchend', onEnd, {
	                passive: false
	            });
	        }
	    }
	    function generateTranslateValue(value) {
	        return is_vertical ? `translate3d(0, ${value}px, 0)` : `translate3d(${value}px, 0, 0)`;
	    }
	    function generateTouchPosCss(value, touch_end = false) {
	        let transformString = generateTranslateValue(value);
	        let _css = `
-webkit-transition-duration: ${touch_end ? transitionDuration : '0'}ms;
transition-duration: ${touch_end ? transitionDuration : '0'}ms;
-webkit-transform: ${transformString};
-ms-transform: ${transformString};`;
	        return _css;
	    }
	    onMount(()=>{
	        init();
	        if (typeof window !== 'undefined') {
	            window.addEventListener('resize', update);
	        }
	    });
	    onDestroy(()=>{
	        if (typeof window !== 'undefined') {
	            window.removeEventListener('resize', update);
	        }
	    });
	    let touch_active = false;
	    function onMove(e) {
	        if (touch_active) {
	            movingcount++;
	            e.stopImmediatePropagation();
	            e.stopPropagation();
	            let _axis = e.touches ? e.touches[0][page_axis] : e[page_axis], distance = axis - _axis + pos_axis;
	            if (!allow_infinite_swipe) {
	                if (pos_axis == 0 && axis < _axis || pos_axis == availableMeasure && axis > _axis) {
	                    return;
	                }
	            }
	            e.preventDefault();
	            setElementsPosition({
	                moving: true,
	                elems: [
	                    ...swipeElements
	                ],
	                availableSpace,
	                distance,
	                has_infinite_loop: allow_infinite_swipe
	            });
	            availableDistance = distance;
	            last_axis_pos = _axis;
	        }
	    }
	    let startx, starty;
	    function onMoveStart(e) {
	        // e.preventDefault();
	        fire('start');
	        movingcount = 0;
	        e.stopImmediatePropagation();
	        e.stopPropagation();
	        touch_active = true;
	        longTouch = false;
	        setTimeout(function() {
	            longTouch = true;
	        }, 250);
	        axis = e.touches ? e.touches[0][page_axis] : e[page_axis];
	        if (e.touches) {
	            startx = e.touches[0].pageX;
	            starty = e.touches[0].pageY;
	        } else {
	            startx = e.clientX;
	            starty = e.clientY;
	        }
	        eventDelegate('add');
	    }
	    function onEnd(e) {
	        if (e && e.cancelable) {
	            e.preventDefault();
	        }
	        e && e.stopImmediatePropagation();
	        e && e.stopPropagation();
	        let direction = axis < last_axis_pos;
	        touch_active = false;
	        let _as = availableSpace;
	        let accidental_touch = Math.round(availableSpace / 50) > Math.abs(axis - last_axis_pos);
	        if (longTouch || accidental_touch) {
	            availableDistance = Math.round(availableDistance / _as) * _as;
	        } else {
	            availableDistance = direction ? Math.floor(availableDistance / _as) * _as : Math.ceil(availableDistance / _as) * _as;
	        }
	        axis = null;
	        last_axis_pos = null;
	        pos_axis = availableDistance;
	        $$invalidate(1, activeIndicator = availableDistance / _as);
	        $$invalidate(7, active_item = activeIndicator);
	        $$invalidate(6, defaultIndex = active_item);
	        setElementsPosition({
	            end: true,
	            elems: [
	                ...swipeElements
	            ],
	            availableSpace: _as,
	            pos_axis,
	            has_infinite_loop: allow_infinite_swipe
	        });
	        if (allow_infinite_swipe) {
	            if (active_item === -1) {
	                pos_axis = _as * (total_elements - 1);
	            }
	            if (active_item === total_elements) {
	                pos_axis = 0;
	            }
	            $$invalidate(1, activeIndicator = pos_axis / _as);
	            $$invalidate(7, active_item = activeIndicator);
	            $$invalidate(6, defaultIndex = active_item);
	            setTimeout(()=>{
	                setElementsPosition({
	                    reset: true,
	                    elems: [
	                        ...swipeElements
	                    ],
	                    availableSpace: _as,
	                    pos_axis,
	                    has_infinite_loop: allow_infinite_swipe
	                });
	            }, transitionDuration);
	        }
	        eventDelegate('remove');
	        let swipe_direction = direction ? 'right' : 'left';
	        let x, y;
	        if (e === null || e === void 0 ? void 0 : e.changedTouches) {
	            x = e.changedTouches[0].pageX;
	            y = e.changedTouches[0].pageY;
	        } else {
	            x = e === null || e === void 0 ? void 0 : e.clientX;
	            y = e === null || e === void 0 ? void 0 : e.clientY;
	        }
	        if (Math.abs(startx - x) < 3 && Math.abs(starty - y) < 3 && movingcount < 3) {
	            fire('click', {
	                x,
	                y
	            });
	        } else {
	            setTimeout(()=>{
	                fire('change', {
	                    active_item,
	                    swipe_direction,
	                    active_element: swipeElements[active_item]
	                });
	            }, transitionDuration);
	        }
	    }
	    function changeItem(item) {
	        let max = availableSpace;
	        availableDistance = max * item;
	        $$invalidate(1, activeIndicator = item);
	        onEnd();
	    }
	    function changeView() {
	        changeItem(played);
	        played = played < total_elements - 1 + allow_infinite_swipe ? ++played : 0;
	    }
	    const mod = (n, m)=>(n % m + m) % m;
	    function goLast() {
	        goTo(total_elements - 1);
	    }
	    function goTo(step) {
	        let item = allow_infinite_swipe ? step : Math.max(0, Math.min(step, indicators.length - 1));
	        changeItem(item);
	    }
	    function prevItem() {
	        let step = activeIndicator - 1;
	        goTo(step);
	    }
	    function nextItem() {
	        let step = activeIndicator + 1;
	        goTo(step);
	    }
	    const writable_props = [
	        'transitionDuration',
	        'showIndicators',
	        'autoplay',
	        'delay',
	        'defaultIndex',
	        'active_item',
	        'is_vertical',
	        'allow_infinite_swipe'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Swipe> was created with unknown prop '${key}'`);
	    });
	    function div2_binding($$value) {
	        binding_callbacks[$$value ? 'unshift' : 'push'](()=>{
	            swipeWrapper = $$value;
	            $$invalidate(3, swipeWrapper);
	        });
	    }
	    const click_handler = (i)=>{
	        changeItem(i);
	    };
	    $$self.$$set = ($$props)=>{
	        if ('transitionDuration' in $$props) $$invalidate(8, transitionDuration = $$props.transitionDuration);
	        if ('showIndicators' in $$props) $$invalidate(0, showIndicators = $$props.showIndicators);
	        if ('autoplay' in $$props) $$invalidate(9, autoplay = $$props.autoplay);
	        if ('delay' in $$props) $$invalidate(10, delay = $$props.delay);
	        if ('defaultIndex' in $$props) $$invalidate(6, defaultIndex = $$props.defaultIndex);
	        if ('active_item' in $$props) $$invalidate(7, active_item = $$props.active_item);
	        if ('is_vertical' in $$props) $$invalidate(11, is_vertical = $$props.is_vertical);
	        if ('allow_infinite_swipe' in $$props) $$invalidate(12, allow_infinite_swipe = $$props.allow_infinite_swipe);
	        if ('$$scope' in $$props) $$invalidate(20, $$scope = $$props.$$scope);
	    };
	    $$self.$capture_state = ()=>({
	            onMount,
	            onDestroy,
	            createEventDispatcher,
	            transitionDuration,
	            showIndicators,
	            autoplay,
	            delay,
	            defaultIndex,
	            active_item,
	            is_vertical,
	            allow_infinite_swipe,
	            activeIndicator,
	            indicators,
	            total_elements,
	            availableSpace,
	            availableMeasure,
	            swipeElements,
	            availableDistance,
	            swipeItemsWrapper,
	            swipeWrapper,
	            pos_axis,
	            page_axis,
	            axis,
	            longTouch,
	            last_axis_pos,
	            played,
	            run_interval,
	            fire,
	            movingcount,
	            init,
	            update,
	            setElementsPosition,
	            eventDelegate,
	            generateTranslateValue,
	            generateTouchPosCss,
	            touch_active,
	            onMove,
	            startx,
	            starty,
	            onMoveStart,
	            onEnd,
	            changeItem,
	            changeView,
	            mod,
	            goLast,
	            goTo,
	            prevItem,
	            nextItem
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('transitionDuration' in $$props) $$invalidate(8, transitionDuration = $$props.transitionDuration);
	        if ('showIndicators' in $$props) $$invalidate(0, showIndicators = $$props.showIndicators);
	        if ('autoplay' in $$props) $$invalidate(9, autoplay = $$props.autoplay);
	        if ('delay' in $$props) $$invalidate(10, delay = $$props.delay);
	        if ('defaultIndex' in $$props) $$invalidate(6, defaultIndex = $$props.defaultIndex);
	        if ('active_item' in $$props) $$invalidate(7, active_item = $$props.active_item);
	        if ('is_vertical' in $$props) $$invalidate(11, is_vertical = $$props.is_vertical);
	        if ('allow_infinite_swipe' in $$props) $$invalidate(12, allow_infinite_swipe = $$props.allow_infinite_swipe);
	        if ('activeIndicator' in $$props) $$invalidate(1, activeIndicator = $$props.activeIndicator);
	        if ('indicators' in $$props) $$invalidate(2, indicators = $$props.indicators);
	        if ('total_elements' in $$props) $$invalidate(18, total_elements = $$props.total_elements);
	        if ('availableSpace' in $$props) availableSpace = $$props.availableSpace;
	        if ('availableMeasure' in $$props) availableMeasure = $$props.availableMeasure;
	        if ('swipeElements' in $$props) swipeElements = $$props.swipeElements;
	        if ('availableDistance' in $$props) availableDistance = $$props.availableDistance;
	        if ('swipeItemsWrapper' in $$props) swipeItemsWrapper = $$props.swipeItemsWrapper;
	        if ('swipeWrapper' in $$props) $$invalidate(3, swipeWrapper = $$props.swipeWrapper);
	        if ('pos_axis' in $$props) pos_axis = $$props.pos_axis;
	        if ('page_axis' in $$props) page_axis = $$props.page_axis;
	        if ('axis' in $$props) axis = $$props.axis;
	        if ('longTouch' in $$props) longTouch = $$props.longTouch;
	        if ('last_axis_pos' in $$props) last_axis_pos = $$props.last_axis_pos;
	        if ('played' in $$props) played = $$props.played;
	        if ('run_interval' in $$props) $$invalidate(19, run_interval = $$props.run_interval);
	        if ('fire' in $$props) fire = $$props.fire;
	        if ('movingcount' in $$props) movingcount = $$props.movingcount;
	        if ('touch_active' in $$props) touch_active = $$props.touch_active;
	        if ('startx' in $$props) startx = $$props.startx;
	        if ('starty' in $$props) starty = $$props.starty;
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty[0] & /*total_elements*/ 262144) {
	            $$invalidate(2, indicators = Array(total_elements));
	        }
	        if ($$self.$$.dirty[0] & /*autoplay, run_interval, defaultIndex, active_item, delay*/ 526016) {
	            {
	                if (autoplay && !run_interval) {
	                    played = defaultIndex || active_item;
	                    $$invalidate(19, run_interval = setInterval(changeView, delay));
	                }
	                if (!autoplay && run_interval) {
	                    clearInterval(run_interval);
	                    $$invalidate(19, run_interval = false);
	                }
	            }
	        }
	    };
	    return [
	        showIndicators,
	        activeIndicator,
	        indicators,
	        swipeWrapper,
	        onMoveStart,
	        changeItem,
	        defaultIndex,
	        active_item,
	        transitionDuration,
	        autoplay,
	        delay,
	        is_vertical,
	        allow_infinite_swipe,
	        update,
	        goLast,
	        goTo,
	        prevItem,
	        nextItem,
	        total_elements,
	        run_interval,
	        $$scope,
	        slots,
	        div2_binding,
	        click_handler
	    ];
	}
	class Swipe extends SvelteComponentDev {
	    get transitionDuration() {
	        throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set transitionDuration(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get showIndicators() {
	        throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set showIndicators(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get autoplay() {
	        throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set autoplay(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get delay() {
	        throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set delay(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get defaultIndex() {
	        throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set defaultIndex(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get active_item() {
	        throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set active_item(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get is_vertical() {
	        throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set is_vertical(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get allow_infinite_swipe() {
	        throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set allow_infinite_swipe(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get update() {
	        return this.$$.ctx[13];
	    }
	    set update(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get goLast() {
	        return this.$$.ctx[14];
	    }
	    set goLast(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get goTo() {
	        return this.$$.ctx[15];
	    }
	    set goTo(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get prevItem() {
	        return this.$$.ctx[16];
	    }
	    set prevItem(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get nextItem() {
	        return this.$$.ctx[17];
	    }
	    set nextItem(value) {
	        throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$M, create_fragment$M, safe_not_equal, {
	            transitionDuration: 8,
	            showIndicators: 0,
	            autoplay: 9,
	            delay: 10,
	            defaultIndex: 6,
	            active_item: 7,
	            is_vertical: 11,
	            allow_infinite_swipe: 12,
	            update: 13,
	            goLast: 14,
	            goTo: 15,
	            prevItem: 16,
	            nextItem: 17
	        }, null, [
	            -1,
	            -1
	        ]);
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Swipe",
	            options,
	            id: create_fragment$M.name
	        });
	    }
	}

	const file$J = "src\\3rd\\swipeitem.svelte";
	function create_fragment$L(ctx) {
	    let div1;
	    let div0;
	    let div1_class_value;
	    let div1_resize_listener;
	    let current;
	    const default_slot_template = /*#slots*/ ctx[6].default;
	    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	    const block = {
	        c: function create() {
	            div1 = element("div");
	            div0 = element("div");
	            if (default_slot) default_slot.c();
	            attr_dev(div0, "class", "swipeable-item-inner");
	            add_location(div0, file$J, 34, 2, 917);
	            attr_dev(div1, "class", div1_class_value = "swipeable-item " + /*classes*/ ctx[1] + " " + /*active*/ (ctx[0] ? 'is-active' : '') + "" + " svelte-13ik1fy");
	            attr_dev(div1, "style", /*style*/ ctx[2]);
	            add_render_callback(()=>/*div1_elementresize_handler*/ ctx[8].call(div1));
	            add_location(div1, file$J, 29, 0, 804);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div1, anchor);
	            append_dev(div1, div0);
	            if (default_slot) {
	                default_slot.m(div0, null);
	            }
	            /*div0_binding*/ ctx[7](div0);
	            div1_resize_listener = add_iframe_resize_listener(div1, /*div1_elementresize_handler*/ ctx[8].bind(div1));
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            if (default_slot) {
	                if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
	                    update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[5]) : get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null), null);
	                }
	            }
	            if (!current || dirty & /*classes, active*/ 3 && div1_class_value !== (div1_class_value = "swipeable-item " + /*classes*/ ctx[1] + " " + /*active*/ (ctx[0] ? 'is-active' : '') + "" + " svelte-13ik1fy")) {
	                attr_dev(div1, "class", div1_class_value);
	            }
	            if (!current || dirty & /*style*/ 4) {
	                attr_dev(div1, "style", /*style*/ ctx[2]);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(default_slot, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(default_slot, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div1);
	            }
	            if (default_slot) default_slot.d(detaching);
	            /*div0_binding*/ ctx[7](null);
	            div1_resize_listener();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$L.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$L($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Swipeitem', slots, [
	        'default'
	    ]);
	    let { active = false } = $$props;
	    let { classes = '' } = $$props;
	    let { style = '' } = $$props;
	    //export let allow_dynamic_height = false;
	    let swipeItemInner = null;
	    let _height = 0;
	    const writable_props = [
	        'active',
	        'classes',
	        'style'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Swipeitem> was created with unknown prop '${key}'`);
	    });
	    function div0_binding($$value) {
	        binding_callbacks[$$value ? 'unshift' : 'push'](()=>{
	            swipeItemInner = $$value;
	            $$invalidate(3, swipeItemInner);
	        });
	    }
	    function div1_elementresize_handler() {
	        _height = this.clientHeight;
	        $$invalidate(4, _height);
	    }
	    $$self.$$set = ($$props)=>{
	        if ('active' in $$props) $$invalidate(0, active = $$props.active);
	        if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
	        if ('style' in $$props) $$invalidate(2, style = $$props.style);
	        if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	    };
	    $$self.$capture_state = ()=>({
	            onMount,
	            createEventDispatcher,
	            active,
	            classes,
	            style,
	            swipeItemInner,
	            _height
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('active' in $$props) $$invalidate(0, active = $$props.active);
	        if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
	        if ('style' in $$props) $$invalidate(2, style = $$props.style);
	        if ('swipeItemInner' in $$props) $$invalidate(3, swipeItemInner = $$props.swipeItemInner);
	        if ('_height' in $$props) $$invalidate(4, _height = $$props._height);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        active,
	        classes,
	        style,
	        swipeItemInner,
	        _height,
	        $$scope,
	        slots,
	        div0_binding,
	        div1_elementresize_handler
	    ];
	}
	class Swipeitem extends SvelteComponentDev {
	    get active() {
	        throw new Error("<Swipeitem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set active(value) {
	        throw new Error("<Swipeitem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get classes() {
	        throw new Error("<Swipeitem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set classes(value) {
	        throw new Error("<Swipeitem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get style() {
	        throw new Error("<Swipeitem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set style(value) {
	        throw new Error("<Swipeitem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$L, create_fragment$L, safe_not_equal, {
	            active: 0,
	            classes: 1,
	            style: 2
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Swipeitem",
	            options,
	            id: create_fragment$L.name
	        });
	    }
	}

	function registerServiceWorker(swfn = "./sw.js") {
	    const localhost = isLocalhost();
	    const p = document.location.protocol;
	    if ("serviceWorker" in navigator && (localhost || p == 'https:')) {
	        navigator.serviceWorker.register(swfn);
	    }
	}
	function isLocalhost() {
	    const p = document.location.protocol;
	    const h = document.location.hostname;
	    return p == 'http:' && (h == '127.0.0.1' || h == 'localhost');
	}

	// Step 1: start the fetch and obtain a reader
	const isLatest = async (url, cacheName)=>{
	    if (!navigator.onLine && !isLocalhost()) return true;
	    const cachefn = url.replace(/\?.+/, '');
	    const fetchurl = cachefn + '?' + new Date().toISOString();
	    const ContentType = ~fetchurl.indexOf('.mp3') ? "audio/mpeg" : "application/octet-stream";
	    const headresponse = await fetch(fetchurl, {
	        method: "HEAD",
	        mode: "no-cors",
	        redirect: "follow",
	        credentials: "omit",
	        origin,
	        headers: {
	            Accept: ContentType
	        }
	    });
	    const cache = await caches.open(cacheName);
	    const cached = await cache.match(cachefn);
	    const contentlength = headresponse.headers.get('Content-Length');
	    const isLatest = cached && contentlength == cached.headers.get('Content-Length');
	    return isLatest;
	};
	const downloadToCache = async (cacheName, url, cb)=>{
	    const cachefn = url.replace(/\?.+/, ''); //remove tailing timestamp
	    // if (location.host!=='nissaya.cn' 
	    // && location.host.indexOf('localhost')==-1 
	    // && location.host.indexOf('127.0.0.1')==-1) url="https://nissaya.cn/"+url.replace(/^\//,'');
	    const ContentType = ~url.indexOf('.mp3') ? "audio/mpeg" : "application/octet-stream";
	    const origin1 = "https://nissaya.cn";
	    const cache = await caches.open(cacheName);
	    const cached = await cache.match(cachefn);
	    if (!navigator.onLine && !isLocalhost()) {
	        return cached || cache.match('/offline.html');
	    }
	    //once download , zip and mp3 need to manually delete
	    if (cached && cached.statusText == 'OK' && (url.endsWith(".zip") || url.endsWith(".mp3") || url.endsWith(".ptk"))) {
	        return cached;
	    }
	    //HEAD is slow occasionally, clear it manually if want to update
	    let headresponse = await fetch(url, {
	        method: "HEAD",
	        mode: "no-cors",
	        redirect: "follow",
	        credentials: "omit",
	        origin: origin1,
	        headers: {
	            Accept: ContentType
	        }
	    });
	    const lastmodified = headresponse.headers.get('Content-Length');
	    if (cached && lastmodified == cached.headers.get('Content-Length')) {
	        // console.log('use cached')
	        return cached;
	    }
	    cb && cb('requesting');
	    let response = await fetch(url, {
	        method: "GET",
	        mode: "no-cors",
	        redirect: "follow",
	        credentials: "omit",
	        origin: origin1,
	        headers: {
	            Accept: ContentType
	        }
	    });
	    cb && cb('responsed');
	    if (response.status >= 400) {
	        cb && cb(response.statusText);
	        return;
	    }
	    if (response.body) {
	        const reader = response.body.getReader();
	        // Step 2: get total length
	        const contentLength = +response.headers.get('Content-Length');
	        // Step 3: read the data
	        let receivedLength = 0; // received that many bytes at the moment
	        let chunks = []; // array of received binary chunks (comprises the body)
	        while(true){
	            const { done, value } = await reader.read();
	            if (done) break;
	            chunks.push(value);
	            receivedLength += value.length;
	            cb && cb(Math.floor(100 * receivedLength / contentLength) + '% / ' + humanBytes(contentLength));
	        // console.log(`Received ${receivedLength} of ${contentLength}`)
	        }
	        // Step 4: concatenate chunks into single Uint8Array
	        let chunksAll = new Uint8Array(receivedLength); // (4.1)
	        let position = 0;
	        for (let chunk of chunks){
	            chunksAll.set(chunk, position); // (4.2)
	            position += chunk.length;
	        }
	        //put to cache
	        const resp = {
	            status: response.status,
	            statusText: response.statusText,
	            headers: {
	                'X-Shaka-From-Cache': true,
	                "Content-Type": ContentType,
	                "Content-Length": contentLength
	            }
	        };
	        const res = new Response(chunksAll, resp);
	        cache.put(cachefn, res.clone());
	        cb && cb('cached');
	        return res;
	    } else {
	        cache.put(cachefn, response.clone());
	        cb && cb('cached');
	        return response;
	    }
	};
	const fileInCache = async (pat, cacheName, ext = '.ptk')=>{
	    const cache = await caches.open(cacheName);
	    const keys = await cache.keys();
	    const incaches = keys.filter((it)=>it.url.endsWith(ext)).map((it)=>it.url.match(pat)).filter((it)=>!!it).map((it)=>it[1]);
	    return unique(incaches);
	};
	const ptkInCache = async (cacheName)=>{
	    return await fileInCache(/([a-z_\-]+)\.ptk/, cacheName);
	};

	const file$I = "src\\downloadstatus.svelte";
	function create_fragment$K(ctx) {
	    let div;
	    let t;
	    const block = {
	        c: function create() {
	            div = element("div");
	            t = text(/*msg*/ ctx[0]);
	            attr_dev(div, "class", "downloading bodytext");
	            add_location(div, file$I, 3, 0, 38);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, t);
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*msg*/ 1) set_data_dev(t, /*msg*/ ctx[0]);
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$K.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$K($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Downloadstatus', slots, []);
	    let { msg = '' } = $$props;
	    const writable_props = [
	        'msg'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Downloadstatus> was created with unknown prop '${key}'`);
	    });
	    $$self.$$set = ($$props)=>{
	        if ('msg' in $$props) $$invalidate(0, msg = $$props.msg);
	    };
	    $$self.$capture_state = ()=>({
	            msg
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('msg' in $$props) $$invalidate(0, msg = $$props.msg);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        msg
	    ];
	}
	class Downloadstatus extends SvelteComponentDev {
	    get msg() {
	        throw new Error("<Downloadstatus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set msg(value) {
	        throw new Error("<Downloadstatus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$K, create_fragment$K, safe_not_equal, {
	            msg: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Downloadstatus",
	            options,
	            id: create_fragment$K.name
	        });
	    }
	}

	const { Object: Object_1$1 } = globals;
	const file$H = "src\\swipezipimage.svelte";
	// (311:0) {:else}
	function create_else_block$b(ctx) {
	    let downloadstatus;
	    let current;
	    downloadstatus = new Downloadstatus({
	        props: {
	            msg: /*$downloading*/ ctx[20]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(downloadstatus.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(downloadstatus, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const downloadstatus_changes = {};
	            if (dirty[0] & /*$downloading*/ 1048576) downloadstatus_changes.msg = /*$downloading*/ ctx[20];
	            downloadstatus.$set(downloadstatus_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(downloadstatus.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(downloadstatus.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(downloadstatus, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$b.name,
	        type: "else",
	        source: "(311:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (302:0) {#if ready}
	function create_if_block_6$4(ctx) {
	    let div;
	    let swipe;
	    let div_style_value;
	    let current;
	    let mounted;
	    let dispose;
	    const swipe_spread_levels = [
	        /*swipeConfig*/ ctx[25],
	        {
	            defaultIndex: /*defaultIndex*/ ctx[8]
	        }
	    ];
	    let swipe_props = {
	        $$slots: {
	            default: [
	                create_default_slot$8
	            ]
	        },
	        $$scope: {
	            ctx
	        }
	    };
	    for(let i = 0; i < swipe_spread_levels.length; i += 1){
	        swipe_props = assign(swipe_props, swipe_spread_levels[i]);
	    }
	    swipe = new Swipe({
	        props: swipe_props,
	        $$inline: true
	    });
	    /*swipe_binding*/ ctx[36](swipe);
	    swipe.$on("click", /*onfoliopageclick*/ ctx[29]);
	    swipe.$on("start", /*swipeStart*/ ctx[26]);
	    swipe.$on("change", /*swipeChanged*/ ctx[27]);
	    const block = {
	        c: function create() {
	            div = element("div");
	            create_component(swipe.$$.fragment);
	            attr_dev(div, "aria-hidden", "true");
	            attr_dev(div, "class", "swipe-holder svelte-u4lgbo");
	            attr_dev(div, "style", div_style_value = "opacity:" + /*$leftmode*/ (ctx[18] !== 'folio' ? '0;' : '1') + ";width:" + folioHolderWidth(/*$landscape*/ ctx[19], 1, /*swiper*/ ctx[7]));
	            add_location(div, file$H, 302, 0, 9102);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            mount_component(swipe, div, null);
	            current = true;
	            if (!mounted) {
	                dispose = listen_dev(div, "wheel", /*mousewheel*/ ctx[28], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            const swipe_changes = dirty[0] & /*swipeConfig, defaultIndex*/ 33554688 ? get_spread_update(swipe_spread_levels, [
	                dirty[0] & /*swipeConfig*/ 33554432 && get_spread_object(/*swipeConfig*/ ctx[25]),
	                dirty[0] & /*defaultIndex*/ 256 && {
	                    defaultIndex: /*defaultIndex*/ ctx[8]
	                }
	            ]) : {};
	            if (dirty[1] & /*$$scope*/ 1048576) {
	                swipe_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            swipe.$set(swipe_changes);
	            if (!current || dirty[0] & /*$leftmode, $landscape, swiper*/ 786560 && div_style_value !== (div_style_value = "opacity:" + /*$leftmode*/ (ctx[18] !== 'folio' ? '0;' : '1') + ";width:" + folioHolderWidth(/*$landscape*/ ctx[19], 1, /*swiper*/ ctx[7]))) {
	                attr_dev(div, "style", div_style_value);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(swipe.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(swipe.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            /*swipe_binding*/ ctx[36](null);
	            destroy_component(swipe);
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_6$4.name,
	        type: "if",
	        source: "(302:0) {#if ready}",
	        ctx
	    });
	    return block;
	}
	// (306:1) <SwipeItem>
	function create_default_slot_3(ctx) {
	    let img;
	    let img_src_value;
	    const block = {
	        c: function create() {
	            img = element("img");
	            if (!src_url_equal(img.src, img_src_value = blankimage)) attr_dev(img, "src", img_src_value);
	            attr_dev(img, "alt", "no");
	            attr_dev(img, "class", "leftimage swipe svelte-u4lgbo");
	            add_location(img, file$H, 305, 12, 9417);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, img, anchor);
	        },
	        p: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(img);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot_3.name,
	        type: "slot",
	        source: "(306:1) <SwipeItem>",
	        ctx
	    });
	    return block;
	}
	// (307:1) <SwipeItem>
	function create_default_slot_2$2(ctx) {
	    let img;
	    let img_src_value;
	    const block = {
	        c: function create() {
	            img = element("img");
	            if (!src_url_equal(img.src, img_src_value = blankimage)) attr_dev(img, "src", img_src_value);
	            attr_dev(img, "alt", "no");
	            attr_dev(img, "class", "middleimage swipe svelte-u4lgbo");
	            add_location(img, file$H, 306, 12, 9498);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, img, anchor);
	        },
	        p: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(img);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot_2$2.name,
	        type: "slot",
	        source: "(307:1) <SwipeItem>",
	        ctx
	    });
	    return block;
	}
	// (308:1) <SwipeItem>
	function create_default_slot_1$2(ctx) {
	    let img;
	    let img_src_value;
	    const block = {
	        c: function create() {
	            img = element("img");
	            if (!src_url_equal(img.src, img_src_value = blankimage)) attr_dev(img, "src", img_src_value);
	            attr_dev(img, "alt", "no");
	            attr_dev(img, "class", "rightimage swipe svelte-u4lgbo");
	            add_location(img, file$H, 307, 12, 9581);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, img, anchor);
	        },
	        p: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(img);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot_1$2.name,
	        type: "slot",
	        source: "(308:1) <SwipeItem>",
	        ctx
	    });
	    return block;
	}
	// (304:0) <Swipe bind:this={swiper} {...swipeConfig} {defaultIndex}   on:click={onfoliopageclick} on:start={swipeStart} on:change={swipeChanged}>
	function create_default_slot$8(ctx) {
	    let swipeitem0;
	    let t0;
	    let swipeitem1;
	    let t1;
	    let swipeitem2;
	    let current;
	    swipeitem0 = new Swipeitem({
	        props: {
	            $$slots: {
	                default: [
	                    create_default_slot_3
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    swipeitem1 = new Swipeitem({
	        props: {
	            $$slots: {
	                default: [
	                    create_default_slot_2$2
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    swipeitem2 = new Swipeitem({
	        props: {
	            $$slots: {
	                default: [
	                    create_default_slot_1$2
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(swipeitem0.$$.fragment);
	            t0 = space();
	            create_component(swipeitem1.$$.fragment);
	            t1 = space();
	            create_component(swipeitem2.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(swipeitem0, target, anchor);
	            insert_dev(target, t0, anchor);
	            mount_component(swipeitem1, target, anchor);
	            insert_dev(target, t1, anchor);
	            mount_component(swipeitem2, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const swipeitem0_changes = {};
	            if (dirty[1] & /*$$scope*/ 1048576) {
	                swipeitem0_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            swipeitem0.$set(swipeitem0_changes);
	            const swipeitem1_changes = {};
	            if (dirty[1] & /*$$scope*/ 1048576) {
	                swipeitem1_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            swipeitem1.$set(swipeitem1_changes);
	            const swipeitem2_changes = {};
	            if (dirty[1] & /*$$scope*/ 1048576) {
	                swipeitem2_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            swipeitem2.$set(swipeitem2_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(swipeitem0.$$.fragment, local);
	            transition_in(swipeitem1.$$.fragment, local);
	            transition_in(swipeitem2.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(swipeitem0.$$.fragment, local);
	            transition_out(swipeitem1.$$.fragment, local);
	            transition_out(swipeitem2.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	            }
	            destroy_component(swipeitem0, detaching);
	            destroy_component(swipeitem1, detaching);
	            destroy_component(swipeitem2, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot$8.name,
	        type: "slot",
	        source: "(304:0) <Swipe bind:this={swiper} {...swipeConfig} {defaultIndex}   on:click={onfoliopageclick} on:start={swipeStart} on:change={swipeChanged}>",
	        ctx
	    });
	    return block;
	}
	// (314:0) {#if !$landscape && totalpages-defaultIndex>1}
	function create_if_block_5$5(ctx) {
	    let previous_key = /*favoritetimer*/ ctx[10];
	    let key_block_anchor;
	    let key_block = create_key_block_2$1(ctx);
	    const block = {
	        c: function create() {
	            key_block.c();
	            key_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            key_block.m(target, anchor);
	            insert_dev(target, key_block_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*favoritetimer*/ 1024 && safe_not_equal(previous_key, previous_key = /*favoritetimer*/ ctx[10])) {
	                key_block.d(1);
	                key_block = create_key_block_2$1(ctx);
	                key_block.c();
	                key_block.m(key_block_anchor.parentNode, key_block_anchor);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(key_block_anchor);
	            }
	            key_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_5$5.name,
	        type: "if",
	        source: "(314:0) {#if !$landscape && totalpages-defaultIndex>1}",
	        ctx
	    });
	    return block;
	}
	// (315:0) {#key favoritetimer}
	function create_key_block_2$1(ctx) {
	    var /*$favorites*/ _ctx__ctx_;
	    let span;
	    let t_value = favortypes[((_ctx__ctx_ = ctx[14][/*$activefolioid*/ ctx[13]]) === null || _ctx__ctx_ === void 0 ? void 0 : _ctx__ctx_[/*$activepb*/ ctx[2]]) || 0] + "";
	    let t;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "favoritebtn");
	            toggle_class(span, "blinkfavorbtn", !!/*favoritetimer*/ ctx[10]);
	            add_location(span, file$H, 315, 0, 9786);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*favoritebtn*/ ctx[30], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            var /*$favorites*/ _ctx__ctx_;
	            if (dirty[0] & /*$favorites, $activefolioid, $activepb*/ 24580 && t_value !== (t_value = favortypes[((_ctx__ctx_ = ctx[14][/*$activefolioid*/ ctx[13]]) === null || _ctx__ctx_ === void 0 ? void 0 : _ctx__ctx_[/*$activepb*/ ctx[2]]) || 0] + "")) set_data_dev(t, t_value);
	            if (dirty[0] & /*favoritetimer*/ 1024) {
	                toggle_class(span, "blinkfavorbtn", !!/*favoritetimer*/ ctx[10]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block_2$1.name,
	        type: "key",
	        source: "(315:0) {#key favoritetimer}",
	        ctx
	    });
	    return block;
	}
	// (319:0) {#if !$landscape  && $mediaurls.filter(it=>it.incache).length}
	function create_if_block_4$6(ctx) {
	    let span;
	    let t_value = /*$audioid*/ (ctx[21] ? '◼' : '♫') + "";
	    let t;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "playbtn");
	            add_location(span, file$H, 319, 0, 10033);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*toggleplaybtn*/ ctx[31], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*$audioid*/ 2097152 && t_value !== (t_value = /*$audioid*/ (ctx[21] ? '◼' : '♫') + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_4$6.name,
	        type: "if",
	        source: "(319:0) {#if !$landscape  && $mediaurls.filter(it=>it.incache).length}",
	        ctx
	    });
	    return block;
	}
	// (324:0) {#if $playing}
	function create_if_block_3$6(ctx) {
	    let span;
	    let t_value = /*$remainrollback*/ (ctx[23] > 0 ? /*$remainrollback*/ ctx[23] : '') + "";
	    let t;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "class", "remainrollback");
	            add_location(span, file$H, 324, 0, 10194);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*$remainrollback*/ 8388608 && t_value !== (t_value = /*$remainrollback*/ (ctx[23] > 0 ? /*$remainrollback*/ ctx[23] : '') + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_3$6.name,
	        type: "if",
	        source: "(324:0) {#if $playing}",
	        ctx
	    });
	    return block;
	}
	// (329:0) {#if ready&&!hidepunc && !$showpaiji && $leftmode=='folio'}
	function create_if_block_2$8(ctx) {
	    let tapmark_1;
	    let current;
	    tapmark_1 = new Tapmark({
	        props: {
	            mark: /*$tapmark*/ ctx[15],
	            pb: /*$activepb*/ ctx[2],
	            folioChars: /*$folioChars*/ ctx[17],
	            folioLines: folioLines(),
	            frame: /*imageFrame*/ ctx[11]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(tapmark_1.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(tapmark_1, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const tapmark_1_changes = {};
	            if (dirty[0] & /*$tapmark*/ 32768) tapmark_1_changes.mark = /*$tapmark*/ ctx[15];
	            if (dirty[0] & /*$activepb*/ 4) tapmark_1_changes.pb = /*$activepb*/ ctx[2];
	            if (dirty[0] & /*$folioChars*/ 131072) tapmark_1_changes.folioChars = /*$folioChars*/ ctx[17];
	            if (dirty[0] & /*imageFrame*/ 2048) tapmark_1_changes.frame = /*imageFrame*/ ctx[11];
	            tapmark_1.$set(tapmark_1_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(tapmark_1.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(tapmark_1.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(tapmark_1, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_2$8.name,
	        type: "if",
	        source: "(329:0) {#if ready&&!hidepunc && !$showpaiji && $leftmode=='folio'}",
	        ctx
	    });
	    return block;
	}
	// (328:0) {#key $tapmark+$activepb}
	function create_key_block_1$1(ctx) {
	    let if_block_anchor;
	    let current;
	    let if_block = /*ready*/ ctx[5] && !/*hidepunc*/ ctx[6] && !/*$showpaiji*/ ctx[16] && /*$leftmode*/ ctx[18] == 'folio' && create_if_block_2$8(ctx);
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (/*ready*/ ctx[5] && !/*hidepunc*/ ctx[6] && !/*$showpaiji*/ ctx[16] && /*$leftmode*/ ctx[18] == 'folio') {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                    if (dirty[0] & /*ready, hidepunc, $showpaiji, $leftmode*/ 327776) {
	                        transition_in(if_block, 1);
	                    }
	                } else {
	                    if_block = create_if_block_2$8(ctx);
	                    if_block.c();
	                    transition_in(if_block, 1);
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                group_outros();
	                transition_out(if_block, 1, 1, ()=>{
	                    if_block = null;
	                });
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block_1$1.name,
	        type: "key",
	        source: "(328:0) {#key $tapmark+$activepb}",
	        ctx
	    });
	    return block;
	}
	// (336:0) {#if !hidepunc}
	function create_if_block$n(ctx) {
	    let t;
	    let transcriptlayer;
	    let current;
	    let if_block = /*$showpunc*/ ctx[24] == 'on' && /*$leftmode*/ ctx[18] == 'folio' && create_if_block_1$e(ctx);
	    transcriptlayer = new Transcriptlayer({
	        props: {
	            frame: /*imageFrame*/ ctx[11],
	            totalpages: /*totalpages*/ ctx[0],
	            ptk: /*ptk*/ ctx[1],
	            foliopage: /*foliopage*/ ctx[3]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            t = space();
	            create_component(transcriptlayer.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, t, anchor);
	            mount_component(transcriptlayer, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (/*$showpunc*/ ctx[24] == 'on' && /*$leftmode*/ ctx[18] == 'folio') {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                    if (dirty[0] & /*$showpunc, $leftmode*/ 17039360) {
	                        transition_in(if_block, 1);
	                    }
	                } else {
	                    if_block = create_if_block_1$e(ctx);
	                    if_block.c();
	                    transition_in(if_block, 1);
	                    if_block.m(t.parentNode, t);
	                }
	            } else if (if_block) {
	                group_outros();
	                transition_out(if_block, 1, 1, ()=>{
	                    if_block = null;
	                });
	                check_outros();
	            }
	            const transcriptlayer_changes = {};
	            if (dirty[0] & /*imageFrame*/ 2048) transcriptlayer_changes.frame = /*imageFrame*/ ctx[11];
	            if (dirty[0] & /*totalpages*/ 1) transcriptlayer_changes.totalpages = /*totalpages*/ ctx[0];
	            if (dirty[0] & /*ptk*/ 2) transcriptlayer_changes.ptk = /*ptk*/ ctx[1];
	            if (dirty[0] & /*foliopage*/ 8) transcriptlayer_changes.foliopage = /*foliopage*/ ctx[3];
	            transcriptlayer.$set(transcriptlayer_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            transition_in(transcriptlayer.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            transition_out(transcriptlayer.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	            if (if_block) if_block.d(detaching);
	            destroy_component(transcriptlayer, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$n.name,
	        type: "if",
	        source: "(336:0) {#if !hidepunc}",
	        ctx
	    });
	    return block;
	}
	// (337:0) {#if $showpunc=='on'&& $leftmode=='folio'}
	function create_if_block_1$e(ctx) {
	    let punclayer;
	    let current;
	    punclayer = new Punclayer({
	        props: {
	            frame: /*imageFrame*/ ctx[11],
	            puncs: /*puncs*/ ctx[4]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(punclayer.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(punclayer, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const punclayer_changes = {};
	            if (dirty[0] & /*imageFrame*/ 2048) punclayer_changes.frame = /*imageFrame*/ ctx[11];
	            if (dirty[0] & /*puncs*/ 16) punclayer_changes.puncs = /*puncs*/ ctx[4];
	            punclayer.$set(punclayer_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(punclayer.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(punclayer.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(punclayer, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$e.name,
	        type: "if",
	        source: "(337:0) {#if $showpunc=='on'&& $leftmode=='folio'}",
	        ctx
	    });
	    return block;
	}
	// (335:0) {#key puncs}
	function create_key_block$a(ctx) {
	    let if_block_anchor;
	    let current;
	    let if_block = !/*hidepunc*/ ctx[6] && create_if_block$n(ctx);
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (!/*hidepunc*/ ctx[6]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                    if (dirty[0] & /*hidepunc*/ 64) {
	                        transition_in(if_block, 1);
	                    }
	                } else {
	                    if_block = create_if_block$n(ctx);
	                    if_block.c();
	                    transition_in(if_block, 1);
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                group_outros();
	                transition_out(if_block, 1, 1, ()=>{
	                    if_block = null;
	                });
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$a.name,
	        type: "key",
	        source: "(335:0) {#key puncs}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$J(ctx) {
	    let current_block_type_index;
	    let if_block0;
	    let t0;
	    let t1;
	    let show_if = !/*$landscape*/ ctx[19] && /*$mediaurls*/ ctx[12].filter(func).length;
	    let t2;
	    let span;
	    let t3_value = /*imageIndex*/ ctx[9] + 1 + "";
	    let t3;
	    let t4;
	    let t5;
	    let previous_key = /*$tapmark*/ ctx[15] + /*$activepb*/ ctx[2];
	    let t6;
	    let previous_key_1 = /*puncs*/ ctx[4];
	    let key_block1_anchor;
	    let current;
	    const if_block_creators = [
	        create_if_block_6$4,
	        create_else_block$b
	    ];
	    const if_blocks = [];
	    function select_block_type(ctx, dirty) {
	        if (/*ready*/ ctx[5]) return 0;
	        return 1;
	    }
	    current_block_type_index = select_block_type(ctx);
	    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    let if_block1 = !/*$landscape*/ ctx[19] && /*totalpages*/ ctx[0] - /*defaultIndex*/ ctx[8] > 1 && create_if_block_5$5(ctx);
	    let if_block2 = show_if && create_if_block_4$6(ctx);
	    let if_block3 = /*$playing*/ ctx[22] && create_if_block_3$6(ctx);
	    let key_block0 = create_key_block_1$1(ctx);
	    let key_block1 = create_key_block$a(ctx);
	    const block = {
	        c: function create() {
	            if_block0.c();
	            t0 = space();
	            if (if_block1) if_block1.c();
	            t1 = space();
	            if (if_block2) if_block2.c();
	            t2 = space();
	            span = element("span");
	            t3 = text(t3_value);
	            t4 = space();
	            if (if_block3) if_block3.c();
	            t5 = space();
	            key_block0.c();
	            t6 = space();
	            key_block1.c();
	            key_block1_anchor = empty();
	            attr_dev(span, "class", "pagenumber");
	            add_location(span, file$H, 322, 0, 10132);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            if_blocks[current_block_type_index].m(target, anchor);
	            insert_dev(target, t0, anchor);
	            if (if_block1) if_block1.m(target, anchor);
	            insert_dev(target, t1, anchor);
	            if (if_block2) if_block2.m(target, anchor);
	            insert_dev(target, t2, anchor);
	            insert_dev(target, span, anchor);
	            append_dev(span, t3);
	            insert_dev(target, t4, anchor);
	            if (if_block3) if_block3.m(target, anchor);
	            insert_dev(target, t5, anchor);
	            key_block0.m(target, anchor);
	            insert_dev(target, t6, anchor);
	            key_block1.m(target, anchor);
	            insert_dev(target, key_block1_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            let previous_block_index = current_block_type_index;
	            current_block_type_index = select_block_type(ctx);
	            if (current_block_type_index === previous_block_index) {
	                if_blocks[current_block_type_index].p(ctx, dirty);
	            } else {
	                group_outros();
	                transition_out(if_blocks[previous_block_index], 1, 1, ()=>{
	                    if_blocks[previous_block_index] = null;
	                });
	                check_outros();
	                if_block0 = if_blocks[current_block_type_index];
	                if (!if_block0) {
	                    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	                    if_block0.c();
	                } else {
	                    if_block0.p(ctx, dirty);
	                }
	                transition_in(if_block0, 1);
	                if_block0.m(t0.parentNode, t0);
	            }
	            if (!/*$landscape*/ ctx[19] && /*totalpages*/ ctx[0] - /*defaultIndex*/ ctx[8] > 1) {
	                if (if_block1) {
	                    if_block1.p(ctx, dirty);
	                } else {
	                    if_block1 = create_if_block_5$5(ctx);
	                    if_block1.c();
	                    if_block1.m(t1.parentNode, t1);
	                }
	            } else if (if_block1) {
	                if_block1.d(1);
	                if_block1 = null;
	            }
	            if (dirty[0] & /*$landscape, $mediaurls*/ 528384) show_if = !/*$landscape*/ ctx[19] && /*$mediaurls*/ ctx[12].filter(func).length;
	            if (show_if) {
	                if (if_block2) {
	                    if_block2.p(ctx, dirty);
	                } else {
	                    if_block2 = create_if_block_4$6(ctx);
	                    if_block2.c();
	                    if_block2.m(t2.parentNode, t2);
	                }
	            } else if (if_block2) {
	                if_block2.d(1);
	                if_block2 = null;
	            }
	            if ((!current || dirty[0] & /*imageIndex*/ 512) && t3_value !== (t3_value = /*imageIndex*/ ctx[9] + 1 + "")) set_data_dev(t3, t3_value);
	            if (/*$playing*/ ctx[22]) {
	                if (if_block3) {
	                    if_block3.p(ctx, dirty);
	                } else {
	                    if_block3 = create_if_block_3$6(ctx);
	                    if_block3.c();
	                    if_block3.m(t5.parentNode, t5);
	                }
	            } else if (if_block3) {
	                if_block3.d(1);
	                if_block3 = null;
	            }
	            if (dirty[0] & /*$tapmark, $activepb*/ 32772 && safe_not_equal(previous_key, previous_key = /*$tapmark*/ ctx[15] + /*$activepb*/ ctx[2])) {
	                group_outros();
	                transition_out(key_block0, 1, 1, noop);
	                check_outros();
	                key_block0 = create_key_block_1$1(ctx);
	                key_block0.c();
	                transition_in(key_block0, 1);
	                key_block0.m(t6.parentNode, t6);
	            } else {
	                key_block0.p(ctx, dirty);
	            }
	            if (dirty[0] & /*puncs*/ 16 && safe_not_equal(previous_key_1, previous_key_1 = /*puncs*/ ctx[4])) {
	                group_outros();
	                transition_out(key_block1, 1, 1, noop);
	                check_outros();
	                key_block1 = create_key_block$a(ctx);
	                key_block1.c();
	                transition_in(key_block1, 1);
	                key_block1.m(key_block1_anchor.parentNode, key_block1_anchor);
	            } else {
	                key_block1.p(ctx, dirty);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block0);
	            transition_in(key_block0);
	            transition_in(key_block1);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block0);
	            transition_out(key_block0);
	            transition_out(key_block1);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(t2);
	                detach_dev(span);
	                detach_dev(t4);
	                detach_dev(t5);
	                detach_dev(t6);
	                detach_dev(key_block1_anchor);
	            }
	            if_blocks[current_block_type_index].d(detaching);
	            if (if_block1) if_block1.d(detaching);
	            if (if_block2) if_block2.d(detaching);
	            if (if_block3) if_block3.d(detaching);
	            key_block0.d(detaching);
	            key_block1.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$J.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	const blankimage = 'frames/blank.png';
	const func = (it)=>it.incache;
	function instance$J($$self, $$props, $$invalidate) {
	    let ptk;
	    let $activepb;
	    let $mediaurls;
	    let $activefolioid;
	    let $preferaudio;
	    let $favorites;
	    let $activePtk;
	    let $tapmark;
	    let $showpaiji;
	    let $folioChars;
	    let $leftmode;
	    let $thezip;
	    let $showyoutube;
	    let $landscape;
	    let $downloading;
	    let $audioid;
	    let $playing;
	    let $remainrollback;
	    let $showpunc;
	    validate_store(activepb, 'activepb');
	    component_subscribe($$self, activepb, ($$value)=>$$invalidate(2, $activepb = $$value));
	    validate_store(mediaurls, 'mediaurls');
	    component_subscribe($$self, mediaurls, ($$value)=>$$invalidate(12, $mediaurls = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(13, $activefolioid = $$value));
	    validate_store(preferaudio, 'preferaudio');
	    component_subscribe($$self, preferaudio, ($$value)=>$$invalidate(39, $preferaudio = $$value));
	    validate_store(favorites, 'favorites');
	    component_subscribe($$self, favorites, ($$value)=>$$invalidate(14, $favorites = $$value));
	    validate_store(activePtk, 'activePtk');
	    component_subscribe($$self, activePtk, ($$value)=>$$invalidate(35, $activePtk = $$value));
	    validate_store(tapmark, 'tapmark');
	    component_subscribe($$self, tapmark, ($$value)=>$$invalidate(15, $tapmark = $$value));
	    validate_store(showpaiji, 'showpaiji');
	    component_subscribe($$self, showpaiji, ($$value)=>$$invalidate(16, $showpaiji = $$value));
	    validate_store(folioChars, 'folioChars');
	    component_subscribe($$self, folioChars, ($$value)=>$$invalidate(17, $folioChars = $$value));
	    validate_store(leftmode, 'leftmode');
	    component_subscribe($$self, leftmode, ($$value)=>$$invalidate(18, $leftmode = $$value));
	    validate_store(thezip, 'thezip');
	    component_subscribe($$self, thezip, ($$value)=>$$invalidate(40, $thezip = $$value));
	    validate_store(showyoutube, 'showyoutube');
	    component_subscribe($$self, showyoutube, ($$value)=>$$invalidate(41, $showyoutube = $$value));
	    validate_store(landscape, 'landscape');
	    component_subscribe($$self, landscape, ($$value)=>$$invalidate(19, $landscape = $$value));
	    validate_store(downloading, 'downloading');
	    component_subscribe($$self, downloading, ($$value)=>$$invalidate(20, $downloading = $$value));
	    validate_store(audioid, 'audioid');
	    component_subscribe($$self, audioid, ($$value)=>$$invalidate(21, $audioid = $$value));
	    validate_store(playing, 'playing');
	    component_subscribe($$self, playing, ($$value)=>$$invalidate(22, $playing = $$value));
	    validate_store(remainrollback, 'remainrollback');
	    component_subscribe($$self, remainrollback, ($$value)=>$$invalidate(23, $remainrollback = $$value));
	    validate_store(showpunc, 'showpunc');
	    component_subscribe($$self, showpunc, ($$value)=>$$invalidate(24, $showpunc = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Swipezipimage', slots, []);
	    let { onMainmenu = ()=>{} } = $$props;
	    let { src } = $$props;
	    let foliopage = [], puncs = [], ready, hidepunc = false;
	    let { totalpages = 0 } = $$props;
	    let { onTapText = function() {} } = $$props;
	    let swiper;
	    let defaultIndex = 1;
	    let imageIndex = 0;
	    let favoritetimer = 0;
	    let imageFrame = {};
	    const getImages = (idx)=>{
	        const clss = [
	            "leftimage",
	            "middleimage",
	            "rightimage"
	        ];
	        const cls = clss[idx];
	        const imgs = document.getElementsByClassName(cls);
	        return imgs;
	    };
	    const swipeConfig = {
	        autoplay: false,
	        delay: 0,
	        showIndicators: false,
	        transitionDuration: 250,
	        allow_infinite_swipe: true
	    };
	    const loadZip = async ()=>{
	        $$invalidate(5, ready = false);
	        loadingzip.set(true);
	        let host = 'folio/';
	        const ftext = new FolioText(ptk); //fetchFolioText(ptk,$activefolioid);
	        await ftext.load($activefolioid);
	        foliotext.set(ftext);
	        // const res=await fetch(host+src);
	        const validateaddress = makeAddressFromFolioPos($tapmark);
	        if (addressFromUrl() !== validateaddress) {
	            updateUrl(validateaddress);
	        }
	        const res = await downloadToCache(CacheName, host + src, (msg)=>{
	            downloading.set(host + src + " " + msg);
	        });
	        downloading.set('');
	        const buf = await res.arrayBuffer();
	        const zip = new ZipStore(buf);
	        thezip.set(zip);
	        $$invalidate(0, totalpages = zip.files.length);
	        $$invalidate(9, imageIndex = parseInt($activepb) - 1);
	        if (imageIndex >= totalpages) $$invalidate(9, imageIndex = 0);
	        $$invalidate(5, ready = true);
	        setTimeout(()=>{
	            maxfolio.set(totalpages);
	            loadingzip.set(false);
	            setImages(imageIndex);
	            updateFolioText();
	            fetchAudioList($activefolioid, mediaurls, $showyoutube == 'on');
	        }, 10);
	    };
	    const swipeStart = (obj)=>{
	        $$invalidate(6, hidepunc = true);
	    };
	    let oldDefaultIndex = 1;
	    const setImage = (imageidx, zip, idx)=>{
	        if (!swiper) return;
	        if (idx >= totalpages) idx = 0;
	        else if (idx < 0) idx = totalpages - 1;
	        if (isNaN(idx)) idx = 0;
	        const imgs = getImages(imageidx);
	        //need to see all clone
	        for(let i = 0; i < imgs.length; i++){
	            const blob = new Blob([
	                zip.files[idx].content
	            ]);
	            imgs[i].src = URL.createObjectURL(blob);
	        }
	        swiper.update();
	    };
	    const setImages = (idx)=>{
	        if (!swiper) return;
	        const zip = $thezip;
	        let previdx = idx - 1;
	        if (previdx < 0) previdx = totalpages - 1;
	        let nextidx = idx + 1;
	        if (nextidx >= totalpages) nextidx = 0;
	        setImage((defaultIndex + 1) % 3, zip, previdx);
	        setImage(defaultIndex, zip, idx);
	        setImage((defaultIndex + 2) % 3, zip, nextidx);
	        swiper.update();
	        $$invalidate(9, imageIndex = idx);
	        const img = document.getElementsByClassName('middleimage')[0];
	        const height = img.clientHeight || imageFrame.height;
	        const width = img.clientWidth || imageFrame.width || height * 0.45; //some time width ==0
	        $$invalidate(11, imageFrame = {
	            left: 0,
	            top: 0,
	            width,
	            height
	        });
	    };
	    const swipeChanged = (obj)=>{
	        if (!ready) return;
	        const { active_item } = obj.detail;
	        $$invalidate(8, defaultIndex = active_item);
	        let idx = imageIndex;
	        const zip = $thezip;
	        if (oldDefaultIndex == defaultIndex) {
	            $$invalidate(6, hidepunc = false);
	            return;
	        }
	        //console.log( ((oldDefaultIndex+3) - defaultIndex)%3)
	        if ((oldDefaultIndex + 3 - defaultIndex) % 3 == 1) {
	            //next image
	            idx++;
	            if (idx >= totalpages) idx = 0;
	            setImage((oldDefaultIndex + 1) % 3, zip, idx + 1); //change next image
	        } else {
	            idx--;
	            if (idx < 0) idx = totalpages - 1;
	            setImage((oldDefaultIndex + 2) % 3, zip, idx - 1); //change prev image
	        }
	        oldDefaultIndex = defaultIndex;
	        $$invalidate(9, imageIndex = idx);
	        activepb.set((imageIndex + 1).toString());
	        swiper.update();
	        updateFolioText();
	        useractive();
	        confirmfavorite();
	    };
	    const updateFolioText = ()=>{
	        $$invalidate(6, hidepunc = true);
	        $$invalidate(3, foliopage = get_store_value(foliotext).folioPageText($activepb));
	        $$invalidate(3, foliopage = foliopage.join('\n').replace(/【[^】]+】/, '').split('\n'));
	        setTimeout(()=>{
	            const fl = folioLines();
	            $$invalidate(6, hidepunc = false);
	            $$invalidate(4, puncs = extractPuncPos(foliopage, fl));
	        }, 200); //wait until swiper stop
	    };
	    const useractive = (humanaction = false)=>{
	        if (!isSidePaiji() || humanaction) {
	            showpaiji.set(false);
	            idlecount.set(0);
	        }
	    };
	    const mousewheel = (e)=>{
	        if ($leftmode !== 'folio') return;
	        if (!ready) return;
	        if (e.ctrlKey) return;
	        $$invalidate(6, hidepunc = true);
	        let pb = parseInt($activepb);
	        if (e.deltaY > 0) {
	            pb++;
	            if (pb > totalpages) pb = 1;
	            activepb.set(pb);
	        } else {
	            pb--;
	            if (pb < 1) pb = totalpages;
	            activepb.set(pb);
	        }
	        useractive(true);
	        e.preventDefault();
	    };
	    const getCharXY = (x, y)=>{
	        const { left, top, width, height } = imageFrame;
	        x -= left;
	        y -= top;
	        const cx = folioLines() - Math.floor(x / width * folioLines()) - 1;
	        const cy = Math.floor(y / height * $folioChars);
	        return [
	            cx,
	            cy
	        ];
	    };
	    const onfoliopageclick = (e)=>{
	        if ($showpaiji && !isSidePaiji()) {
	            useractive(true);
	            return;
	        }
	        $$invalidate(6, hidepunc = false);
	        const { x, y } = e.detail;
	        const [cx, cy] = getCharXY(x, y);
	        if (cx >= folioLines() !== cx < 0) {
	            onTapText('');
	            return;
	        }
	        const oldmark = $tapmark;
	        const newmark = [
	            $activepb,
	            cx,
	            cy
	        ];
	        if (JSON.stringify(oldmark) == JSON.stringify(newmark)) {
	            sharing.set(true);
	            navigator.clipboard.writeText(shareAddress());
	            onTapText('');
	            return;
	        } else {
	            sharing.set(false);
	            tapmark.set(newmark);
	        }
	        const _addr = tapAddress();
	        updateUrl(_addr);
	        localStorage.setItem(AppPrefix + 'homeurl', _addr);
	        const ft = get_store_value(foliotext);
	        let { choff, linetext } = ft.fromFolioPos($activepb, cx, cy);
	        linetext = linetext.replace(/([。！？：、．；，「『（ ])/g, '　');
	        const offtext = linetext.slice(0, choff) + CURSORMARK + linetext.slice(choff).replace(/　.+/, '');
	        let [t] = parseOfftext(offtext);
	        while(t.charAt(0) == '　')t = t.slice(1);
	        while(t.charAt(t.length - 1) == '　')t = t.slice(0, t.length - 1);
	        onTapText(t);
	    };
	    const gotoPb = async (pb)=>{
	        if (!totalpages || !swiper) return; //not loaded yet
	        updateFolioText();
	        setImages(parseInt(pb) - 1);
	    };
	    const confirmfavorite = ()=>{
	        var _$favorites_$activefolioid;
	        if (favoritetimer) {
	            clearTimeout(favoritetimer);
	            $$invalidate(10, favoritetimer = 0);
	        }
	        cancellable = true;
	        const pb = $activepb;
	        const f = (_$favorites_$activefolioid = $favorites[$activefolioid]) === null || _$favorites_$activefolioid === void 0 ? void 0 : _$favorites_$activefolioid[pb];
	        if (f) {
	            //remove all other same favorite type in this folio
	            const bookfavor = Object.assign({}, $favorites);
	            for(let i in $favorites[$activefolioid]){
	                const f2 = $favorites[$activefolioid][i];
	                if (f2 == f && parseInt(pb) !== parseInt(i)) {
	                    delete $favorites[$activefolioid][i];
	                }
	            }
	            favorites.set(Object.assign({}, bookfavor));
	        }
	    };
	    let cancellable = true;
	    const favoritebtn = ()=>{
	        const actptk = $activePtk;
	        if (actptk !== 'ylz-prjn' && actptk !== 'ylz-tg' && actptk !== 'ylz-vny' && actptk !== 'ylz-svk') return; //only support chinese
	        clearTimeout(favoritetimer);
	        $$invalidate(10, favoritetimer = setTimeout(()=>{
	            confirmfavorite();
	        }, 5000));
	        const bookfavor = Object.assign({}, $favorites);
	        if (!bookfavor[$activefolioid]) {
	            bookfavor[$activefolioid] = {};
	        }
	        const type = bookfavor[$activefolioid][$activepb];
	        if (!type) {
	            cancellable = false;
	            bookfavor[$activefolioid][$activepb] = 1;
	        } else {
	            if (cancellable) {
	                delete bookfavor[$activefolioid][$activepb];
	                clearTimeout(favoritetimer);
	                $$invalidate(10, favoritetimer = 0);
	            } else {
	                let i = bookfavor[$activefolioid][$activepb] + 1;
	                if (i >= favortypes.length) i = 1;
	                bookfavor[$activefolioid][$activepb] = i;
	                cancellable = false;
	            }
	        }
	        favorites.set(Object.assign({}, bookfavor));
	    };
	    const toggleplaybtn = ()=>{
	        if (!get_store_value(audioid)) {
	            var _$mediaurls_;
	            if ($mediaurls.length < 2) return;
	            const pick = Math.floor(Math.random() * ($mediaurls.length - 1)) + 1;
	            const vid = $preferaudio[$activefolioid] || ((_$mediaurls_ = $mediaurls[pick || 1]) === null || _$mediaurls_ === void 0 ? void 0 : _$mediaurls_.aid);
	            selectmedia(vid);
	        } else {
	            selectmedia('');
	        }
	    };
	    $$self.$$.on_mount.push(function() {
	        if (src === undefined && !('src' in $$props || $$self.$$.bound[$$self.$$.props['src']])) {
	            console.warn("<Swipezipimage> was created without expected prop 'src'");
	        }
	    });
	    const writable_props = [
	        'onMainmenu',
	        'src',
	        'totalpages',
	        'onTapText'
	    ];
	    Object_1$1.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Swipezipimage> was created with unknown prop '${key}'`);
	    });
	    function swipe_binding($$value) {
	        binding_callbacks[$$value ? 'unshift' : 'push'](()=>{
	            swiper = $$value;
	            $$invalidate(7, swiper);
	        });
	    }
	    $$self.$$set = ($$props)=>{
	        if ('onMainmenu' in $$props) $$invalidate(32, onMainmenu = $$props.onMainmenu);
	        if ('src' in $$props) $$invalidate(33, src = $$props.src);
	        if ('totalpages' in $$props) $$invalidate(0, totalpages = $$props.totalpages);
	        if ('onTapText' in $$props) $$invalidate(34, onTapText = $$props.onTapText);
	    };
	    $$self.$capture_state = ()=>({
	            TranscriptLayer: Transcriptlayer,
	            PuncLayer: Punclayer,
	            TapMark: Tapmark,
	            Swipe,
	            SwipeItem: Swipeitem,
	            downloadToCache,
	            extractPuncPos,
	            usePtk,
	            FolioText,
	            parseOfftext,
	            updateUrl,
	            addressFromUrl,
	            CURSORMARK,
	            ZipStore,
	            DownloadStatus: Downloadstatus,
	            CacheName,
	            thezip,
	            favortypes,
	            landscape,
	            foliotext,
	            folioLines,
	            isSidePaiji,
	            tapAddress,
	            folioChars,
	            activePtk,
	            activefolioid,
	            activepb,
	            favorites,
	            audioid,
	            showpunc,
	            maxfolio,
	            tapmark,
	            playing,
	            remainrollback,
	            showyoutube,
	            shareAddress,
	            makeAddressFromFolioPos,
	            idlecount,
	            showpaiji,
	            loadingzip,
	            selectmedia,
	            preferaudio,
	            folioHolderWidth,
	            leftmode,
	            mediaurls,
	            downloading,
	            sharing,
	            get: get_store_value,
	            fetchAudioList,
	            AppPrefix,
	            onMainmenu,
	            src,
	            foliopage,
	            puncs,
	            ready,
	            hidepunc,
	            totalpages,
	            onTapText,
	            blankimage,
	            swiper,
	            defaultIndex,
	            imageIndex,
	            favoritetimer,
	            imageFrame,
	            getImages,
	            swipeConfig,
	            loadZip,
	            swipeStart,
	            oldDefaultIndex,
	            setImage,
	            setImages,
	            swipeChanged,
	            updateFolioText,
	            useractive,
	            mousewheel,
	            getCharXY,
	            onfoliopageclick,
	            gotoPb,
	            confirmfavorite,
	            cancellable,
	            favoritebtn,
	            toggleplaybtn,
	            ptk,
	            $activepb,
	            $mediaurls,
	            $activefolioid,
	            $preferaudio,
	            $favorites,
	            $activePtk,
	            $tapmark,
	            $showpaiji,
	            $folioChars,
	            $leftmode,
	            $thezip,
	            $showyoutube,
	            $landscape,
	            $downloading,
	            $audioid,
	            $playing,
	            $remainrollback,
	            $showpunc
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('onMainmenu' in $$props) $$invalidate(32, onMainmenu = $$props.onMainmenu);
	        if ('src' in $$props) $$invalidate(33, src = $$props.src);
	        if ('foliopage' in $$props) $$invalidate(3, foliopage = $$props.foliopage);
	        if ('puncs' in $$props) $$invalidate(4, puncs = $$props.puncs);
	        if ('ready' in $$props) $$invalidate(5, ready = $$props.ready);
	        if ('hidepunc' in $$props) $$invalidate(6, hidepunc = $$props.hidepunc);
	        if ('totalpages' in $$props) $$invalidate(0, totalpages = $$props.totalpages);
	        if ('onTapText' in $$props) $$invalidate(34, onTapText = $$props.onTapText);
	        if ('swiper' in $$props) $$invalidate(7, swiper = $$props.swiper);
	        if ('defaultIndex' in $$props) $$invalidate(8, defaultIndex = $$props.defaultIndex);
	        if ('imageIndex' in $$props) $$invalidate(9, imageIndex = $$props.imageIndex);
	        if ('favoritetimer' in $$props) $$invalidate(10, favoritetimer = $$props.favoritetimer);
	        if ('imageFrame' in $$props) $$invalidate(11, imageFrame = $$props.imageFrame);
	        if ('oldDefaultIndex' in $$props) oldDefaultIndex = $$props.oldDefaultIndex;
	        if ('cancellable' in $$props) cancellable = $$props.cancellable;
	        if ('ptk' in $$props) $$invalidate(1, ptk = $$props.ptk);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty[1] & /*$activePtk*/ 16) {
	            $$invalidate(1, ptk = usePtk($activePtk));
	        }
	        if ($$self.$$.dirty[0] & /*ptk*/ 2 | $$self.$$.dirty[1] & /*src*/ 4) {
	            ptk && loadZip();
	        }
	        if ($$self.$$.dirty[0] & /*$activepb*/ 4) {
	            gotoPb($activepb); //trigger by goto folio in setting.svelte
	        }
	    };
	    return [
	        totalpages,
	        ptk,
	        $activepb,
	        foliopage,
	        puncs,
	        ready,
	        hidepunc,
	        swiper,
	        defaultIndex,
	        imageIndex,
	        favoritetimer,
	        imageFrame,
	        $mediaurls,
	        $activefolioid,
	        $favorites,
	        $tapmark,
	        $showpaiji,
	        $folioChars,
	        $leftmode,
	        $landscape,
	        $downloading,
	        $audioid,
	        $playing,
	        $remainrollback,
	        $showpunc,
	        swipeConfig,
	        swipeStart,
	        swipeChanged,
	        mousewheel,
	        onfoliopageclick,
	        favoritebtn,
	        toggleplaybtn,
	        onMainmenu,
	        src,
	        onTapText,
	        $activePtk,
	        swipe_binding
	    ];
	}
	class Swipezipimage extends SvelteComponentDev {
	    get onMainmenu() {
	        throw new Error("<Swipezipimage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set onMainmenu(value) {
	        throw new Error("<Swipezipimage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get src() {
	        throw new Error("<Swipezipimage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set src(value) {
	        throw new Error("<Swipezipimage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get totalpages() {
	        throw new Error("<Swipezipimage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set totalpages(value) {
	        throw new Error("<Swipezipimage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get onTapText() {
	        throw new Error("<Swipezipimage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set onTapText(value) {
	        throw new Error("<Swipezipimage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$J, create_fragment$J, safe_not_equal, {
	            onMainmenu: 32,
	            src: 33,
	            totalpages: 0,
	            onTapText: 34
	        }, null, [
	            -1,
	            -1
	        ]);
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Swipezipimage",
	            options,
	            id: create_fragment$J.name
	        });
	    }
	}

	let portrait = window.matchMedia("(orientation: portrait)");
	portrait.addEventListener("change", function(e) {
	    // console.log(e.matches)
	    landscape.set(!e.matches);
	});
	window.addEventListener("deviceorientation", ()=>{
	    landscape.set(screen.availWidth > screen.availHeight);
	}, true);
	landscape.set(screen.availWidth > screen.availHeight);
	const documentHeight = ()=>{
	    const doc = document.documentElement;
	    const h = window.innerHeight * get_store_value(heightratio);
	    doc.style.setProperty('--doc-height', `${h}px`);
	};
	window.addEventListener('resize', documentHeight);

	const sc2tc = `㑔㑯
㑇㑳
㐹㑶
刾㓨
㘎㘚
㚯㜄
㛣㜏
㟆㠏
㤘㥮
㨫㩜
㧐㩳
擜㩵
㻪㻽
䀥䁻
鿎䃮
䌶䊷
䌺䋙
䌻䋚
䌿䋹
䌾䋻
䎬䎱
䙌䙡
䜧䜀
䞍䝼
䦂䥇
鿏䥑
䥾䥱
䦶䦛
䦷䦟
䯅䯀
鲃䰾
䲣䱷
䲝䱽
鳚䲁
鳤䲘
鹮䴉
丢丟
并<併並
干<幹>乾
乱亂
亚亞
伫佇
来來
仑侖
侣侶
俣俁
系<繫係
伣俔
侠俠
伡俥
伥倀
俩倆
俫倈
仓倉
个個
们們
伦倫
㑈倲
伟偉
㐽偑
侧側
侦偵
伪僞偽
㐷傌
杰<傑
伧傖
伞傘
备備
佣<傭
偬傯
传傳
伛傴
债債
伤傷
倾傾
偻僂
仅僅
佥僉
侨僑
仆<僕
侥僥
偾僨
价<價
仪儀
㑺儁
侬儂
亿億
侩儈
俭儉
傧儐
俦儔
侪儕
尽盡儘
偿償
优<優
储儲
俪儷
㑩儸
傩儺
傥儻
俨儼
兑兌
儿<兒
兖兗
内內
两兩
册冊
幂冪
净凈
冻凍
凛凜
凯凱
别別
删刪
刭剄
则則
克<剋
刹剎
刬剗
刚剛
剥剝
剐剮
剀剴
创創
划<劃
剧劇
刘劉
刽劊
刿劌
剑劍
㓥劏
剂劑
㔉劚
劲勁
动動
务務
勋勛
胜<勝
劳勞
势勢
勚勩
劢勱
励勵
劝勸
匀勻
匦匭
汇彙匯
匮匱
区區
协協
却卻
厍厙
厌厭
厉厲
厣厴
参參
叁叄
丛叢
咤>吒
吴吳
呐吶
吕呂
呙咼
员員
呗唄
吣唚
问問
哑啞
启啟
唡啢
㖞喎
唤喚
丧喪
乔喬
单單
哟喲
呛嗆
啬嗇
唝嗊
吗嗎
呜嗚
唢嗩
哔嗶
叹嘆
喽嘍
啯嘓
呕嘔
啧嘖
尝嘗
唛嘜
哗嘩
唠嘮
啸嘯
叽嘰
哓嘵
呒嘸
啴嘽
嘘噓
㖊噚
咝噝
哒噠
哝噥
哕噦
嗳噯
哙噲
喷噴
吨<噸
当當噹
咛嚀
吓嚇
哜嚌
噜嚕
啮嚙
呖嚦
咙嚨
亸嚲
喾嚳
严嚴
嘤嚶
啭囀
嗫囁
嚣囂
冁囅
呓囈
啰囉
嘱囑
囱囪
囵圇
国國
围圍
园園
圆圓
图圖
团團
埯垵
垭埡
采<採埰
执執
坚堅
垩堊
垴堖
埚堝
尧堯
报報
场場
块塊
茔塋
垲塏
埘塒
涂<塗
坞塢
埙塤
尘塵
堑塹
垫墊
坠墜
堕墮
坟墳
垯墶
垦墾
坛罈壇
垱壋
压壓
垒壘
圹壙
垆壚
坏<壞
垄壟
垅壠
坜壢
坝壩
塆壪
壮壯
壶壺
壸壼
寿壽
够夠
梦夢
夹夾
奂奐
奥奧
奁奩
夺奪
奨奬
奋奮
姹奼
妆妝
姗姍
奸<姦
娱娛
娄婁
妇婦
娅婭
娲媧
妫媯
㛀媰
媪媼
妈媽
妪嫗
妩嫵
娴嫻
婳嫿
媭嬃
娆嬈
婵嬋
娇嬌
嫱嬙
嫒嬡
嬷嬤
嫔嬪
婴嬰
婶嬸
㛤孋
娈孌
孙孫
学學
孪孿
宫宮
寝寢
实實
宁<寧
审審
写寫
宽寬
㝦寯
宠寵
宝寶
将將
专專
寻尋
对對
导導
尴尷
届屆
尸<屍
屃屓
屉屜
屡屢
层層
屦屨
属屬
冈岡
岘峴
岛島
峡峽
崃崍
岗崗
峥崢
岽崬
岚嵐
㟥嵾
嵝嶁
崭嶄
岖嶇
嵚嶔
崂嶗
峤嶠
峣嶢
峄嶧
崄嶮
岙嶴
嵘嶸
岭<嶺
屿嶼
岿巋
峦巒
巅巔
巯巰
帅帥
师師
帐帳
带帶
帧幀
帏幃
㡎幓
帼幗
帻幘
帜幟
币幣
帮幫
帱幬
么<麼>幺>麽
几<幾
库庫
厕廁
厢廂
厩廄
厦廈
厨廚
厮廝
庙廟
厂<廠
庑廡
废廢
广廣
廪廩
庐廬
厅廳
弑弒
弪弳
张張
强強
弹彈
弥彌
弯彎
彝<彞
彟彠
彦彥
彨彲
后<>後
径徑
从從
徕徠
复<複復>覆
征<>徵
彻徹
恒恆
耻恥
悦悅
悮悞
怅悵
闷悶
恶惡
恼惱
恽惲
恻惻
爱愛
惬愜
悫愨
怆愴
恺愷
忾愾
栗<慄
态態
愠慍
惨慘
惭慚
恸慟
惯慣
怄慪
怂慫
虑慮
悭慳
庆慶
㥪慺
忧憂
惫憊
㤭憍
怜<憐
凭憑
愦憒
慭憖
惮憚
愤憤
悯憫
怃憮
宪憲
忆憶
恳懇
应應
怿懌
懔懍
怼懟
懑懣
㤽懤
㤖懧
恹懨
惩懲
懒懶
怀<懷
悬懸
忏<懺
惧懼
慑懾
恋戀
戆戇
戋戔
戗戧
戬戩
战戰
戯戱
戏戲
户戶
抛拋
捝挩
挟挾
舍<捨
扪捫
扫掃
抡掄
㧏掆
挜掗
挣掙
挂<掛
拣揀
扬揚
换換
挥揮
损損
摇搖
捣搗
揾搵
抢搶
掴摑
掼摜
搂摟
挚摯
抠摳
抟摶
掺摻
捞撈
挦撏
撑撐
挠撓
㧑撝
挢撟
掸撣
拨撥
抚撫
扑<撲
揿撳
挞撻
挝撾
捡撿
拥擁
掳擄
择擇
击擊
挡擋
㧟擓
担擔
据<據
挤擠
㧛擥
拟擬
摈擯
拧擰
搁擱
掷擲
扩擴
撷擷
摆擺
擞擻
撸擼
㧰擽
扰<擾
摅攄
撵攆
拢攏
拦攔
撄攖
搀攙
撺攛
携攜
摄攝
攒攢
挛攣
摊攤
搅攪
揽攬
败敗
叙敘
敌敵
数數
敛斂
毙斃
敩斆
斓斕
斩斬
断斷
于<>於
时時
晋晉
昼晝
晕暈
晖暉
旸暘
畅暢
暂暫
晔曄
历歷曆
昙曇
晓曉
向<曏
暧曖
旷曠
昽曨
晒<曬
书書
会會
胧朧
东東
栅柵
杆<桿
栀梔
枧梘
条條
枭梟
棁梲
弃棄
枨棖
枣棗
栋棟
㭎棡
栈棧
栖<棲
梾棶
桠椏
㭏椲
杨楊
枫楓
桢楨
业業
极<極
杩榪
荣榮
榅榲
桤榿
构<構
枪槍
梿槤
椠槧
椁槨
椮槮
桨槳
椢槶
椝槼
桩樁
乐樂
枞樅
楼樓
标標
枢樞
㭤樢
样樣
㭴樫
桪樳
朴<樸
树樹
桦樺
椫樿
桡橈
桥橋
机<機
椭橢
横橫
檩檁
柽檉
档檔
桧檜
槚檟
检檢
樯檣
梼檮
台<颱臺檯
槟檳
柠檸
槛檻
柜<櫃
橹櫓
榈櫚
栉櫛
椟櫝
橼櫞
栎櫟
橱櫥
槠櫧
栌櫨
枥櫪
橥櫫
榇櫬
蘖櫱
栊櫳
榉櫸
樱櫻
栏欄
权權
椤欏
栾欒
榄欖
棂欞
钦欽
欧歐
欤歟
欢歡
岁歲
归歸
殁歿
残殘
殒殞
殇殤
㱮殨
殚殫
殓殮
殡殯
㱩殰
歼殲
杀殺
壳殼
毁毀
殴毆
毵毿
牦氂
毡氈
氇氌
气<氣
氢氫
氩氬
氲氳
决決
没沒
冲衝沖
况況
汹洶
浃浹
泾涇
凉涼
泪淚
渌淥
沦淪
渊淵
涞淶
浅淺
涣渙
减減
沨渢
涡渦
测測
浑渾
凑湊
浈湞
汤湯
沩溈
准<準
沟溝
温溫
浉溮
涢溳
沧滄
灭滅
涤滌
荥滎
沪滬
滞滯
渗滲
浒滸
浐滻
滚滾
满滿
渔漁
溇漊
沤漚
汉漢
涟漣
渍漬
涨漲
溆漵
渐漸
浆漿
颍潁
泼潑
洁<潔
㴋潚
潜潛
润潤
浔潯
溃潰
滗潷
涠潿
涩澀
浇澆
涝澇
涧澗
渑澠
泽澤
滪澦
泶澩
浍澮
淀<澱
㳠澾
浊濁
浓濃
㳡濄
湿濕
泞<濘
溁濚
浕濜
济濟
涛濤
㳔濧
滥濫
潍濰
滨濱
溅濺
泺濼
滤濾
澛瀂
滢瀅
渎瀆
㲿瀇
泻瀉
沈<瀋
浏瀏
濒瀕
泸瀘
沥瀝
潇瀟
潆瀠
潴瀦
泷瀧
濑瀨
㳽瀰
潋瀲
澜瀾
沣灃
滠灄
洒<灑
漓<灕
滩灘
灏灝
漤灠
㳕灡
湾灣
滦灤
滟灧
灾災
为為
乌烏
烃烴
无無
炼煉
炜煒
烟煙
茕煢
焕煥
烦煩
炀煬
㶽煱
煴熅
荧熒
炝熗
热熱
颎熲
炽熾
烨燁
灯燈
烧燒
烫燙
焖燜
营營
灿燦
烛燭
烩燴
㶶燶
烬燼
焘燾
烁爍
炉爐
烂爛
争爭
爷爺
尔爾
墙牆
牍牘
牵牽
荦犖
犊犢
牺犧
状狀
狭狹
狈狽
狰猙
犹猶
狲猻
犸獁
狱獄
狮獅
奖獎
独獨
狯獪
猃獫
狝獮
狞獰
㺍獱
获穫獲
猎獵
犷獷
兽獸
獭獺
献獻
猕獼
猡玀
现現
珐琺
珲琿
玮瑋
玚瑒
琐瑣
瑶瑤
莹瑩
玛瑪
玱瑲
琏璉
琎璡
玑璣
瑷璦
珰璫
㻅璯
环環
玙璵
瑸璸
玺璽
琼瓊
珑瓏
璎瓔
瓒瓚
瓯甌
产產
亩畝
毕畢
画畫
异<異
畴疇
叠疊
痉痙
疴痾
痖瘂
疯瘋
疡瘍
痪瘓
瘗瘞
疮瘡
疟瘧
瘆瘮
疭瘲
瘘瘺
疗療
痨癆
痫癇
瘅癉
疠癘
瘪癟
痒<癢
疖癤
症<癥
疬癧
癞癩
癣癬
瘿癭
瘾癮
痈癰
瘫癱
癫癲
发髮發
皑皚
疱皰
皲皸
皱皺
盗盜
盏盞
监監
盘盤
卢盧
荡蕩盪
眦眥
众眾
困<睏
睁睜
睐睞
眍瞘
䁖瞜
瞒瞞
瞆瞶
睑瞼
眬矓
瞩矚
矫矯
硁硜
硖硤
砗硨
砚硯
硕碩
砀碭
砜碸
确<確
码碼
䂵碽
硙磑
砖磚
硵磠
碜磣
碛磧
矶磯
硗磽
䃅磾
硚礄
硷鹼礆
础礎
碍礙
矿礦
砺礪
砾礫
矾礬
砻礱
禄祿
祸禍
祯禎
祎禕
祃禡
御<禦
禅禪
礼禮
祢禰
祷禱
秃禿
籼秈
税稅
秆稈
䅉稏
禀稟
种<種
称稱
谷<穀
䅟穇
稣穌
积積
颖穎
秾穠
穑穡
秽穢
稳穩
稆穭
窝窩
洼<窪
穷窮
窑窯
窎窵
窭窶
窥窺
窜竄
窍竅
窦竇
窃竊
竞競
笔筆
笋筍
笕筧
䇲筴
笺箋
筝箏
节節
范<範
筑<築
箧篋
筼篔
笃篤
筛篩
筚篳
箦簀
篓簍
箪簞
简簡
篑簣
箫簫
筜簹
签簽
帘<簾
篮籃
筹籌
䉤籔
箓籙
篯籛
箨籜
籁籟
笼籠
笾籩
簖籪
篱<籬
箩籮
粤粵
糁糝
粪糞
粮糧
粝糲
籴糴
粜糶
纟糹
纠糾
纪紀
纣紂
约約
红紅
纡紆
纥紇
纨紈
纫紉
纹紋
纳納
纽紐
纾紓
纯純
纰紕
纼紖
纱紗
纮紘
纸紙
级級
纷紛
纭紜
纴紝
纺紡
䌷紬
细細
绂紱
绁紲
绅紳
纻紵
绍紹
绀紺
绋紼
绐紿
绌絀
终終
组組
䌹絅
绊絆
绗絎
结結
绝絕
绦縧絛
绔絝
绞絞
络絡
绚絢
给給
绒絨
绖絰
统統
丝絲
绛絳
绢絹
绑綁
绡綃
绠綆
绨綈
绤綌
绥綏
䌼綐
经經
综綜
缍綞
绿綠
绸綢
绻綣
绶綬
维維
绹綯
绾綰
纲綱
网<網
缀綴
䌽綵
纶綸
绺綹
绮綺
绽綻
绰綽
绫綾
绵綿
绲緄
缁緇
紧緊
绯緋
绪緒
绬緓
绱鞝緔
缃緗
缄緘
缂緙
线線
缉緝
缎緞
缔締
缗緡
缘緣
缌緦
编編
缓緩
缅緬
纬緯
缑緱
缈緲
练練
缏緶
缇緹
致<緻
萦縈
缙縉
缢縊
缒縋
绉縐
缣縑
缊縕
缞縗
缚縛
缜縝
缟縞
缛縟
县縣
缝縫
缡縭
缩縮
纵縱
缧縲
䌸縳
缦縵
絷縶
缕縷
缥縹
总總
绩績
绷繃
缫繅
缪繆
缯繒
织織
缮繕
缭繚
绕繞
绣繡
缋繢
绳繩
绘繪
茧<繭
缰韁繮
缳繯
缲繰
缴繳
䍁繸
绎繹
继繼
缤繽
缱繾
䍀繿
颣纇
缬纈
纩纊
续續
累<纍
缠纏
缨纓
纤纖
缵纘
缆纜
钵缽
罂罌
罚罰
骂罵
罢罷
罗羅
罴羆
羁羈
芈羋
羟羥
义義
习習
翚翬
翘翹
翙翽
耧耬
耢耮
圣<聖
闻聞
联聯
聪聰
声聲
耸聳
聩聵
聂聶
职職
聍聹
听<聽
聋聾
肃肅
胁脅
脉脈
胫脛
脱脫
胀脹
肾腎
胨腖
脶腡
脑腦
肿腫
脚腳
肠腸
腽膃
腘膕
肤膚
䏝膞
胶膠
腻膩
胆膽
脍膾
脓膿
䐪臇
脸臉
脐臍
膑臏
腊<臘
胪臚
脏髒臟
脔臠
臜臢
临臨
与<與
兴興
举舉
旧舊
舱艙
舣艤
舰艦
舻艫
艰艱
艳艷
刍芻
苎苧
兹茲
荆荊
庄<莊
茎莖
荚莢
苋莧
华華
苌萇
莱萊
万<萬
荝萴
莴萵
叶葉
荭葒
着>著
荮葤
苇葦
荤葷
莳蒔
莅蒞
苍蒼
荪蓀
盖蓋
莲蓮
苁蓯
莼蓴
荜蓽
蒌蔞
蒋蔣
葱蔥
茑蔦
荫蔭
荨蕁
蒇蕆
荞蕎
荬蕒
芸<蕓
莸蕕
荛蕘
蒉蕢
芜蕪
萧蕭
蓣蕷
蕰薀
荟薈
蓟薊
芗薌
蔷薔
荙薘
莶薟
荐<薦
萨薩
䓕薳
苧<薴
䓓薵
荠薺
蓝藍
荩藎
艺藝
药藥
薮藪
苈藶
蔼藹
蔺藺
萚蘀
蕲蘄
芦蘆
苏蘇
蕴蘊
苹<蘋
藓蘚
蔹蘞
茏蘢
兰蘭
蓠蘺
萝蘿
蔂<虆
处處
虚虛
虏虜
号號
亏虧
虬虯
蛱蛺
蜕蛻
蚬蜆
蚀蝕
猬蝟
虾蝦
蜗蝸
蛳螄
蚂螞
萤螢
䗖螮
蝼螻
螀螿
蛰蟄
蝈蟈
螨蟎
虮<蟣
蝉蟬
蛲蟯
虫<蟲
蛏蟶
蚁蟻
蚃蠁
蝇蠅
虿蠆
蛴蠐
蝾蠑
蜡<蠟
蛎蠣
蟏蠨
蛊蠱
蚕<蠶
蛮蠻
术術
同<衕
胡<鬍衚
卫衛
衮袞
袅裊
补補
装裝
里<裡
制<製
裈褌
袆褘
裤褲
裢褳
褛褸
亵褻
裥襇
褝襌
袯襏
袄襖
裣襝
裆襠
褴襤
袜襪
䙓襬
衬襯
袭襲
襕襴
见見
觃覎
规規
觅覓
视視
觇覘
觋覡
觍覥
觎覦
亲親
觊覬
觏覯
觐覲
觑覷
觉覺
览覽
觌覿
观觀
觞觴
觯觶
触<觸
讠訁
订訂
讣訃
计計
讯訊
讧訌
讨討
讦訐
讱訒
训訓
讪訕
讫訖
讬託
记記
讹訛
讶訝
讼訟
䜣訢
诀訣
讷訥
讻訩
访訪
设設
许許
诉訴
诃訶
诊診
注<註
诂詁
诋詆
讵詎
诈詐
诒詒
诏詔
评評
诐詖
诇詗
诎詘
诅詛
词詞
咏詠
诩詡
询詢
诣詣
试試
诗詩
诧詫
诟詬
诡詭
诠詮
诘詰
话話
该該
详詳
诜詵
诙詼
诖詿
诔誄
诛誅
诓誆
夸<誇
志<誌
认認
诳誑
诶誒
诞誕
诱誘
诮誚
语語
诚誠
诫誡
诬誣
误誤
诰誥
诵誦
诲誨
说說
谁誰
课課
谇誶
诽誹
谊誼
訚誾
调調
谄諂
谆諄
谈談
诿諉
请請
诤諍
诹諏
诼諑
谅諒
论論
谂諗
谀諛
谍諜
谞諝
谝諞
诨諢
谔諤
谛諦
谐諧
谏諫
谕諭
谘諮
讳諱
谙諳
谌諶
讽諷
诸諸
谚諺
谖諼
诺諾
谋謀
谒謁
谓謂
誊謄
诌謅
谎謊
谜謎
谧謐
谑謔
谡謖
谤謗
谦謙
谥謚
讲講
谢謝
谣謠
谟謨
谪謫
谬謬
谫譾謭
讴謳
谨謹
谩謾
证證
谲譎
讥譏
谮譖
识識
谯譙
谭譚
谱譜
谵譫
译譯
议議
谴譴
护護
诪譸
䛓譼
誉譽
读讀
谉讅
变變
詟讋
䜩讌
雠讎
谗讒
让讓
谰讕
谶讖
谠讜
谳讞
岂豈
竖豎
丰<豐
猪豬
豮豶
猫貓
䝙貙
贝貝
贞貞
贠貟
负負
财財
贡貢
贫貧
货貨
贩販
贪貪
贯貫
责責
贮貯
贳貰
赀貲
贰貳
贵貴
贬貶
买買
贷貸
贶貺
费費
贴貼
贻貽
贸貿
贺賀
贲賁
赂賂
赁賃
贿賄
赅賅
资資
贾賈
贼賊
赈賑
赊賒
宾賓
赇賕
赒賙
赉賚
赐賜
赏賞
赔賠
赓賡
贤賢
卖賣
贱賤
赋賦
赕賧
质質
账賬
赌賭
䞐賰
赖賴
赗賵
赚賺
赙賻
购購
赛賽
赜賾
贽贄
赘贅
赟贇
赠贈
赞贊
赝贗贋
赡贍
赢贏
赆贐
赃贓
赑贔
赎贖
赣贛
赪赬
赶<趕
赵趙
趋趨
趱趲
迹跡
践踐
踊<踴
跄蹌
跸蹕
蹒蹣
踪蹤
跷蹺
跶躂
趸躉
踌躊
跻躋
跃躍
䟢躎
踯躑
跞躒
踬躓
蹰躕
跹躚
蹑躡
蹿躥
躜躦
躏躪
躯軀
车車
轧軋
轨軌
军軍
轪軑
轩軒
轫軔
轭軛
软軟
轷軤
轸軫
轱軲
轴軸
轵軹
轺軺
轲軻
轶軼
轼軾
较較
辂輅
辁輇
辀輈
载載
轾輊
辄輒
挽<輓
辅輔
轻輕
辆輛
辎輜
辉輝
辋輞
辍輟
辊輥
辇輦
辈輩
轮輪
辌輬
辑輯
辏輳
输輸
辐輻
辗輾
舆輿
辒轀
毂轂
辖轄
辕轅
辘轆
转轉
辙轍
轿轎
辚轔
轰轟
辔轡
轹轢
轳轤
办辦
辞辭
辫辮
辩辯
农農
迳逕
这這
连連
进進
运運
过過
达達
违違
遥遙
逊遜
递遞
远遠
适<適
迟遲
迁遷
选選
遗遺
辽遼
迈邁
还還
迩邇
边邊
逻邏
逦邐
郏郟
邮郵
郓鄆
乡鄉
邹鄒
邬鄔
郧鄖
邓鄧
郑鄭
邻鄰
郸鄲
邺鄴
郐鄶
邝鄺
酂酇
郦酈
丑<醜
酝醞
医醫
酱醬
酦醱
酿釀
衅釁
酾釃
酽釅
释釋
厘<釐
钅釒
钆釓
钇釔
钌釕
钊釗
钉釘
钋釙
针針
钓釣
钐釤
钏釧
钒釩
钗釵
钍釷
钕釹
钎釺
䥺釾
钯鈀
钫鈁
钘鈃
钭鈄
钚鈈
钠鈉
钝鈍
钩鉤鈎
钤鈐
钣鈑
钑鈒
钞鈔
钮鈕
钧鈞
钙鈣
钬鈥
钛鈦
钪鈧
铌鈮
铈鈰
钶鈳
铃鈴
钴鈷
钹鈸
铍鈹
钰鈺
钸鈽
铀鈾
钿鈿
钾鉀
钜鉅
铊鉈
铉鉉
铇鉋
铋鉍
铂鉑
钷鉕
钳鉗
铆鉚
铅鉛
钺鉞
钲鉦
鿭鑈鉨
钼鉬
钽鉭
铏鉶
铰鉸
铒鉺
铬鉻
铪鉿
银銀
铳銃
铜銅
铚銍
铣銑
铨銓
铢銖
铭銘
铫銚
铦銛
衔銜
铑銠
铷銣
铱銥
铟銦
铵銨
铥銩
铕銪
铯銫
铐銬
铞銱
锐銳
销銷
锈鏽銹
锑銻
锉銼
铝鋁
锒鋃
锌鋅
钡鋇
铤鋌
铗鋏
锋鋒
铻鋙
锊鋝
锓鋟
铘鋣
锄鋤
锃鋥
锔鋦
锇鋨
铓鋩
铺鋪
铖鋮
锆鋯
锂鋰
铽鋱
锍鋶
锯鋸
钢鋼
锞錁
录錄
锖錆
锫錇
锩錈
铔錏
锥錐
锕錒
锟錕
锤錘
锱錙
铮錚
锛錛
锬錟
锭錠
锜錡
钱錢
锦錦
锚錨
锠錩
锡錫
锢錮
错錯
锰錳
表<錶
铼錸
锝鍀
锨鍁
锪鍃
钔鍆
锴鍇
锳鍈
锅鍋
镀鍍
锷鍔
铡鍘
钖鍚
锻鍛
锽鍠
锸鍤
锲鍥
锘鍩
锹鍬
锾鍰
键鍵
锶鍶
锗鍺
钟鐘鍾
镁鎂
锿鎄
镅鎇
镑鎊
镕鎔
锁鎖
镉鎘
镈鎛
镃鎡
钨鎢
蓥鎣
镏鎦
铠鎧
铩鎩
锼鎪
镐鎬
镇鎮
镒鎰
镋鎲
镍鎳
镓鎵
鿔鎶
镎鎿
镞鏃
镟鏇
链鏈
镆鏌
镙鏍
镠鏐
镝鏑
铿鏗
锵鏘
镗鏜
镘鏝
镛鏞
铲鏟
镜鏡
镖鏢
镂鏤
錾鏨
镚鏰
铧鏵
镤鏷
镪鏹
䥽鏺
铙鐃
铴鐋
镣鐐
铹鐒
镦鐓
镡鐔
镫鐙
镢鐝
镨鐠
䦅鐥
锎鐦
锏鐧
镄鐨
镌鐫
镰鐮
䦃鐯
镯鐲
镭鐳
铁鐵
镮鐶
铎鐸
铛鐺
镱鐿
铸鑄
镬鑊
镔鑌
鉴鑒
镲鑔
锧鑕
镴鑞
铄鑠
镳鑣
镥鑥
镧鑭
钥鑰
镵鑱
镶鑲
镊鑷
镩鑹
锣鑼
钻鑽
銮鑾
凿鑿
䦆钁
长長
门門
闩閂
闪閃
闫閆
闬閈
闭閉
开開
闶閌
闳閎
闰閏
闲閒閑
间間
闵閔
闸閘
阂閡
阁閣
阀閥
闺閨
闽閩
阃閫
阆閬
闾閭
阅閱
阊閶
阉閹
阎閻
阏閼
阍閽
阈閾
阌閿
阒闃
板<闆
闱闈
阔闊
阕闋
阑闌
阇闍
阗闐
阘闒
闿闓
阖闔
阙闕
闯闖
关關
阚闞
阓闠
阐闡
辟<闢
阛闤
闼闥
坂>阪
陉陘
陕陝
阵陣
阴陰
陈陳
陆陸
阳陽
陧隉
队隊
阶階
陨隕
际際
随隨
险險
陦隯
隐隱
陇隴
隶隸
只<隻
隽雋
虽雖
双雙
雏雛
杂雜
鸡雞
离<離
难難
云<雲
电電
霡霢
雾霧
霁霽
雳靂
霭靄
叇靆
灵靈
叆靉
靓靚
静靜
䩄靦
靥靨
鼗鞀
巩鞏
鞒鞽
鞑韃
鞯韉
韦韋
韧韌
韨韍
韩韓
韪韙
韬韜
韫韞
韵韻
响響
页頁
顶頂
顷頃
项項
顺順
顸頇
须鬚須
顼頊
颂頌
颀頎
颃頏
预預
顽頑
颁頒
顿頓
颇頗
领領
颌頜
颉頡
颐頤
颏頦
头頭
颒頮
颊頰
颋頲
颕頴
颔頷
颈頸
颓頹
频頻
颗顆
题題
额額
颚顎
颜顏
颙顒
颛顓
愿<願
颡顙
颠顛
类類
颟顢
颢顥
顾顧
颤顫
颥顬
显顯
颦顰
颅顱
颞顳
颧顴
风風
飐颭
飑颮
飒颯
刮<颳
飓颶
飔颸
飏颺
飖颻
飕颼
飗飀
飘飄
飙飆
飚飈
飞飛
饣飠
饥飢
饤飣
饦飥
饨飩
饪飪
饫飫
饬飭
饭飯
饮飲
饴飴
饲飼
饱飽
饰飾
饳飿
饺餃
饸餄
饼餅
饷餉
养養
饵餌
饹餎
饻餏
饽餑
馁餒
饿餓
馂餕
饾餖
余<餘
肴<餚
馄餛
馃餜
饯餞
馅餡
馆館
糇餱
饧餳
馉餶
馇餷
馎餺
饩餼
馏餾
馊餿
馌饁
馍饃
馒饅
馐饈
馑饉
馓饊
馈饋
馔饌
饶饒
飨饗
餍饜
馋饞
馕饢
马馬
驭馭
冯馮
驮馱
驰馳
驯馴
驲馹
驳駁
驻駐
驽駑
驹駒
驵駔
驾駕
骀駘
驸駙
驶駛
驼駝
驷駟
骈駢
骇駭
骃駰
骆駱
骎駸
骏駿
骋騁
骍騂
骓騅
骔騌
骒騍
骑騎
骐騏
骛騖
骗騙
骙騤
䯄騧
骞騫
骘騭
骝騮
腾騰
驺騶
骚騷
骟騸
骡騾
蓦驀
骜驁
骖驂
骠驃
骢驄
驱驅
骅驊
骕驌
骁驍
骣驏
骄驕
验驗
惊<驚
驿驛
骤驟
驴驢
骧驤
骥驥
骦驦
骊驪
骉驫
肮<骯
髅髏
体<體
髌髕
髋髖
松<鬆
鬓鬢
斗<鬥
闹鬧
阋鬩
阄鬮
郁<鬱
鬶鬹
魉魎
魇魘
鱼魚
鱽魛
鱾魢
鲀魨
鲁魯
鲂魴
鱿魷
鲄魺
鲅鮁
鲆鮃
鲌鮊
鲉鮋
鲏鮍
鲇鮎
鲐鮐
鲍鮑
鲋鮒
鲊鮓
鲒鮚
鲘鮜
鲕鮞
䲟鮣
鲖鮦
鲔鮪
鲛鮫
鲑鮭
鲜鮮
鲓鮳
鲪鮶
鲝鮺
鲧鯀
鲠鯁
鲩鯇
鲤鯉
鲨鯊
鲬鯒
鲻鯔
鲯鯕
鲭鯖
鲞鯗
鲷鯛
鲴鯝
鲱鯡
鲵鯢
鲲鯤
鲳鯧
鲸鯨
鲮鯪
鲰鯫
鲶鯰
鲺鯴
鳀鯷
鲫鯽
鳊鯿
鳈鰁
鲗鰂
鳂鰃
䲠鰆
鲽鰈
鳇鰉
䲡鰌
鳅鰍
鲾鰏
鳄鱷鰐
鳆鰒
鳃鰓
鳒鰜
鳑鰟
鳋鰠
鲥鰣
鳏鰥
䲢鰧
鳎鰨
鳐鰩
鳍鰭
鳁鰮
鲢鰱
鳌鰲
鳓鰳
鳘鰵
鲦鰷
鲣鰹
鲹鰺
鳗鰻
鳛鰼
鳔鰾
鳉鱂
鳙鱅
鳕鱈
鳖鱉
鳟鱒
鳝鱔
鳜鱖
鳞鱗
鲟鱘
鲼鱝
鲎鱟
鲙鱠
鳣鱣
鳡鱤
鳢鱧
鲿鱨
鲚鱭
鳠鱯
鲈鱸
鲡鱺
鸟鳥
凫鳧
鸠鳩
鸤鳲
凤鳳
鸣鳴
鸢鳶
䴓鳾
鸩鴆
鸨鴇
鸦鴉
鸰鴒
鸵鴕
鸳鴛
鸲鴝
鸮鴞
鸱鴟
鸪鴣
鸯鴦
鸭鴨
鸸鴯
鸹鴰
鸻鴴
䴕鴷
鸿鴻
鸽鴿
䴔鵁
鸺鵂
鸼鵃
鹀鵐
鹃鵑
鹆鵒
鹁鵓
鹈鵜
鹅鵝
鹄鵠
鹉鵡
鹌鵪
鹏鵬
鹐鵮
鹎鵯
鹊鵲
鹓鵷
鹍鵾
䴖鶄
鸫鶇
鹑鶉
鹒鶊
鹋鶓
鹙鶖
鹕鶘
鹗鶚
鹖鶡
鹛鶥
鹜鶩
䴗鶪
鸧鶬
莺鶯
鹟鶲
鹤鶴
鹠鶹
鹡鶺
鹘鶻
鹣鶼
鹚鷀
鹢鷁
鹞鷂
䴘鷉鷈
鹝鷊
鹧鷓
鹥鷖
鸥鷗
鸷鷙
鹨鷚
鸶鷥
鹪鷦
鹔鷫
鹩鷯
鹫鷲
鹇鷳
鹬鷸
鹰鷹
鹭鷺
鸴鷽
䴙鸊鷿
㶉鸂
鹯鸇
鹱鸌
鹲鸏
鸬鸕
鹴鸘
鹦鸚
鹳鸛
鹂鸝
鸾鸞
卤鹵
咸<鹹
鹾鹺
盐鹽
丽麗
麦麥
麸麩
曲<麯
麹>麴
面<麵
黄黃
黉黌
点點
党<黨
黪黲
黡黶
黩黷
黾黽
鼋黿
鼍鼉
鼹鼴
齐齊
斋齋
赍齎
齑齏
齿齒
龀齔
龁齕
龂齗
龅齙
龇齜
龃齟
龆齠
龄齡
出<齣
龈齦
龊齪
龉齬
龋齲
腭齶
龌齷
龙龍
厐龎
庞龐
䶮龑
龚龔
龛龕
龟龜
䜤鿁
䲤鿐
鿓鿒`;

	const mapping = sc2tc.split(/\r?\n/);
	mapping.push('“「');
	mapping.push('‘『');
	mapping.push('”」');
	mapping.push('’』');
	/*
	伪=偽僞   //對應兩個繁體字
	㐷=傌     //gb 與 big5 一對一 (繁體無㐷字)
	杰~傑     //繁體有「杰」字
	*/ const overwrite = {
	    "获": "獲穫",
	    "缰": "繮韁",
	    "赝": "贋贗",
	    "伪": "僞偽",
	    "汇": "匯彙",
	    "坛": "壇罈",
	    "台": "臺颱檯",
	    "冲": "沖衝",
	    "硷": "礆鹼",
	    "绱": "緔鞝",
	    "脏": "臟髒",
	    "谫": "謭譾",
	    "钩": "鈎鉤",
	    "鿭": "鉨鑈",
	    "锈": "銹鏽",
	    "闲": "閑閒",
	    "须": "須鬚",
	    "鳄": "鰐鱷"
	};
	const t2s = {}, t2s_unsafe1 = {};
	mapping.forEach((line, idx)=>{
	    const r = line.match(/(.)(<?)(.+)/u);
	    if (!r) throw 'wrong data format ' + idx;
	    let [m, sc, op, tc] = r;
	    let oldtc = tc;
	    if (overwrite[sc]) tc = overwrite[sc];
	    if (op == '') {
	        if (tc.length == 1) {
	            t2s[tc] = sc;
	        } else {
	            if (tc[0] == '>') {
	                t2s_unsafe1[tc.substring(1)] = sc;
	            } else {
	                //历歷曆  , 发髮發 , 脏臟髒
	                t2s[tc[0]] = sc; //第一個繁體可以安全轉到簡體
	                tc = tc.substring(1);
	                for(let i = 0; i < tc.length; i++){
	                    const cp = tc.codePointAt(i); //考慮未來 surrogate
	                    if (!cp) break;
	                    t2s_unsafe1[String.fromCodePoint(cp)] = sc;
	                }
	            }
	        }
	    } else {
	        if (tc.length == 1) {
	            t2s_unsafe1[tc] = sc; //簡字也在big5中
	        } else {
	            while(tc && tc[0] !== '>'){
	                //接受 幹=>干 ,臺=>台 
	                const ch = String.fromCodePoint(tc.codePointAt(0));
	                t2s_unsafe1[ch] = sc;
	                tc = tc.substring(ch.length);
	            }
	        //最後剩六組  干乾  后後  复覆 征徵  于於  么幺麽
	        //繁體都收，不轉換
	        }
	    }
	    tc = oldtc.replace(/\>/g, '');
	    if (op == '<') {
	        tc.replace(sc, '') + sc; //簡字也可能是繁字 ， 簡字「面」 可能是繁字的「麵」或「面」
	    }
	});
	const toSim = (s, mode = 1)=>{
	    if (!s) return s;
	    let out = '', i = 0;
	    if (!mode) return s;
	    while(i < s.length){
	        const cp = s.codePointAt(i);
	        const ucs4 = String.fromCodePoint(cp);
	        if (!ucs4) break;
	        let sc = t2s[ucs4];
	        if (mode == 2 && !sc) sc = t2s_unsafe1[ucs4];
	        out += sc || ucs4;
	        i++;
	        if (cp > 0xffff) i++;
	    }
	    return out;
	};

	const _ = (text, _sim)=>{
	    const sim = typeof _sim == 'undefined' ? get_store_value(tosim) : _sim;
	    if (parseInt(sim)) return toSim(text, sim);
	    return text;
	};

	const file$G = "src\\dictpopup.svelte";
	function get_each_context$j(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[17] = list[i][0];
	    child_ctx[18] = list[i][1];
	    child_ctx[20] = i;
	    return child_ctx;
	}
	// (74:0) {:else}
	function create_else_block_2(ctx) {
	    let t_value = _("點要查的字詞。") + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block_2.name,
	        type: "else",
	        source: "(74:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (44:0) {#if entries.length}
	function create_if_block$m(ctx) {
	    let span;
	    let t;
	    let if_block_anchor;
	    let each_value = ensure_array_like_dev(/*entries*/ ctx[0]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
	    }
	    let if_block = /*src*/ ctx[5] && create_if_block_1$d(ctx);
	    const block = {
	        c: function create() {
	            span = element("span");
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            t = space();
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	            attr_dev(span, "class", "header svelte-q5fwfc");
	            add_location(span, file$G, 44, 0, 1292);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(span, null);
	                }
	            }
	            insert_dev(target, t, anchor);
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*nentry, baidulink, entries, googlelink, wikilink, showing, setWikipedia, wikipedia, onelinelink, setOneline, fgdzd, dfb*/ 8159) {
	                each_value = ensure_array_like_dev(/*entries*/ ctx[0]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$j(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$j(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(span, null);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	            if (/*src*/ ctx[5]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block_1$d(ctx);
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	                detach_dev(t);
	                detach_dev(if_block_anchor);
	            }
	            destroy_each(each_blocks, detaching);
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$m.name,
	        type: "if",
	        source: "(44:0) {#if entries.length}",
	        ctx
	    });
	    return block;
	}
	// (49:0) {#if idx==nentry}
	function create_if_block_2$7(ctx) {
	    let t0;
	    let t1;
	    let a0;
	    let t2;
	    let a0_href_value;
	    let t3;
	    let a1;
	    let t4;
	    let a1_href_value;
	    let if_block0 = /*fgdzd*/ (ctx[3] || /*dfb*/ ctx[4]) && create_if_block_5$4(ctx);
	    let if_block1 = /*wikipedia*/ ctx[2] && create_if_block_3$5(ctx);
	    const block = {
	        c: function create() {
	            if (if_block0) if_block0.c();
	            t0 = space();
	            if (if_block1) if_block1.c();
	            t1 = space();
	            a0 = element("a");
	            t2 = text("谷哥");
	            t3 = space();
	            a1 = element("a");
	            t4 = text("百度");
	            attr_dev(a0, "target", "_new");
	            attr_dev(a0, "href", a0_href_value = /*googlelink*/ ctx[9](/*entry*/ ctx[18]));
	            add_location(a0, file$G, 63, 0, 1802);
	            attr_dev(a1, "target", "_new");
	            attr_dev(a1, "href", a1_href_value = /*baidulink*/ ctx[10](/*entry*/ ctx[18]));
	            add_location(a1, file$G, 64, 0, 1849);
	        },
	        m: function mount(target, anchor) {
	            if (if_block0) if_block0.m(target, anchor);
	            insert_dev(target, t0, anchor);
	            if (if_block1) if_block1.m(target, anchor);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, a0, anchor);
	            append_dev(a0, t2);
	            insert_dev(target, t3, anchor);
	            insert_dev(target, a1, anchor);
	            append_dev(a1, t4);
	        },
	        p: function update(ctx, dirty) {
	            if (/*fgdzd*/ ctx[3] || /*dfb*/ ctx[4]) {
	                if (if_block0) {
	                    if_block0.p(ctx, dirty);
	                } else {
	                    if_block0 = create_if_block_5$4(ctx);
	                    if_block0.c();
	                    if_block0.m(t0.parentNode, t0);
	                }
	            } else if (if_block0) {
	                if_block0.d(1);
	                if_block0 = null;
	            }
	            if (/*wikipedia*/ ctx[2]) {
	                if (if_block1) {
	                    if_block1.p(ctx, dirty);
	                } else {
	                    if_block1 = create_if_block_3$5(ctx);
	                    if_block1.c();
	                    if_block1.m(t1.parentNode, t1);
	                }
	            } else if (if_block1) {
	                if_block1.d(1);
	                if_block1 = null;
	            }
	            if (dirty & /*entries*/ 1 && a0_href_value !== (a0_href_value = /*googlelink*/ ctx[9](/*entry*/ ctx[18]))) {
	                attr_dev(a0, "href", a0_href_value);
	            }
	            if (dirty & /*entries*/ 1 && a1_href_value !== (a1_href_value = /*baidulink*/ ctx[10](/*entry*/ ctx[18]))) {
	                attr_dev(a1, "href", a1_href_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(a0);
	                detach_dev(t3);
	                detach_dev(a1);
	            }
	            if (if_block0) if_block0.d(detaching);
	            if (if_block1) if_block1.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_2$7.name,
	        type: "if",
	        source: "(49:0) {#if idx==nentry}",
	        ctx
	    });
	    return block;
	}
	// (50:0) {#if fgdzd||dfb}
	function create_if_block_5$4(ctx) {
	    let if_block_anchor;
	    function select_block_type_1(ctx, dirty) {
	        if (/*showing*/ ctx[6] == 'oneline') return create_if_block_6$3;
	        return create_else_block_1$1;
	    }
	    let current_block_type = select_block_type_1(ctx);
	    let if_block = current_block_type(ctx);
	    const block = {
	        c: function create() {
	            if_block.c();
	            if_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
	                if_block.p(ctx, dirty);
	            } else {
	                if_block.d(1);
	                if_block = current_block_type(ctx);
	                if (if_block) {
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_5$4.name,
	        type: "if",
	        source: "(50:0) {#if fgdzd||dfb}",
	        ctx
	    });
	    return block;
	}
	// (53:0) {:else}
	function create_else_block_1$1(ctx) {
	    let button;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            button = element("button");
	            button.textContent = "一行";
	            add_location(button, file$G, 53, 0, 1596);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, button, anchor);
	            if (!mounted) {
	                dispose = listen_dev(button, "click", /*setOneline*/ ctx[12], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(button);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block_1$1.name,
	        type: "else",
	        source: "(53:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (51:0) {#if showing=='oneline'}
	function create_if_block_6$3(ctx) {
	    let a;
	    let t;
	    let a_href_value;
	    const block = {
	        c: function create() {
	            a = element("a");
	            t = text("一行");
	            attr_dev(a, "target", "_new");
	            attr_dev(a, "href", a_href_value = /*onelinelink*/ ctx[8](/*entry*/ ctx[18]));
	            add_location(a, file$G, 51, 0, 1540);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, a, anchor);
	            append_dev(a, t);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*entries*/ 1 && a_href_value !== (a_href_value = /*onelinelink*/ ctx[8](/*entry*/ ctx[18]))) {
	                attr_dev(a, "href", a_href_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(a);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_6$3.name,
	        type: "if",
	        source: "(51:0) {#if showing=='oneline'}",
	        ctx
	    });
	    return block;
	}
	// (57:0) {#if wikipedia}
	function create_if_block_3$5(ctx) {
	    let if_block_anchor;
	    function select_block_type_2(ctx, dirty) {
	        if (/*showing*/ ctx[6] == 'wikipedia') return create_if_block_4$5;
	        return create_else_block$a;
	    }
	    let current_block_type = select_block_type_2(ctx);
	    let if_block = current_block_type(ctx);
	    const block = {
	        c: function create() {
	            if_block.c();
	            if_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
	                if_block.p(ctx, dirty);
	            } else {
	                if_block.d(1);
	                if_block = current_block_type(ctx);
	                if (if_block) {
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_3$5.name,
	        type: "if",
	        source: "(57:0) {#if wikipedia}",
	        ctx
	    });
	    return block;
	}
	// (60:0) {:else}
	function create_else_block$a(ctx) {
	    let button;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            button = element("button");
	            button.textContent = "維基";
	            add_location(button, file$G, 60, 0, 1746);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, button, anchor);
	            if (!mounted) {
	                dispose = listen_dev(button, "click", /*setWikipedia*/ ctx[11], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(button);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$a.name,
	        type: "else",
	        source: "(60:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (58:0) {#if showing=='wikipedia'}
	function create_if_block_4$5(ctx) {
	    let a;
	    let t;
	    let a_href_value;
	    const block = {
	        c: function create() {
	            a = element("a");
	            t = text("維基");
	            attr_dev(a, "target", "_new");
	            attr_dev(a, "href", a_href_value = /*wikilink*/ ctx[7](/*entry*/ ctx[18]));
	            add_location(a, file$G, 58, 0, 1693);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, a, anchor);
	            append_dev(a, t);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*entries*/ 1 && a_href_value !== (a_href_value = /*wikilink*/ ctx[7](/*entry*/ ctx[18]))) {
	                attr_dev(a, "href", a_href_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(a);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_4$5.name,
	        type: "if",
	        source: "(58:0) {#if showing=='wikipedia'}",
	        ctx
	    });
	    return block;
	}
	// (46:0) {#each entries as [distance,entry],idx}
	function create_each_block$j(ctx) {
	    let span;
	    let label;
	    let input;
	    let t0_value = /*entry*/ ctx[18] + "";
	    let t0;
	    let t1;
	    let t2;
	    let binding_group;
	    let mounted;
	    let dispose;
	    let if_block = /*idx*/ ctx[20] == /*nentry*/ ctx[1] && create_if_block_2$7(ctx);
	    binding_group = init_binding_group(/*$$binding_groups*/ ctx[14][0]);
	    const block = {
	        c: function create() {
	            span = element("span");
	            label = element("label");
	            input = element("input");
	            t0 = text(t0_value);
	            t1 = space();
	            if (if_block) if_block.c();
	            t2 = space();
	            attr_dev(input, "type", "radio");
	            attr_dev(input, "name", "dict");
	            input.__value = /*idx*/ ctx[20];
	            set_input_value(input, input.__value);
	            add_location(input, file$G, 47, 7, 1398);
	            add_location(label, file$G, 47, 0, 1391);
	            toggle_class(span, "dictgroup", /*idx*/ ctx[20] == /*nentry*/ ctx[1]);
	            add_location(span, file$G, 46, 0, 1354);
	            binding_group.p(input);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, label);
	            append_dev(label, input);
	            input.checked = input.__value === /*nentry*/ ctx[1];
	            append_dev(label, t0);
	            append_dev(span, t1);
	            if (if_block) if_block.m(span, null);
	            append_dev(span, t2);
	            if (!mounted) {
	                dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[13]);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*nentry, entries*/ 3) {
	                input.checked = input.__value === /*nentry*/ ctx[1];
	            }
	            if (dirty & /*entries*/ 1 && t0_value !== (t0_value = /*entry*/ ctx[18] + "")) set_data_dev(t0, t0_value);
	            if (/*idx*/ ctx[20] == /*nentry*/ ctx[1]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block_2$7(ctx);
	                    if_block.c();
	                    if_block.m(span, t2);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	            if (dirty & /*nentry*/ 2) {
	                toggle_class(span, "dictgroup", /*idx*/ ctx[20] == /*nentry*/ ctx[1]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            if (if_block) if_block.d();
	            binding_group.r();
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$j.name,
	        type: "each",
	        source: "(46:0) {#each entries as [distance,entry],idx}",
	        ctx
	    });
	    return block;
	}
	// (71:0) {#if src}
	function create_if_block_1$d(ctx) {
	    let iframe;
	    let iframe_src_value;
	    const block = {
	        c: function create() {
	            iframe = element("iframe");
	            set_style(iframe, "border", "none");
	            attr_dev(iframe, "class", "iframe svelte-q5fwfc");
	            attr_dev(iframe, "title", "wiki");
	            if (!src_url_equal(iframe.src, iframe_src_value = /*src*/ ctx[5])) attr_dev(iframe, "src", iframe_src_value);
	            add_location(iframe, file$G, 71, 0, 1936);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, iframe, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*src*/ 32 && !src_url_equal(iframe.src, iframe_src_value = /*src*/ ctx[5])) {
	                attr_dev(iframe, "src", iframe_src_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(iframe);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$d.name,
	        type: "if",
	        source: "(71:0) {#if src}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$I(ctx) {
	    let div;
	    function select_block_type(ctx, dirty) {
	        if (/*entries*/ ctx[0].length) return create_if_block$m;
	        return create_else_block_2;
	    }
	    let current_block_type = select_block_type(ctx);
	    let if_block = current_block_type(ctx);
	    const block = {
	        c: function create() {
	            div = element("div");
	            if_block.c();
	            attr_dev(div, "class", "dictpopup bodytext svelte-q5fwfc");
	            add_location(div, file$G, 42, 0, 1238);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            if_block.m(div, null);
	        },
	        p: function update(ctx, [dirty]) {
	            if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	                if_block.p(ctx, dirty);
	            } else {
	                if_block.d(1);
	                if_block = current_block_type(ctx);
	                if (if_block) {
	                    if_block.c();
	                    if_block.m(div, null);
	                }
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            if_block.d();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$I.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$I($$self, $$props, $$invalidate) {
	    let $activePtk;
	    validate_store(activePtk, 'activePtk');
	    component_subscribe($$self, activePtk, ($$value)=>$$invalidate(15, $activePtk = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Dictpopup', slots, []);
	    let { entries = [] } = $$props;
	    let wikipedia, fgdzd, dfb;
	    let nentry = 0;
	    let src = '', showing = '';
	    const wikilink = (entry)=>"https://zh.wikipedia.org/w/index.php?action=render&title=" + encodeURIComponent(entry);
	    const onelinelink = (entry)=>"https://buddhaspace.org/dict/index.php?keyword=" + encodeURIComponent(entry);
	    const googlelink = (entry)=>"https://www.google.com/search?q=" + encodeURIComponent(entry);
	    const baidulink = (entry)=>"https://www.baidu.com/s?wd=" + encodeURIComponent(entry);
	    const setWikipedia = ()=>{
	        if (!entries[nentry]) $$invalidate(1, nentry = 0);
	        const entry = entries[nentry][1];
	        $$invalidate(6, showing = 'wikipedia');
	        $$invalidate(5, src = wikilink(entry));
	    };
	    const setOneline = ()=>{
	        if (!entries[nentry]) $$invalidate(1, nentry = 0);
	        const entry = entries[nentry][1];
	        $$invalidate(6, showing = 'oneline');
	        $$invalidate(5, src = onelinelink(entry));
	    };
	    const availableDict = (n)=>{
	        if (n >= entries.length) {
	            n = 0;
	        }
	        if (!entries[n]) return;
	        const at = entries[n][2];
	        const flag = usePtk($activePtk).columns.entries.dict[at];
	        $$invalidate(2, wikipedia = flag & 1);
	        $$invalidate(3, fgdzd = flag & 2);
	        $$invalidate(4, dfb = flag & 4);
	        if (fgdzd || dfb) setOneline();
	        else if (wikipedia) setWikipedia();
	    };
	    const writable_props = [
	        'entries'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dictpopup> was created with unknown prop '${key}'`);
	    });
	    const $$binding_groups = [
	        []
	    ];
	    function input_change_handler() {
	        nentry = this.__value;
	        $$invalidate(1, nentry);
	    }
	    $$self.$$set = ($$props)=>{
	        if ('entries' in $$props) $$invalidate(0, entries = $$props.entries);
	    };
	    $$self.$capture_state = ()=>({
	            _,
	            activePtk,
	            usePtk,
	            entries,
	            wikipedia,
	            fgdzd,
	            dfb,
	            nentry,
	            src,
	            showing,
	            wikilink,
	            onelinelink,
	            googlelink,
	            baidulink,
	            setWikipedia,
	            setOneline,
	            availableDict,
	            $activePtk
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('entries' in $$props) $$invalidate(0, entries = $$props.entries);
	        if ('wikipedia' in $$props) $$invalidate(2, wikipedia = $$props.wikipedia);
	        if ('fgdzd' in $$props) $$invalidate(3, fgdzd = $$props.fgdzd);
	        if ('dfb' in $$props) $$invalidate(4, dfb = $$props.dfb);
	        if ('nentry' in $$props) $$invalidate(1, nentry = $$props.nentry);
	        if ('src' in $$props) $$invalidate(5, src = $$props.src);
	        if ('showing' in $$props) $$invalidate(6, showing = $$props.showing);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*nentry, entries*/ 3) {
	            availableDict(nentry);
	        }
	    };
	    return [
	        entries,
	        nentry,
	        wikipedia,
	        fgdzd,
	        dfb,
	        src,
	        showing,
	        wikilink,
	        onelinelink,
	        googlelink,
	        baidulink,
	        setWikipedia,
	        setOneline,
	        input_change_handler,
	        $$binding_groups
	    ];
	}
	class Dictpopup extends SvelteComponentDev {
	    get entries() {
	        throw new Error("<Dictpopup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set entries(value) {
	        throw new Error("<Dictpopup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$I, create_fragment$I, safe_not_equal, {
	            entries: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Dictpopup",
	            options,
	            id: create_fragment$I.name
	        });
	    }
	}

	const file$F = "src\\favoritebuttons.svelte";
	function get_each_context$i(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[7] = list[i][0];
	    child_ctx[8] = list[i][1];
	    return child_ctx;
	}
	// (19:0) {#each favors as [pb,favor]}
	function create_each_block$i(ctx) {
	    let span;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[4](/*pb*/ ctx[7]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            span.textContent = `${favortypes[/*favor*/ ctx[8]]}`;
	            attr_dev(span, "aria-hidden", "true");
	            add_location(span, file$F, 19, 0, 457);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$i.name,
	        type: "each",
	        source: "(19:0) {#each favors as [pb,favor]}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$H(ctx) {
	    let each_1_anchor;
	    let each_value = ensure_array_like_dev(/*favors*/ ctx[0]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            each_1_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, each_1_anchor, anchor);
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*gofavor, favors*/ 3) {
	                each_value = ensure_array_like_dev(/*favors*/ ctx[0]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$i(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$i(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(each_1_anchor);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$H.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$H($$self, $$props, $$invalidate) {
	    let $favorites;
	    validate_store(favorites, 'favorites');
	    component_subscribe($$self, favorites, ($$value)=>$$invalidate(5, $favorites = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Favoritebuttons', slots, []);
	    let { folioid } = $$props;
	    let { closePopup } = $$props;
	    let favors = [];
	    const _favorites = $favorites[folioid];
	    for(let i in _favorites){
	        if (_favorites[i]) favors.push([
	            parseInt(i),
	            _favorites[i]
	        ]);
	    }
	    const gofavor = (pb)=>{
	        loadFolio(folioid, ()=>{
	            activepb.set(pb);
	        });
	        closePopup();
	    };
	    $$self.$$.on_mount.push(function() {
	        if (folioid === undefined && !('folioid' in $$props || $$self.$$.bound[$$self.$$.props['folioid']])) {
	            console.warn("<Favoritebuttons> was created without expected prop 'folioid'");
	        }
	        if (closePopup === undefined && !('closePopup' in $$props || $$self.$$.bound[$$self.$$.props['closePopup']])) {
	            console.warn("<Favoritebuttons> was created without expected prop 'closePopup'");
	        }
	    });
	    const writable_props = [
	        'folioid',
	        'closePopup'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Favoritebuttons> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (pb)=>gofavor(pb);
	    $$self.$$set = ($$props)=>{
	        if ('folioid' in $$props) $$invalidate(2, folioid = $$props.folioid);
	        if ('closePopup' in $$props) $$invalidate(3, closePopup = $$props.closePopup);
	    };
	    $$self.$capture_state = ()=>({
	            favortypes,
	            favorites,
	            activepb,
	            loadFolio,
	            folioid,
	            closePopup,
	            favors,
	            _favorites,
	            gofavor,
	            $favorites
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('folioid' in $$props) $$invalidate(2, folioid = $$props.folioid);
	        if ('closePopup' in $$props) $$invalidate(3, closePopup = $$props.closePopup);
	        if ('favors' in $$props) $$invalidate(0, favors = $$props.favors);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        favors,
	        gofavor,
	        folioid,
	        closePopup,
	        click_handler
	    ];
	}
	class Favoritebuttons extends SvelteComponentDev {
	    get folioid() {
	        throw new Error("<Favoritebuttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set folioid(value) {
	        throw new Error("<Favoritebuttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get closePopup() {
	        throw new Error("<Favoritebuttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set closePopup(value) {
	        throw new Error("<Favoritebuttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$H, create_fragment$H, safe_not_equal, {
	            folioid: 2,
	            closePopup: 3
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Favoritebuttons",
	            options,
	            id: create_fragment$H.name
	        });
	    }
	}

	const viplist = {
	    'FAWANG': {
	        title: '法王講堂',
	        www: 'http://fawang.com.tw/main1_0.htm'
	    },
	    'FAYUN': {
	        title: '法雲寺',
	        www: 'https://dcm.org.tw/'
	    },
	    'YAP': {
	        title: '作者',
	        www: 'https://nissaya.cn/'
	    },
	    'HAIYIN': {
	        title: '金門海印寺',
	        www: 'https://kinmen.travel/zh-tw/travel/attraction/401'
	    }
	};
	const getVip = (field)=>{
	    const obj = viplist[get_store_value(vip)] || {};
	    return obj[field] || '';
	};

	const file$E = "src\\endmarker.svelte";
	// (8:0) {#if !$vip}
	function create_if_block$l(ctx) {
	    let t0_value = _("公眾版本") + "";
	    let t0;
	    let t1;
	    const block = {
	        c: function create() {
	            t0 = text(t0_value);
	            t1 = text("※※");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t0, anchor);
	            insert_dev(target, t1, anchor);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$l.name,
	        type: "if",
	        source: "(8:0) {#if !$vip}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$G(ctx) {
	    let div;
	    let t0;
	    let a;
	    let t1_value = getVip('title', /*$vip*/ ctx[0]) + "";
	    let t1;
	    let t2;
	    let if_block = !/*$vip*/ ctx[0] && create_if_block$l(ctx);
	    const block = {
	        c: function create() {
	            div = element("div");
	            t0 = text("※");
	            a = element("a");
	            t1 = text(t1_value);
	            t2 = text("※\n");
	            if (if_block) if_block.c();
	            attr_dev(a, "target", "_new");
	            attr_dev(a, "href", getVip('www'));
	            add_location(a, file$E, 6, 24, 138);
	            attr_dev(div, "class", "endmarker");
	            add_location(div, file$E, 6, 0, 114);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, t0);
	            append_dev(div, a);
	            append_dev(a, t1);
	            append_dev(div, t2);
	            if (if_block) if_block.m(div, null);
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*$vip*/ 1 && t1_value !== (t1_value = getVip('title', /*$vip*/ ctx[0]) + "")) set_data_dev(t1, t1_value);
	            if (!/*$vip*/ ctx[0]) {
	                if (if_block) ; else {
	                    if_block = create_if_block$l(ctx);
	                    if_block.c();
	                    if_block.m(div, null);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            if (if_block) if_block.d();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$G.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$G($$self, $$props, $$invalidate) {
	    let $vip;
	    validate_store(vip, 'vip');
	    component_subscribe($$self, vip, ($$value)=>$$invalidate(0, $vip = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Endmarker', slots, []);
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Endmarker> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            getVip,
	            vip,
	            _,
	            $vip
	        });
	    return [
	        $vip
	    ];
	}
	class Endmarker extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$G, create_fragment$G, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Endmarker",
	            options,
	            id: create_fragment$G.name
	        });
	    }
	}

	const { console: console_1$2 } = globals;
	const file$D = "src\\foliolist.svelte";
	function get_each_context$h(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[32] = list[i][0];
	    child_ctx[33] = list[i][1];
	    child_ctx[34] = list[i][2];
	    return child_ctx;
	}
	function get_each_context_1$3(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[37] = list[i];
	    return child_ctx;
	}
	// (164:0) {:else}
	function create_else_block$9(ctx) {
	    let div;
	    let span;
	    let t0;
	    let t1;
	    let t2;
	    let mounted;
	    let dispose;
	    let if_block = /*aptk*/ ctx[1] == "ylz-vny" && create_if_block_4$4(ctx);
	    const block = {
	        c: function create() {
	            div = element("div");
	            span = element("span");
	            t0 = text("安裝 ");
	            t1 = text(/*downloadmessage*/ ctx[2]);
	            t2 = space();
	            if (if_block) if_block.c();
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable hyperlink");
	            add_location(span, file$D, 165, 0, 5536);
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$D, 164, 0, 5513);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, span);
	            append_dev(span, t0);
	            append_dev(span, t1);
	            append_dev(div, t2);
	            if (if_block) if_block.m(div, null);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*click_handler_7*/ ctx[25], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*downloadmessage*/ 4) set_data_dev(t1, /*downloadmessage*/ ctx[2]);
	            if (/*aptk*/ ctx[1] == "ylz-vny") {
	                if (if_block) ; else {
	                    if_block = create_if_block_4$4(ctx);
	                    if_block.c();
	                    if_block.m(div, null);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            if (if_block) if_block.d();
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$9.name,
	        type: "else",
	        source: "(164:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (136:0) {#if folios.length}
	function create_if_block$k(ctx) {
	    let t;
	    let each_1_anchor;
	    let current;
	    let if_block = /*downloading*/ ctx[4] && create_if_block_3$4(ctx);
	    let each_value = ensure_array_like_dev(/*folios*/ ctx[3]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
	    }
	    const out = (i)=>transition_out(each_blocks[i], 1, 1, ()=>{
	            each_blocks[i] = null;
	        });
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            t = space();
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            each_1_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, t, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, each_1_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (/*downloading*/ ctx[4]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block_3$4(ctx);
	                    if_block.c();
	                    if_block.m(t.parentNode, t);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	            if (dirty[0] & /*$tosim, folios, getFolioId, closePopup, $folioincache, $activefolioid, selectfolio, getFolioName, $online, downloadBook, $vip, downloading, samesutra, aptk*/ 64507) {
	                each_value = ensure_array_like_dev(/*folios*/ ctx[3]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$h(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                        transition_in(each_blocks[i], 1);
	                    } else {
	                        each_blocks[i] = create_each_block$h(child_ctx);
	                        each_blocks[i].c();
	                        transition_in(each_blocks[i], 1);
	                        each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	                    }
	                }
	                group_outros();
	                for(i = each_value.length; i < each_blocks.length; i += 1){
	                    out(i);
	                }
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            for(let i = 0; i < each_value.length; i += 1){
	                transition_in(each_blocks[i]);
	            }
	            current = true;
	        },
	        o: function outro(local) {
	            each_blocks = each_blocks.filter(Boolean);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                transition_out(each_blocks[i]);
	            }
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	                detach_dev(each_1_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$k.name,
	        type: "if",
	        source: "(136:0) {#if folios.length}",
	        ctx
	    });
	    return block;
	}
	// (167:0) {#if aptk=="ylz-vny"}
	function create_if_block_4$4(ctx) {
	    let br;
	    let t_value = _("包含聲聞戒律，在家居士閱讀應有充份理由。") + "";
	    let t;
	    const block = {
	        c: function create() {
	            br = element("br");
	            t = text(t_value);
	            add_location(br, file$D, 167, 0, 5671);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, br, anchor);
	            insert_dev(target, t, anchor);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(br);
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_4$4.name,
	        type: "if",
	        source: "(167:0) {#if aptk==\\\"ylz-vny\\\"}",
	        ctx
	    });
	    return block;
	}
	// (137:0) {#if downloading}
	function create_if_block_3$4(ctx) {
	    let t0;
	    let t1;
	    let span;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            t0 = text(/*downloading*/ ctx[4]);
	            t1 = space();
	            span = element("span");
	            span.textContent = "Cancel";
	            attr_dev(span, "aria-hidden", "true");
	            add_location(span, file$D, 137, 14, 4537);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t0, anchor);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, span, anchor);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*CancelDownloadBook*/ ctx[10](), false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*downloading*/ 16) set_data_dev(t0, /*downloading*/ ctx[4]);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_3$4.name,
	        type: "if",
	        source: "(137:0) {#if downloading}",
	        ctx
	    });
	    return block;
	}
	// (146:0) {#if $vip=='YAP' && !downloading && samesutra($activefolioid,folioid) && getAllFolio(usePtk(aptk) ,folioid).length>1 }
	function create_if_block_2$6(ctx) {
	    let span;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span = element("span");
	            span.textContent = "Download All";
	            attr_dev(span, "aria-hidden", "true");
	            add_location(span, file$D, 146, 0, 4997);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", function() {
	                    if (is_function(/*downloadBook*/ ctx[11](/*folioid*/ ctx[33]))) /*downloadBook*/ ctx[11](/*folioid*/ ctx[33]).apply(this, arguments);
	                }, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_2$6.name,
	        type: "if",
	        source: "(146:0) {#if $vip=='YAP' && !downloading && samesutra($activefolioid,folioid) && getAllFolio(usePtk(aptk) ,folioid).length>1 }",
	        ctx
	    });
	    return block;
	}
	// (151:0) {#if $folioincache[getFolioId(par)] || $online}
	function create_if_block_1$c(ctx) {
	    let span;
	    let t0_value = /*getFolioName*/ ctx[13](/*par*/ ctx[37]) + "";
	    let t0;
	    let t1;
	    let favoritebuttons;
	    let current;
	    let mounted;
	    let dispose;
	    function click_handler_6() {
	        return /*click_handler_6*/ ctx[24](/*par*/ ctx[37]);
	    }
	    favoritebuttons = new Favoritebuttons({
	        props: {
	            folioid: /*getFolioId*/ ctx[14](/*par*/ ctx[37]),
	            closePopup: /*closePopup*/ ctx[0]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            span = element("span");
	            t0 = text(t0_value);
	            t1 = space();
	            create_component(favoritebuttons.$$.fragment);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "parallelfolio");
	            toggle_class(span, "dimmed", !/*$folioincache*/ ctx[7][/*getFolioId*/ ctx[14](/*par*/ ctx[37])]);
	            toggle_class(span, "selecteditem", /*$activefolioid*/ ctx[8] == /*getFolioId*/ ctx[14](/*par*/ ctx[37]));
	            add_location(span, file$D, 151, 0, 5191);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t0);
	            insert_dev(target, t1, anchor);
	            mount_component(favoritebuttons, target, anchor);
	            current = true;
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler_6, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if ((!current || dirty[0] & /*folios*/ 8) && t0_value !== (t0_value = /*getFolioName*/ ctx[13](/*par*/ ctx[37]) + "")) set_data_dev(t0, t0_value);
	            if (!current || dirty[0] & /*$folioincache, getFolioId, folios*/ 16520) {
	                toggle_class(span, "dimmed", !/*$folioincache*/ ctx[7][/*getFolioId*/ ctx[14](/*par*/ ctx[37])]);
	            }
	            if (!current || dirty[0] & /*$activefolioid, getFolioId, folios*/ 16648) {
	                toggle_class(span, "selecteditem", /*$activefolioid*/ ctx[8] == /*getFolioId*/ ctx[14](/*par*/ ctx[37]));
	            }
	            const favoritebuttons_changes = {};
	            if (dirty[0] & /*folios*/ 8) favoritebuttons_changes.folioid = /*getFolioId*/ ctx[14](/*par*/ ctx[37]);
	            if (dirty[0] & /*closePopup*/ 1) favoritebuttons_changes.closePopup = /*closePopup*/ ctx[0];
	            favoritebuttons.$set(favoritebuttons_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(favoritebuttons.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(favoritebuttons.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	                detach_dev(t1);
	            }
	            destroy_component(favoritebuttons, detaching);
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$c.name,
	        type: "if",
	        source: "(151:0) {#if $folioincache[getFolioId(par)] || $online}",
	        ctx
	    });
	    return block;
	}
	// (150:0) {#each pars as par}
	function create_each_block_1$3(ctx) {
	    let show_if = /*$folioincache*/ ctx[7][/*getFolioId*/ ctx[14](/*par*/ ctx[37])] || /*$online*/ ctx[6];
	    let if_block_anchor;
	    let current;
	    let if_block = show_if && create_if_block_1$c(ctx);
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*$folioincache, folios, $online*/ 200) show_if = /*$folioincache*/ ctx[7][/*getFolioId*/ ctx[14](/*par*/ ctx[37])] || /*$online*/ ctx[6];
	            if (show_if) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                    if (dirty[0] & /*$folioincache, folios, $online*/ 200) {
	                        transition_in(if_block, 1);
	                    }
	                } else {
	                    if_block = create_if_block_1$c(ctx);
	                    if_block.c();
	                    transition_in(if_block, 1);
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                group_outros();
	                transition_out(if_block, 1, 1, ()=>{
	                    if_block = null;
	                });
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block_1$3.name,
	        type: "each",
	        source: "(150:0) {#each pars as par}",
	        ctx
	    });
	    return block;
	}
	// (142:0) {#key $tosim}
	function create_key_block$9(ctx) {
	    let span;
	    let t0_value = /*getFolioName*/ ctx[13](/*nfolio*/ ctx[32]) + "";
	    let t0;
	    let t1;
	    let show_if = /*$vip*/ ctx[9] == 'YAP' && !/*downloading*/ ctx[4] && /*samesutra*/ ctx[15](/*$activefolioid*/ ctx[8], /*folioid*/ ctx[33]) && getAllFolio(usePtk(/*aptk*/ ctx[1]), /*folioid*/ ctx[33]).length > 1;
	    let t2;
	    let favoritebuttons;
	    let t3;
	    let each_1_anchor;
	    let current;
	    let mounted;
	    let dispose;
	    function click_handler_5() {
	        return /*click_handler_5*/ ctx[23](/*nfolio*/ ctx[32]);
	    }
	    let if_block = show_if && create_if_block_2$6(ctx);
	    favoritebuttons = new Favoritebuttons({
	        props: {
	            folioid: /*folioid*/ ctx[33],
	            closePopup: /*closePopup*/ ctx[0]
	        },
	        $$inline: true
	    });
	    let each_value_1 = ensure_array_like_dev(/*pars*/ ctx[34]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value_1.length; i += 1){
	        each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
	    }
	    const out = (i)=>transition_out(each_blocks[i], 1, 1, ()=>{
	            each_blocks[i] = null;
	        });
	    const block = {
	        c: function create() {
	            span = element("span");
	            t0 = text(t0_value);
	            t1 = space();
	            if (if_block) if_block.c();
	            t2 = space();
	            create_component(favoritebuttons.$$.fragment);
	            t3 = space();
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            each_1_anchor = empty();
	            attr_dev(span, "aria-hidden", "true");
	            toggle_class(span, "dimmed", !/*$folioincache*/ ctx[7][/*folioid*/ ctx[33]]);
	            toggle_class(span, "selecteditem", /*samesutra*/ ctx[15](/*$activefolioid*/ ctx[8], /*folioid*/ ctx[33]));
	            add_location(span, file$D, 142, 0, 4687);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t0);
	            insert_dev(target, t1, anchor);
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, t2, anchor);
	            mount_component(favoritebuttons, target, anchor);
	            insert_dev(target, t3, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, each_1_anchor, anchor);
	            current = true;
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler_5, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if ((!current || dirty[0] & /*folios*/ 8) && t0_value !== (t0_value = /*getFolioName*/ ctx[13](/*nfolio*/ ctx[32]) + "")) set_data_dev(t0, t0_value);
	            if (!current || dirty[0] & /*$folioincache, folios*/ 136) {
	                toggle_class(span, "dimmed", !/*$folioincache*/ ctx[7][/*folioid*/ ctx[33]]);
	            }
	            if (!current || dirty[0] & /*samesutra, $activefolioid, folios*/ 33032) {
	                toggle_class(span, "selecteditem", /*samesutra*/ ctx[15](/*$activefolioid*/ ctx[8], /*folioid*/ ctx[33]));
	            }
	            if (dirty[0] & /*$vip, downloading, $activefolioid, folios, aptk*/ 794) show_if = /*$vip*/ ctx[9] == 'YAP' && !/*downloading*/ ctx[4] && /*samesutra*/ ctx[15](/*$activefolioid*/ ctx[8], /*folioid*/ ctx[33]) && getAllFolio(usePtk(/*aptk*/ ctx[1]), /*folioid*/ ctx[33]).length > 1;
	            if (show_if) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block_2$6(ctx);
	                    if_block.c();
	                    if_block.m(t2.parentNode, t2);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	            const favoritebuttons_changes = {};
	            if (dirty[0] & /*folios*/ 8) favoritebuttons_changes.folioid = /*folioid*/ ctx[33];
	            if (dirty[0] & /*closePopup*/ 1) favoritebuttons_changes.closePopup = /*closePopup*/ ctx[0];
	            favoritebuttons.$set(favoritebuttons_changes);
	            if (dirty[0] & /*getFolioId, folios, closePopup, $folioincache, $activefolioid, selectfolio, getFolioName, $online*/ 29129) {
	                each_value_1 = ensure_array_like_dev(/*pars*/ ctx[34]);
	                let i;
	                for(i = 0; i < each_value_1.length; i += 1){
	                    const child_ctx = get_each_context_1$3(ctx, each_value_1, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                        transition_in(each_blocks[i], 1);
	                    } else {
	                        each_blocks[i] = create_each_block_1$3(child_ctx);
	                        each_blocks[i].c();
	                        transition_in(each_blocks[i], 1);
	                        each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	                    }
	                }
	                group_outros();
	                for(i = each_value_1.length; i < each_blocks.length; i += 1){
	                    out(i);
	                }
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(favoritebuttons.$$.fragment, local);
	            for(let i = 0; i < each_value_1.length; i += 1){
	                transition_in(each_blocks[i]);
	            }
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(favoritebuttons.$$.fragment, local);
	            each_blocks = each_blocks.filter(Boolean);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                transition_out(each_blocks[i]);
	            }
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	                detach_dev(t1);
	                detach_dev(t2);
	                detach_dev(t3);
	                detach_dev(each_1_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	            destroy_component(favoritebuttons, detaching);
	            destroy_each(each_blocks, detaching);
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$9.name,
	        type: "key",
	        source: "(142:0) {#key $tosim}",
	        ctx
	    });
	    return block;
	}
	// (140:0) {#each folios as [nfolio,folioid,pars]}
	function create_each_block$h(ctx) {
	    let div;
	    let previous_key = /*$tosim*/ ctx[5];
	    let t;
	    let current;
	    let key_block = create_key_block$9(ctx);
	    const block = {
	        c: function create() {
	            div = element("div");
	            key_block.c();
	            t = space();
	            attr_dev(div, "class", "book");
	            add_location(div, file$D, 140, 0, 4654);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            key_block.m(div, null);
	            append_dev(div, t);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*$tosim*/ 32 && safe_not_equal(previous_key, previous_key = /*$tosim*/ ctx[5])) {
	                group_outros();
	                transition_out(key_block, 1, 1, noop);
	                check_outros();
	                key_block = create_key_block$9(ctx);
	                key_block.c();
	                transition_in(key_block, 1);
	                key_block.m(div, t);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(key_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(key_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            key_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$h.name,
	        type: "each",
	        source: "(140:0) {#each folios as [nfolio,folioid,pars]}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$F(ctx) {
	    let div0;
	    let span0;
	    let t1;
	    let span1;
	    let t3;
	    let span2;
	    let t4_value = _("懺儀", /*$tosim*/ ctx[5]) + "";
	    let t4;
	    let t5;
	    let span3;
	    let t6_value = _("聲聞", /*$tosim*/ ctx[5]) + "";
	    let t6;
	    let t7;
	    let span4;
	    let t9;
	    let current_block_type_index;
	    let if_block;
	    let t10;
	    let div1;
	    let endmarker;
	    let current;
	    let mounted;
	    let dispose;
	    const if_block_creators = [
	        create_if_block$k,
	        create_else_block$9
	    ];
	    const if_blocks = [];
	    function select_block_type(ctx, dirty) {
	        if (/*folios*/ ctx[3].length) return 0;
	        return 1;
	    }
	    current_block_type_index = select_block_type(ctx);
	    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div0 = element("div");
	            span0 = element("span");
	            span0.textContent = "唯名";
	            t1 = space();
	            span1 = element("span");
	            span1.textContent = "唯心";
	            t3 = space();
	            span2 = element("span");
	            t4 = text(t4_value);
	            t5 = space();
	            span3 = element("span");
	            t6 = text(t6_value);
	            t7 = space();
	            span4 = element("span");
	            span4.textContent = "戒律";
	            t9 = space();
	            if_block.c();
	            t10 = space();
	            div1 = element("div");
	            create_component(endmarker.$$.fragment);
	            attr_dev(span0, "aria-hidden", "true");
	            attr_dev(span0, "class", "clickable");
	            toggle_class(span0, "selected", /*aptk*/ ctx[1] == "ylz-prjn");
	            add_location(span0, file$D, 129, 4, 3847);
	            attr_dev(span1, "aria-hidden", "true");
	            attr_dev(span1, "class", "clickable");
	            toggle_class(span1, "selected", /*aptk*/ ctx[1] == "ylz-tg");
	            add_location(span1, file$D, 130, 4, 3970);
	            attr_dev(span2, "aria-hidden", "true");
	            attr_dev(span2, "class", "clickable");
	            toggle_class(span2, "selected", /*aptk*/ ctx[1] == "ylz-rite");
	            add_location(span2, file$D, 131, 4, 4089);
	            attr_dev(span3, "aria-hidden", "true");
	            attr_dev(span3, "class", "clickable");
	            toggle_class(span3, "selected", /*aptk*/ ctx[1] == "ylz-svk");
	            add_location(span3, file$D, 132, 4, 4226);
	            attr_dev(span4, "aria-hidden", "true");
	            attr_dev(span4, "class", "clickable");
	            toggle_class(span4, "selected", /*aptk*/ ctx[1] == "ylz-vny");
	            add_location(span4, file$D, 133, 4, 4361);
	            attr_dev(div0, "class", "tabs");
	            add_location(div0, file$D, 128, 0, 3824);
	            attr_dev(div1, "class", "bodytext");
	            add_location(div1, file$D, 171, 0, 5723);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div0, anchor);
	            append_dev(div0, span0);
	            append_dev(div0, t1);
	            append_dev(div0, span1);
	            append_dev(div0, t3);
	            append_dev(div0, span2);
	            append_dev(span2, t4);
	            append_dev(div0, t5);
	            append_dev(div0, span3);
	            append_dev(span3, t6);
	            append_dev(div0, t7);
	            append_dev(div0, span4);
	            insert_dev(target, t9, anchor);
	            if_blocks[current_block_type_index].m(target, anchor);
	            insert_dev(target, t10, anchor);
	            insert_dev(target, div1, anchor);
	            mount_component(endmarker, div1, null);
	            current = true;
	            if (!mounted) {
	                dispose = [
	                    listen_dev(span0, "click", /*click_handler*/ ctx[18], false, false, false, false),
	                    listen_dev(span1, "click", /*click_handler_1*/ ctx[19], false, false, false, false),
	                    listen_dev(span2, "click", /*click_handler_2*/ ctx[20], false, false, false, false),
	                    listen_dev(span3, "click", /*click_handler_3*/ ctx[21], false, false, false, false),
	                    listen_dev(span4, "click", /*click_handler_4*/ ctx[22], false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (!current || dirty[0] & /*aptk*/ 2) {
	                toggle_class(span0, "selected", /*aptk*/ ctx[1] == "ylz-prjn");
	            }
	            if (!current || dirty[0] & /*aptk*/ 2) {
	                toggle_class(span1, "selected", /*aptk*/ ctx[1] == "ylz-tg");
	            }
	            if ((!current || dirty[0] & /*$tosim*/ 32) && t4_value !== (t4_value = _("懺儀", /*$tosim*/ ctx[5]) + "")) set_data_dev(t4, t4_value);
	            if (!current || dirty[0] & /*aptk*/ 2) {
	                toggle_class(span2, "selected", /*aptk*/ ctx[1] == "ylz-rite");
	            }
	            if ((!current || dirty[0] & /*$tosim*/ 32) && t6_value !== (t6_value = _("聲聞", /*$tosim*/ ctx[5]) + "")) set_data_dev(t6, t6_value);
	            if (!current || dirty[0] & /*aptk*/ 2) {
	                toggle_class(span3, "selected", /*aptk*/ ctx[1] == "ylz-svk");
	            }
	            if (!current || dirty[0] & /*aptk*/ 2) {
	                toggle_class(span4, "selected", /*aptk*/ ctx[1] == "ylz-vny");
	            }
	            let previous_block_index = current_block_type_index;
	            current_block_type_index = select_block_type(ctx);
	            if (current_block_type_index === previous_block_index) {
	                if_blocks[current_block_type_index].p(ctx, dirty);
	            } else {
	                group_outros();
	                transition_out(if_blocks[previous_block_index], 1, 1, ()=>{
	                    if_blocks[previous_block_index] = null;
	                });
	                check_outros();
	                if_block = if_blocks[current_block_type_index];
	                if (!if_block) {
	                    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	                    if_block.c();
	                } else {
	                    if_block.p(ctx, dirty);
	                }
	                transition_in(if_block, 1);
	                if_block.m(t10.parentNode, t10);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div0);
	                detach_dev(t9);
	                detach_dev(t10);
	                detach_dev(div1);
	            }
	            if_blocks[current_block_type_index].d(detaching);
	            destroy_component(endmarker);
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$F.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$F($$self, $$props, $$invalidate) {
	    let $tosim;
	    let $online;
	    let $folioincache;
	    let $activefolioid;
	    let $vip;
	    validate_store(tosim, 'tosim');
	    component_subscribe($$self, tosim, ($$value)=>$$invalidate(5, $tosim = $$value));
	    validate_store(online, 'online');
	    component_subscribe($$self, online, ($$value)=>$$invalidate(6, $online = $$value));
	    validate_store(folioincache, 'folioincache');
	    component_subscribe($$self, folioincache, ($$value)=>$$invalidate(7, $folioincache = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(8, $activefolioid = $$value));
	    validate_store(vip, 'vip');
	    component_subscribe($$self, vip, ($$value)=>$$invalidate(9, $vip = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Foliolist', slots, []);
	    let { thetab } = $$props;
	    let { closePopup = function() {} } = $$props;
	    let downloadmessage = '';
	    let folios = [];
	    let canceldownload = false, downloading = '';
	    const texttypeOf = (prefix)=>{
	        if (prefix.slice(0, 3) == 'agm' || prefix == 'lastword') return 1; //聲聞經
	        if (prefix.slice(0, 5) == 'vnybs') return 4; //大乘律
	        if (prefix.slice(0, 3) == 'vny') return 3; //聲聞律
	        return 2; //大乘經
	    };
	    const openptk = async (name)=>{
	        const res = await downloadToCache(CacheName, name + '.ptk', (msg)=>{
	            $$invalidate(2, downloadmessage = name + '.ptk ' + msg);
	        });
	        const buf = await res.arrayBuffer();
	        const ptk = await openPtk(name, new Uint8Array(buf));
	        enableAccelon23Features(ptk);
	        return ptk;
	    };
	    const ptknameFromFolioId = ()=>{
	        const folioid = $activefolioid;
	        let ptkname = "ylz-prjn";
	        const ptks = poolGetAll();
	        for(let i = 0; i < ptks.length; i++){
	            const folio = ptks[i].defines.folio;
	            if (!folio) continue;
	            if (~folio.fields.id.values.indexOf(folioid)) {
	                ptkname = ptks[i].name;
	            }
	        }
	        return ptkname;
	    };
	    let aptk = ptknameFromFolioId();
	    const getFolioList = async (aptk)=>{
	        const cachedPtks = await ptkInCache$1();
	        const at = cachedPtks.indexOf(aptk);
	        if (!~at) {
	            $$invalidate(3, folios = []);
	            return;
	        }
	        const ptk = await openptk(aptk);
	        const folio = ptk.defines.folio;
	        const out = [];
	        for(let i = 0; i < folio.linepos.length; i++){
	            const id = folio.fields.id.values[i];
	            const endingnumber = id.match(/(\d+)$/);
	            const at = id.indexOf('_');
	            ~at ? id.slice(0, at) : id;
	            if (!~at && (!endingnumber || endingnumber[1] == '1')) {
	                //only show book without _ and not ends with >2
	                //const tt=texttypeOf(bkprefix);
	                //if (texttype&& tt!==texttype) continue;
	                out.push([
	                    i,
	                    id,
	                    parallelFolios(ptk, id)
	                ]);
	            }
	        }
	        $$invalidate(3, folios = out);
	    };
	    const CancelDownloadBook = ()=>{
	        canceldownload = true;
	    };
	    const downloadBook = async function(folioid) {
	        const items = getAllFolio(usePtk(aptk), folioid);
	        //if (items.length<2) return; 
	        for (let item of items){
	            const src = item + '.zip';
	            console.log('downloading', src);
	            await downloadToCache(CacheName, "folio/" + src, (msg)=>{
	                $$invalidate(4, downloading = src + " " + msg);
	                console.log(msg);
	            });
	        }
	        canceldownload = false;
	        $$invalidate(4, downloading = '');
	    };
	    const selectfolio = (nfolio)=>{
	        const folio = usePtk(aptk).defines.folio;
	        const folioid = folio.fields.id.values[nfolio];
	        activePtk.set(aptk);
	        if ($folioincache[folioid] || $online) {
	            stopAudio();
	            loadFolio(folioid, function() {
	                $$invalidate(17, thetab = 'toc');
	                activepb.set('1');
	            });
	            closePopup();
	        }
	    };
	    const getFolioName = (nfolio)=>{
	        const folio = usePtk(aptk).defines.folio;
	        return _(folio._innertext.get(nfolio), $tosim);
	    };
	    const getFolioId = (nfolio)=>{
	        const folio = usePtk(aptk).defines.folio;
	        return folio.fields.id.values[nfolio];
	    };
	    const samesutra = (f1, f2)=>{
	        return f1.replace(/\d+$/, '') == f2.replace(/\d+$/, '');
	    };
	    let opening = false;
	    const installptk = async (name)=>{
	        if (opening) return;
	        opening = true;
	        $$invalidate(2, downloadmessage = 'try to download ' + name + '.ptk');
	        const aptk = await openptk(name);
	        opening = false;
	        $$invalidate(2, downloadmessage = '');
	        getFolioList(name);
	        return aptk;
	    };
	    $$self.$$.on_mount.push(function() {
	        if (thetab === undefined && !('thetab' in $$props || $$self.$$.bound[$$self.$$.props['thetab']])) {
	            console_1$2.warn("<Foliolist> was created without expected prop 'thetab'");
	        }
	    });
	    const writable_props = [
	        'thetab',
	        'closePopup'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<Foliolist> was created with unknown prop '${key}'`);
	    });
	    const click_handler = ()=>$$invalidate(1, aptk = "ylz-prjn");
	    const click_handler_1 = ()=>$$invalidate(1, aptk = "ylz-tg");
	    const click_handler_2 = ()=>$$invalidate(1, aptk = "ylz-rite");
	    const click_handler_3 = ()=>$$invalidate(1, aptk = "ylz-svk");
	    const click_handler_4 = ()=>$$invalidate(1, aptk = "ylz-vny");
	    const click_handler_5 = (nfolio)=>selectfolio(nfolio);
	    const click_handler_6 = (par)=>selectfolio(par);
	    const click_handler_7 = ()=>installptk(aptk);
	    $$self.$$set = ($$props)=>{
	        if ('thetab' in $$props) $$invalidate(17, thetab = $$props.thetab);
	        if ('closePopup' in $$props) $$invalidate(0, closePopup = $$props.closePopup);
	    };
	    $$self.$capture_state = ()=>({
	            Favoritebuttons,
	            loadFolio,
	            downloadToCache,
	            CacheName,
	            thetab,
	            activefolioid,
	            vip,
	            tosim,
	            parallelFolios,
	            stopAudio,
	            folioincache,
	            online,
	            activepb,
	            activePtk,
	            Endmarker,
	            ptkInCache: ptkInCache$1,
	            _,
	            usePtk,
	            openPtk,
	            poolGetAll,
	            enableAccelon23Features,
	            getAllFolio,
	            closePopup,
	            downloadmessage,
	            folios,
	            canceldownload,
	            downloading,
	            texttypeOf,
	            openptk,
	            ptknameFromFolioId,
	            aptk,
	            getFolioList,
	            CancelDownloadBook,
	            downloadBook,
	            selectfolio,
	            getFolioName,
	            getFolioId,
	            samesutra,
	            opening,
	            installptk,
	            $tosim,
	            $online,
	            $folioincache,
	            $activefolioid,
	            $vip
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('thetab' in $$props) $$invalidate(17, thetab = $$props.thetab);
	        if ('closePopup' in $$props) $$invalidate(0, closePopup = $$props.closePopup);
	        if ('downloadmessage' in $$props) $$invalidate(2, downloadmessage = $$props.downloadmessage);
	        if ('folios' in $$props) $$invalidate(3, folios = $$props.folios);
	        if ('canceldownload' in $$props) canceldownload = $$props.canceldownload;
	        if ('downloading' in $$props) $$invalidate(4, downloading = $$props.downloading);
	        if ('aptk' in $$props) $$invalidate(1, aptk = $$props.aptk);
	        if ('opening' in $$props) opening = $$props.opening;
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty[0] & /*aptk*/ 2) {
	            getFolioList(aptk);
	        }
	    };
	    return [
	        closePopup,
	        aptk,
	        downloadmessage,
	        folios,
	        downloading,
	        $tosim,
	        $online,
	        $folioincache,
	        $activefolioid,
	        $vip,
	        CancelDownloadBook,
	        downloadBook,
	        selectfolio,
	        getFolioName,
	        getFolioId,
	        samesutra,
	        installptk,
	        thetab,
	        click_handler,
	        click_handler_1,
	        click_handler_2,
	        click_handler_3,
	        click_handler_4,
	        click_handler_5,
	        click_handler_6,
	        click_handler_7
	    ];
	}
	class Foliolist extends SvelteComponentDev {
	    get thetab() {
	        throw new Error("<Foliolist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set thetab(value) {
	        throw new Error("<Foliolist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get closePopup() {
	        throw new Error("<Foliolist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set closePopup(value) {
	        throw new Error("<Foliolist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$F, create_fragment$F, safe_not_equal, {
	            thetab: 17,
	            closePopup: 0
	        }, null, [
	            -1,
	            -1
	        ]);
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Foliolist",
	            options,
	            id: create_fragment$F.name
	        });
	    }
	}

	function handle(node) {
	    const onDown = getOnDown(node);
	    node.addEventListener("touchstart", onDown);
	    node.addEventListener("mousedown", onDown);
	    return {
	        destroy () {
	            node.removeEventListener("touchstart", onDown);
	            node.removeEventListener("mousedown", onDown);
	        }
	    };
	}
	function getOnDown(node) {
	    const onMove = getOnMove(node);
	    return function(e) {
	        e.preventDefault();
	        node.dispatchEvent(new CustomEvent("dragstart"));
	        const moveevent = "touches" in e ? "touchmove" : "mousemove";
	        const upevent = "touches" in e ? "touchend" : "mouseup";
	        document.addEventListener(moveevent, onMove);
	        document.addEventListener(upevent, onUp);
	        function onUp(e) {
	            e.stopPropagation();
	            document.removeEventListener(moveevent, onMove);
	            document.removeEventListener(upevent, onUp);
	            node.dispatchEvent(new CustomEvent("dragend"));
	        }
	    };
	}
	function getOnMove(node) {
	    const track = node.parentNode;
	    return function(e) {
	        const { left, width } = track.getBoundingClientRect();
	        const clickOffset = "touches" in e ? e.touches[0].clientX : e.clientX;
	        const clickPos = Math.min(Math.max((clickOffset - left) / width, 0), 1) || 0;
	        node.dispatchEvent(new CustomEvent("drag", {
	            detail: clickPos
	        }));
	    };
	}

	const file$C = "src\\3rd\\thumb.svelte";
	function create_fragment$E(ctx) {
	    let div1;
	    let div0;
	    let div1_style_value;
	    let current;
	    let mounted;
	    let dispose;
	    const default_slot_template = /*#slots*/ ctx[4].default;
	    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	    const block = {
	        c: function create() {
	            div1 = element("div");
	            div0 = element("div");
	            if (default_slot) default_slot.c();
	            attr_dev(div0, "class", "thumb-content svelte-8w8x88");
	            toggle_class(div0, "active", /*active*/ ctx[1]);
	            add_location(div0, file$C, 8, 2, 304);
	            attr_dev(div1, "class", "thumb svelte-8w8x88");
	            attr_dev(div1, "style", div1_style_value = `left: ${ctx[0] * 100}%;`);
	            add_location(div1, file$C, 1, 0, 59);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div1, anchor);
	            append_dev(div1, div0);
	            if (default_slot) {
	                default_slot.m(div0, null);
	            }
	            current = true;
	            if (!mounted) {
	                dispose = [
	                    action_destroyer(handle.call(null, div1)),
	                    listen_dev(div1, "dragstart", /*dragstart_handler*/ ctx[5], false, false, false, false),
	                    listen_dev(div1, "drag", /*drag_handler*/ ctx[6], false, false, false, false),
	                    listen_dev(div1, "dragend", /*dragend_handler*/ ctx[7], false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (default_slot) {
	                if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
	                    update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[3]) : get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null), null);
	                }
	            }
	            if (!current || dirty & /*active*/ 2) {
	                toggle_class(div0, "active", /*active*/ ctx[1]);
	            }
	            if (!current || dirty & /*pos*/ 1 && div1_style_value !== (div1_style_value = `left: ${ctx[0] * 100}%;`)) {
	                attr_dev(div1, "style", div1_style_value);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(default_slot, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(default_slot, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div1);
	            }
	            if (default_slot) default_slot.d(detaching);
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$E.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$E($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Thumb', slots, [
	        'default'
	    ]);
	    const dispatch = createEventDispatcher();
	    let active;
	    let { pos } = $$props;
	    $$self.$$.on_mount.push(function() {
	        if (pos === undefined && !('pos' in $$props || $$self.$$.bound[$$self.$$.props['pos']])) {
	            console.warn("<Thumb> was created without expected prop 'pos'");
	        }
	    });
	    const writable_props = [
	        'pos'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Thumb> was created with unknown prop '${key}'`);
	    });
	    const dragstart_handler = ()=>($$invalidate(1, active = true), dispatch('active', true));
	    const drag_handler = ({ detail: v })=>$$invalidate(0, pos = v);
	    const dragend_handler = ()=>($$invalidate(1, active = false), dispatch('active', false));
	    $$self.$$set = ($$props)=>{
	        if ('pos' in $$props) $$invalidate(0, pos = $$props.pos);
	        if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	    };
	    $$self.$capture_state = ()=>({
	            createEventDispatcher,
	            handle,
	            dispatch,
	            pos,
	            active
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('pos' in $$props) $$invalidate(0, pos = $$props.pos);
	        if ('active' in $$props) $$invalidate(1, active = $$props.active);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        pos,
	        active,
	        dispatch,
	        $$scope,
	        slots,
	        dragstart_handler,
	        drag_handler,
	        dragend_handler
	    ];
	}
	class Thumb extends SvelteComponentDev {
	    get pos() {
	        throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set pos(value) {
	        throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$E, create_fragment$E, safe_not_equal, {
	            pos: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Thumb",
	            options,
	            id: create_fragment$E.name
	        });
	    }
	}

	const { console: console_1$1 } = globals;
	const file$B = "src\\3rd\\rangeslider.svelte";
	const get_caption_slot_changes = (dirty)=>({});
	const get_caption_slot_context = (ctx)=>({});
	const get_left_slot_changes = (dirty)=>({});
	const get_left_slot_context = (ctx)=>({});
	// (82:12)          
	function fallback_block_1(ctx) {
	    let div;
	    const block = {
	        c: function create() {
	            div = element("div");
	            attr_dev(div, "class", "thumb svelte-giohkn");
	            add_location(div, file$B, 82, 8, 2024);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	        },
	        p: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: fallback_block_1.name,
	        type: "fallback",
	        source: "(82:12)          ",
	        ctx
	    });
	    return block;
	}
	// (81:22)        
	function fallback_block$1(ctx) {
	    let current;
	    const default_slot_template = /*#slots*/ ctx[11].default;
	    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);
	    const default_slot_or_fallback = default_slot || fallback_block_1(ctx);
	    const block = {
	        c: function create() {
	            if (default_slot_or_fallback) default_slot_or_fallback.c();
	        },
	        m: function mount(target, anchor) {
	            if (default_slot_or_fallback) {
	                default_slot_or_fallback.m(target, anchor);
	            }
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (default_slot) {
	                if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
	                    update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[14]) : get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null), null);
	                }
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(default_slot_or_fallback, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(default_slot_or_fallback, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: fallback_block$1.name,
	        type: "fallback",
	        source: "(81:22)        ",
	        ctx
	    });
	    return block;
	}
	// (80:2) <Thumb bind:pos={pos[0]} on:active={({ detail: v }) => active = v}>
	function create_default_slot$7(ctx) {
	    let current;
	    const left_slot_template = /*#slots*/ ctx[11].left;
	    const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[14], get_left_slot_context);
	    const left_slot_or_fallback = left_slot || fallback_block$1(ctx);
	    const block = {
	        c: function create() {
	            if (left_slot_or_fallback) left_slot_or_fallback.c();
	        },
	        m: function mount(target, anchor) {
	            if (left_slot_or_fallback) {
	                left_slot_or_fallback.m(target, anchor);
	            }
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (left_slot) {
	                if (left_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
	                    update_slot_base(left_slot, left_slot_template, ctx, /*$$scope*/ ctx[14], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[14]) : get_slot_changes(left_slot_template, /*$$scope*/ ctx[14], dirty, get_left_slot_changes), get_left_slot_context);
	                }
	            } else {
	                if (left_slot_or_fallback && left_slot_or_fallback.p && (!current || dirty & /*$$scope*/ 16384)) {
	                    left_slot_or_fallback.p(ctx, !current ? -1 : dirty);
	                }
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(left_slot_or_fallback, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(left_slot_or_fallback, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (left_slot_or_fallback) left_slot_or_fallback.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot$7.name,
	        type: "slot",
	        source: "(80:2) <Thumb bind:pos={pos[0]} on:active={({ detail: v }) => active = v}>",
	        ctx
	    });
	    return block;
	}
	function create_fragment$D(ctx) {
	    let div2;
	    let input;
	    let input_value_value;
	    let input_name_value;
	    let t0;
	    let div1;
	    let div0;
	    let t1;
	    let thumb;
	    let updating_pos;
	    let t2;
	    let current;
	    let mounted;
	    let dispose;
	    function thumb_pos_binding(value) {
	        /*thumb_pos_binding*/ ctx[12](value);
	    }
	    let thumb_props = {
	        $$slots: {
	            default: [
	                create_default_slot$7
	            ]
	        },
	        $$scope: {
	            ctx
	        }
	    };
	    if (/*pos*/ ctx[2][0] !== void 0) {
	        thumb_props.pos = /*pos*/ ctx[2][0];
	    }
	    thumb = new Thumb({
	        props: thumb_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(thumb, 'pos', thumb_pos_binding));
	    thumb.$on("active", /*active_handler*/ ctx[13]);
	    const caption_slot_template = /*#slots*/ ctx[11].caption;
	    const caption_slot = create_slot(caption_slot_template, ctx, /*$$scope*/ ctx[14], get_caption_slot_context);
	    const block = {
	        c: function create() {
	            div2 = element("div");
	            input = element("input");
	            t0 = space();
	            div1 = element("div");
	            div0 = element("div");
	            t1 = space();
	            create_component(thumb.$$.fragment);
	            t2 = space();
	            if (caption_slot) caption_slot.c();
	            attr_dev(input, "type", "number");
	            input.value = input_value_value = /*value*/ ctx[0][0];
	            attr_dev(input, "name", input_name_value = /*name*/ ctx[1][0]);
	            attr_dev(input, "class", "svelte-giohkn");
	            add_location(input, file$B, 73, 0, 1739);
	            attr_dev(div0, "class", "progress svelte-giohkn");
	            attr_dev(div0, "style", /*progress*/ ctx[4]);
	            add_location(div0, file$B, 75, 2, 1855);
	            attr_dev(div1, "aria-hidden", "true");
	            attr_dev(div1, "class", "track svelte-giohkn");
	            add_location(div1, file$B, 74, 0, 1795);
	            add_location(div2, file$B, 72, 0, 1733);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div2, anchor);
	            append_dev(div2, input);
	            append_dev(div2, t0);
	            append_dev(div2, div1);
	            append_dev(div1, div0);
	            append_dev(div1, t1);
	            mount_component(thumb, div1, null);
	            append_dev(div1, t2);
	            if (caption_slot) {
	                caption_slot.m(div1, null);
	            }
	            current = true;
	            if (!mounted) {
	                dispose = listen_dev(div1, "click", /*adjust*/ ctx[5], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (!current || dirty & /*value*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[0][0]) && input.value !== input_value_value) {
	                prop_dev(input, "value", input_value_value);
	            }
	            if (!current || dirty & /*name*/ 2 && input_name_value !== (input_name_value = /*name*/ ctx[1][0])) {
	                attr_dev(input, "name", input_name_value);
	            }
	            if (!current || dirty & /*progress*/ 16) {
	                attr_dev(div0, "style", /*progress*/ ctx[4]);
	            }
	            const thumb_changes = {};
	            if (dirty & /*$$scope*/ 16384) {
	                thumb_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            if (!updating_pos && dirty & /*pos*/ 4) {
	                updating_pos = true;
	                thumb_changes.pos = /*pos*/ ctx[2][0];
	                add_flush_callback(()=>updating_pos = false);
	            }
	            thumb.$set(thumb_changes);
	            if (caption_slot) {
	                if (caption_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
	                    update_slot_base(caption_slot, caption_slot_template, ctx, /*$$scope*/ ctx[14], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[14]) : get_slot_changes(caption_slot_template, /*$$scope*/ ctx[14], dirty, get_caption_slot_changes), get_caption_slot_context);
	                }
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(thumb.$$.fragment, local);
	            transition_in(caption_slot, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(thumb.$$.fragment, local);
	            transition_out(caption_slot, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div2);
	            }
	            destroy_component(thumb);
	            if (caption_slot) caption_slot.d(detaching);
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$D.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function checkPos(pos) {
	    return [
	        Math.min(...pos),
	        Math.max(...pos)
	    ];
	}
	function instance$D($$self, $$props, $$invalidate) {
	    let progress;
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Rangeslider', slots, [
	        'default',
	        'left',
	        'caption'
	    ]);
	    const dispatch = createEventDispatcher();
	    let { name = [] } = $$props;
	    let { range = false } = $$props;
	    let { min = 0 } = $$props;
	    let { max = 100 } = $$props;
	    let { step = 1 } = $$props;
	    let { value = [
	        min,
	        max
	    ] } = $$props;
	    let pos = [
	        0,
	        0
	    ];
	    let active = false;
	    let { order = false } = $$props;
	    function setValue(pos) {
	        console.log('setvalue', pos);
	        if (!pos || pos.length !== 2 || !Array.isArray(pos)) {
	            pos = [
	                min,
	                max
	            ];
	        }
	        const offset = min % step;
	        const width = max - min;
	        $$invalidate(0, value = pos.map((v)=>min + v * width).map((v)=>Math.round((v - offset) / step) * step + offset));
	        dispatch("input", value);
	    }
	    function setPos(value) {
	        if (!value || value.length !== 2 || !Array.isArray(value)) {
	            value = [
	                min,
	                max
	            ];
	        }
	        $$invalidate(2, pos = value.map((v)=>Math.min(Math.max(v, min), max)).map((v)=>(v - min) / (max - min)));
	    }
	    // $: min, max, clamp(); , causing pb changed when initial
	    function clamp() {
	        setPos(value);
	        setValue(pos);
	    }
	    function adjust(e) {
	        if (e.target.classList[0] == 'progress') {
	            //left
	            setPos([
	                (value[0] || min) - step,
	                value[1]
	            ]);
	            setValue(pos);
	        } else if (e.target.classList[0] == 'track') {
	            //right
	            setPos([
	                (value[0] || min) + step,
	                value[1]
	            ]);
	            setValue(pos);
	        }
	    }
	    const writable_props = [
	        'name',
	        'range',
	        'min',
	        'max',
	        'step',
	        'value',
	        'order'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Rangeslider> was created with unknown prop '${key}'`);
	    });
	    function thumb_pos_binding(value) {
	        if ($$self.$$.not_equal(pos[0], value)) {
	            pos[0] = value;
	            $$invalidate(2, pos), $$invalidate(6, range), $$invalidate(10, order), $$invalidate(3, active);
	        }
	    }
	    const active_handler = ({ detail: v })=>$$invalidate(3, active = v);
	    $$self.$$set = ($$props)=>{
	        if ('name' in $$props) $$invalidate(1, name = $$props.name);
	        if ('range' in $$props) $$invalidate(6, range = $$props.range);
	        if ('min' in $$props) $$invalidate(7, min = $$props.min);
	        if ('max' in $$props) $$invalidate(8, max = $$props.max);
	        if ('step' in $$props) $$invalidate(9, step = $$props.step);
	        if ('value' in $$props) $$invalidate(0, value = $$props.value);
	        if ('order' in $$props) $$invalidate(10, order = $$props.order);
	        if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
	    };
	    $$self.$capture_state = ()=>({
	            createEventDispatcher,
	            Thumb,
	            dispatch,
	            name,
	            range,
	            min,
	            max,
	            step,
	            value,
	            pos,
	            active,
	            order,
	            setValue,
	            setPos,
	            checkPos,
	            clamp,
	            adjust,
	            progress
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('name' in $$props) $$invalidate(1, name = $$props.name);
	        if ('range' in $$props) $$invalidate(6, range = $$props.range);
	        if ('min' in $$props) $$invalidate(7, min = $$props.min);
	        if ('max' in $$props) $$invalidate(8, max = $$props.max);
	        if ('step' in $$props) $$invalidate(9, step = $$props.step);
	        if ('value' in $$props) $$invalidate(0, value = $$props.value);
	        if ('pos' in $$props) $$invalidate(2, pos = $$props.pos);
	        if ('active' in $$props) $$invalidate(3, active = $$props.active);
	        if ('order' in $$props) $$invalidate(10, order = $$props.order);
	        if ('progress' in $$props) $$invalidate(4, progress = $$props.progress);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*range, order, active, pos*/ 1100) {
	            if (range && order && active) $$invalidate(2, pos = checkPos(pos));
	        }
	        if ($$self.$$.dirty & /*active, pos*/ 12) {
	            if (active) setValue(pos);
	        }
	        if ($$self.$$.dirty & /*active, value*/ 9) {
	            if (!active) setPos(value);
	        }
	        if ($$self.$$.dirty & /*range, pos*/ 68) {
	            $$invalidate(4, progress = `
    left: ${range ? Math.min(pos[0], pos[1]) * 100 : 0}%;
    right: ${100 - Math.max(pos[0], range ? pos[1] : pos[0]) * 100 || 100}%;
  `);
	        }
	    };
	    return [
	        value,
	        name,
	        pos,
	        active,
	        progress,
	        adjust,
	        range,
	        min,
	        max,
	        step,
	        order,
	        slots,
	        thumb_pos_binding,
	        active_handler,
	        $$scope
	    ];
	}
	class Rangeslider extends SvelteComponentDev {
	    get name() {
	        throw new Error("<Rangeslider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set name(value) {
	        throw new Error("<Rangeslider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get range() {
	        throw new Error("<Rangeslider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set range(value) {
	        throw new Error("<Rangeslider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get min() {
	        throw new Error("<Rangeslider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set min(value) {
	        throw new Error("<Rangeslider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get max() {
	        throw new Error("<Rangeslider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set max(value) {
	        throw new Error("<Rangeslider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get step() {
	        throw new Error("<Rangeslider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set step(value) {
	        throw new Error("<Rangeslider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get value() {
	        throw new Error("<Rangeslider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set value(value) {
	        throw new Error("<Rangeslider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get order() {
	        throw new Error("<Rangeslider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set order(value) {
	        throw new Error("<Rangeslider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$D, create_fragment$D, safe_not_equal, {
	            name: 1,
	            range: 6,
	            min: 7,
	            max: 8,
	            step: 9,
	            value: 0,
	            order: 10
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Rangeslider",
	            options,
	            id: create_fragment$D.name
	        });
	    }
	}

	const file$A = "src\\3rd\\switch.svelte";
	function get_each_context$g(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[9] = list[i];
	    return child_ctx;
	}
	// (45:0) {:else}
	function create_else_block$8(ctx) {
	    let span2;
	    let span1;
	    let span0;
	    let t0;
	    let t1;
	    let each_value = ensure_array_like_dev(/*options*/ ctx[3]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            span2 = element("span");
	            span1 = element("span");
	            span0 = element("span");
	            t0 = text(/*label*/ ctx[1]);
	            t1 = space();
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            attr_dev(span0, "class", "legend");
	            attr_dev(span0, "id", `label-${ctx[5]}`);
	            add_location(span0, file$A, 51, 4, 1528);
	            attr_dev(span1, "role", "radiogroup");
	            attr_dev(span1, "class", "group-container svelte-jwpg1d");
	            attr_dev(span1, "aria-labelledby", `label-${ctx[5]}`);
	            attr_dev(span1, "id", `group-${ctx[5]}`);
	            add_location(span1, file$A, 46, 4, 1391);
	            attr_dev(span2, "class", "s s--multi svelte-jwpg1d");
	            add_location(span2, file$A, 45, 0, 1361);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span2, anchor);
	            append_dev(span2, span1);
	            append_dev(span1, span0);
	            append_dev(span0, t0);
	            append_dev(span1, t1);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(span1, null);
	                }
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);
	            if (dirty & /*options, uniqueID, value*/ 41) {
	                each_value = ensure_array_like_dev(/*options*/ ctx[3]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$g(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$g(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(span1, null);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span2);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$8.name,
	        type: "else",
	        source: "(45:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (35:29) 
	function create_if_block_1$b(ctx) {
	    let span1;
	    let span0;
	    let t0;
	    let t1;
	    let button;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span1 = element("span");
	            span0 = element("span");
	            t0 = text(/*label*/ ctx[1]);
	            t1 = space();
	            button = element("button");
	            attr_dev(span0, "id", `switch-${ctx[5]}`);
	            add_location(span0, file$A, 36, 4, 1140);
	            attr_dev(button, "role", "switch");
	            attr_dev(button, "aria-checked", /*checked*/ ctx[4]);
	            attr_dev(button, "aria-labelledby", `switch-${ctx[5]}`);
	            attr_dev(button, "class", "svelte-jwpg1d");
	            add_location(button, file$A, 37, 4, 1191);
	            attr_dev(span1, "class", "s s--slider svelte-jwpg1d");
	            add_location(span1, file$A, 35, 0, 1109);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span1, anchor);
	            append_dev(span1, span0);
	            append_dev(span0, t0);
	            append_dev(span1, t1);
	            append_dev(span1, button);
	            if (!mounted) {
	                dispose = listen_dev(button, "click", /*handleClick*/ ctx[6], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);
	            if (dirty & /*checked*/ 16) {
	                attr_dev(button, "aria-checked", /*checked*/ ctx[4]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span1);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$b.name,
	        type: "if",
	        source: "(35:29) ",
	        ctx
	    });
	    return block;
	}
	// (23:0) {#if design == 'inner'}
	function create_if_block$j(ctx) {
	    let div;
	    let span0;
	    let t0;
	    let t1;
	    let button;
	    let span1;
	    let t3;
	    let span2;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            div = element("div");
	            span0 = element("span");
	            t0 = text(/*label*/ ctx[1]);
	            t1 = space();
	            button = element("button");
	            span1 = element("span");
	            span1.textContent = "on";
	            t3 = space();
	            span2 = element("span");
	            span2.textContent = "off";
	            attr_dev(span0, "id", `switch-${ctx[5]}`);
	            attr_dev(span0, "class", "svelte-jwpg1d");
	            add_location(span0, file$A, 24, 4, 810);
	            attr_dev(span1, "class", "svelte-jwpg1d");
	            add_location(span1, file$A, 30, 12, 1013);
	            attr_dev(span2, "class", "svelte-jwpg1d");
	            add_location(span2, file$A, 31, 12, 1041);
	            attr_dev(button, "role", "switch");
	            attr_dev(button, "aria-checked", /*checked*/ ctx[4]);
	            attr_dev(button, "aria-labelledby", `switch-${ctx[5]}`);
	            attr_dev(button, "class", "svelte-jwpg1d");
	            add_location(button, file$A, 25, 4, 861);
	            attr_dev(div, "class", "s s--inner svelte-jwpg1d");
	            add_location(div, file$A, 23, 0, 781);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, span0);
	            append_dev(span0, t0);
	            append_dev(div, t1);
	            append_dev(div, button);
	            append_dev(button, span1);
	            append_dev(button, t3);
	            append_dev(button, span2);
	            if (!mounted) {
	                dispose = listen_dev(button, "click", /*handleClick*/ ctx[6], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);
	            if (dirty & /*checked*/ 16) {
	                attr_dev(button, "aria-checked", /*checked*/ ctx[4]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$j.name,
	        type: "if",
	        source: "(23:0) {#if design == 'inner'}",
	        ctx
	    });
	    return block;
	}
	// (53:8) {#each options as option}
	function create_each_block$g(ctx) {
	    let input;
	    let input_id_value;
	    let input_value_value;
	    let value_has_changed = false;
	    let t0;
	    let label_1;
	    let t1_value = /*option*/ ctx[9] + "";
	    let t1;
	    let t2;
	    let label_1_for_value;
	    let binding_group;
	    let mounted;
	    let dispose;
	    binding_group = init_binding_group(/*$$binding_groups*/ ctx[8][0]);
	    const block = {
	        c: function create() {
	            input = element("input");
	            t0 = space();
	            label_1 = element("label");
	            t1 = text(t1_value);
	            t2 = space();
	            attr_dev(input, "type", "radio");
	            attr_dev(input, "id", input_id_value = `${ctx[9]}-${ctx[5]}`);
	            input.__value = input_value_value = /*option*/ ctx[9];
	            set_input_value(input, input.__value);
	            attr_dev(input, "class", "svelte-jwpg1d");
	            add_location(input, file$A, 53, 12, 1635);
	            attr_dev(label_1, "for", label_1_for_value = `${ctx[9]}-${ctx[5]}`);
	            attr_dev(label_1, "class", "svelte-jwpg1d");
	            add_location(label_1, file$A, 54, 12, 1731);
	            binding_group.p(input);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, input, anchor);
	            input.checked = input.__value === /*value*/ ctx[0];
	            insert_dev(target, t0, anchor);
	            insert_dev(target, label_1, anchor);
	            append_dev(label_1, t1);
	            append_dev(label_1, t2);
	            if (!mounted) {
	                dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[7]);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*options*/ 8 && input_id_value !== (input_id_value = `${ctx[9]}-${ctx[5]}`)) {
	                attr_dev(input, "id", input_id_value);
	            }
	            if (dirty & /*options*/ 8 && input_value_value !== (input_value_value = /*option*/ ctx[9])) {
	                prop_dev(input, "__value", input_value_value);
	                set_input_value(input, input.__value);
	                value_has_changed = true;
	            }
	            if (value_has_changed || dirty & /*value, options*/ 9) {
	                input.checked = input.__value === /*value*/ ctx[0];
	            }
	            if (dirty & /*options*/ 8 && t1_value !== (t1_value = /*option*/ ctx[9] + "")) set_data_dev(t1, t1_value);
	            if (dirty & /*options*/ 8 && label_1_for_value !== (label_1_for_value = `${ctx[9]}-${ctx[5]}`)) {
	                attr_dev(label_1, "for", label_1_for_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(input);
	                detach_dev(t0);
	                detach_dev(label_1);
	            }
	            binding_group.r();
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$g.name,
	        type: "each",
	        source: "(53:8) {#each options as option}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$C(ctx) {
	    let if_block_anchor;
	    function select_block_type(ctx, dirty) {
	        if (/*design*/ ctx[2] == 'inner') return create_if_block$j;
	        if (/*design*/ ctx[2] == 'slider') return create_if_block_1$b;
	        return create_else_block$8;
	    }
	    let current_block_type = select_block_type(ctx);
	    let if_block = current_block_type(ctx);
	    const block = {
	        c: function create() {
	            if_block.c();
	            if_block_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, [dirty]) {
	            if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	                if_block.p(ctx, dirty);
	            } else {
	                if_block.d(1);
	                if_block = current_block_type(ctx);
	                if (if_block) {
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$C.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$C($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Switch', slots, []);
	    let { label } = $$props;
	    let { design = 'inner label' } = $$props;
	    let { options = [] } = $$props;
	    let { value = 'on' } = $$props;
	    let checked = value == 'on';
	    const uniqueID = Math.floor(Math.random() * 100);
	    function handleClick(event) {
	        const target = event.target;
	        const state = target.getAttribute('aria-checked');
	        $$invalidate(4, checked = state === 'true' ? false : true);
	        $$invalidate(0, value = checked === true ? 'on' : 'off');
	    }
	    $$self.$$.on_mount.push(function() {
	        if (label === undefined && !('label' in $$props || $$self.$$.bound[$$self.$$.props['label']])) {
	            console.warn("<Switch> was created without expected prop 'label'");
	        }
	    });
	    const writable_props = [
	        'label',
	        'design',
	        'options',
	        'value'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Switch> was created with unknown prop '${key}'`);
	    });
	    const $$binding_groups = [
	        []
	    ];
	    function input_change_handler() {
	        value = this.__value;
	        $$invalidate(0, value);
	    }
	    $$self.$$set = ($$props)=>{
	        if ('label' in $$props) $$invalidate(1, label = $$props.label);
	        if ('design' in $$props) $$invalidate(2, design = $$props.design);
	        if ('options' in $$props) $$invalidate(3, options = $$props.options);
	        if ('value' in $$props) $$invalidate(0, value = $$props.value);
	    };
	    $$self.$capture_state = ()=>({
	            label,
	            design,
	            options,
	            value,
	            checked,
	            uniqueID,
	            handleClick
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('label' in $$props) $$invalidate(1, label = $$props.label);
	        if ('design' in $$props) $$invalidate(2, design = $$props.design);
	        if ('options' in $$props) $$invalidate(3, options = $$props.options);
	        if ('value' in $$props) $$invalidate(0, value = $$props.value);
	        if ('checked' in $$props) $$invalidate(4, checked = $$props.checked);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        value,
	        label,
	        design,
	        options,
	        checked,
	        uniqueID,
	        handleClick,
	        input_change_handler,
	        $$binding_groups
	    ];
	}
	class Switch extends SvelteComponentDev {
	    get label() {
	        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set label(value) {
	        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get design() {
	        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set design(value) {
	        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get options() {
	        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set options(value) {
	        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get value() {
	        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set value(value) {
	        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$C, create_fragment$C, safe_not_equal, {
	            label: 1,
	            design: 2,
	            options: 3,
	            value: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Switch",
	            options,
	            id: create_fragment$C.name
	        });
	    }
	}

	const downloadicon = `<svg width="32px" height="32px" viewBox="0 0 24 24" fill="none"><path d="M12 16L12 8" stroke="#323232" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M9 13L11.913 15.913V15.913C11.961 15.961 12.039 15.961 12.087 15.913V15.913L15 13" stroke="#323232" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M3 15L3 16L3 19C3 20.1046 3.89543 21 5 21L19 21C20.1046 21 21 20.1046 21 19L21 16L21 15" stroke="#323232" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
	const youtubeicon = `<svg style="margin-bottom:-0.2em" height="4vh" width="4vh" viewBox="0 0 461.001 461.001"><g><path style="fill:#F61C0D;" d="M365.257,67.393H95.744C42.866,67.393,0,110.259,0,163.137v134.728c0,52.878,42.866,95.744,95.744,95.744h269.513c52.878,0,95.744-42.866,95.744-95.744V163.137C461.001,110.259,418.135,67.393,365.257,67.393z M300.506,237.056l-126.06,60.123c-3.359,1.602-7.239-0.847-7.239-4.568V168.607c0-3.774,3.982-6.22,7.348-4.514l126.06,63.881C304.363,229.873,304.298,235.248,300.506,237.056z"/></g></svg>`;
	const githubicon = `<svg width="24" height="24" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>`;

	const file$z = "src\\audio.svelte";
	function get_each_context$f(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[38] = list[i];
	    child_ctx[40] = i;
	    return child_ctx;
	}
	// (114:0) {#if idx&& !$playing && media.youtube}
	function create_if_block_7$1(ctx) {
	    let span;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span = element("span");
	            attr_dev(span, "aria-hidden", "true");
	            add_location(span, file$z, 114, 0, 3644);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            span.innerHTML = youtubeicon;
	            if (!mounted) {
	                dispose = listen_dev(span, "click", function() {
	                    if (is_function(/*goyoutube*/ ctx[18](/*media*/ ctx[38].youtube))) /*goyoutube*/ ctx[18](/*media*/ ctx[38].youtube).apply(this, arguments);
	                }, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_7$1.name,
	        type: "if",
	        source: "(114:0) {#if idx&& !$playing && media.youtube}",
	        ctx
	    });
	    return block;
	}
	// (123:0) {#if $online}
	function create_if_block_4$3(ctx) {
	    let span0;
	    let t0_value = _(/*media*/ ctx[38].performer) + " " + "";
	    let t0;
	    let span1;
	    let t1;
	    let t2;
	    let t3;
	    let br;
	    let mounted;
	    let dispose;
	    function click_handler_1() {
	        return /*click_handler_1*/ ctx[23](/*media*/ ctx[38]);
	    }
	    let if_block0 = /*downloading*/ ctx[5] == /*media*/ ctx[38].aid && create_if_block_6$2(ctx);
	    let if_block1 = /*$audioid*/ ctx[0] == /*media*/ ctx[38].vid && /*$audioid*/ ctx[0] && create_if_block_5$3(ctx);
	    const block = {
	        c: function create() {
	            span0 = element("span");
	            t0 = text(t0_value);
	            span1 = element("span");
	            t1 = space();
	            if (if_block0) if_block0.c();
	            t2 = space();
	            if (if_block1) if_block1.c();
	            t3 = space();
	            br = element("br");
	            attr_dev(span0, "class", "uncache");
	            add_location(span0, file$z, 123, 0, 4004);
	            attr_dev(span1, "aria-hidden", "true");
	            attr_dev(span1, "class", "clickable");
	            add_location(span1, file$z, 123, 53, 4057);
	            add_location(br, file$z, 126, 0, 4303);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span0, anchor);
	            append_dev(span0, t0);
	            insert_dev(target, span1, anchor);
	            span1.innerHTML = downloadicon;
	            insert_dev(target, t1, anchor);
	            if (if_block0) if_block0.m(target, anchor);
	            insert_dev(target, t2, anchor);
	            if (if_block1) if_block1.m(target, anchor);
	            insert_dev(target, t3, anchor);
	            insert_dev(target, br, anchor);
	            if (!mounted) {
	                dispose = listen_dev(span1, "click", click_handler_1, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty[0] & /*$mediaurls*/ 512 && t0_value !== (t0_value = _(/*media*/ ctx[38].performer) + " " + "")) set_data_dev(t0, t0_value);
	            if (/*downloading*/ ctx[5] == /*media*/ ctx[38].aid) {
	                if (if_block0) {
	                    if_block0.p(ctx, dirty);
	                } else {
	                    if_block0 = create_if_block_6$2(ctx);
	                    if_block0.c();
	                    if_block0.m(t2.parentNode, t2);
	                }
	            } else if (if_block0) {
	                if_block0.d(1);
	                if_block0 = null;
	            }
	            if (/*$audioid*/ ctx[0] == /*media*/ ctx[38].vid && /*$audioid*/ ctx[0]) {
	                if (if_block1) {
	                    if_block1.p(ctx, dirty);
	                } else {
	                    if_block1 = create_if_block_5$3(ctx);
	                    if_block1.c();
	                    if_block1.m(t3.parentNode, t3);
	                }
	            } else if (if_block1) {
	                if_block1.d(1);
	                if_block1 = null;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span0);
	                detach_dev(span1);
	                detach_dev(t1);
	                detach_dev(t2);
	                detach_dev(t3);
	                detach_dev(br);
	            }
	            if (if_block0) if_block0.d(detaching);
	            if (if_block1) if_block1.d(detaching);
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_4$3.name,
	        type: "if",
	        source: "(123:0) {#if $online}",
	        ctx
	    });
	    return block;
	}
	// (118:0) {#if media.incache || !media.aid}
	function create_if_block_3$3(ctx) {
	    let span;
	    let t0_value = _(/*media*/ ctx[38].performer) + "";
	    let t0;
	    let t1_value = /*idx*/ (ctx[40] && /*media*/ ctx[38].aid == /*$audioid*/ ctx[0] ? '♫' : '') + "";
	    let t1;
	    let t2;
	    let br;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[22](/*media*/ ctx[38]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t0 = text(t0_value);
	            t1 = text(t1_value);
	            t2 = space();
	            br = element("br");
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*media*/ ctx[38].aid == /*$audioid*/ ctx[0]);
	            add_location(span, file$z, 118, 0, 3773);
	            add_location(br, file$z, 120, 4, 3976);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t0);
	            append_dev(span, t1);
	            insert_dev(target, t2, anchor);
	            insert_dev(target, br, anchor);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty[0] & /*$mediaurls*/ 512 && t0_value !== (t0_value = _(/*media*/ ctx[38].performer) + "")) set_data_dev(t0, t0_value);
	            if (dirty[0] & /*$mediaurls, $audioid*/ 513 && t1_value !== (t1_value = /*idx*/ (ctx[40] && /*media*/ ctx[38].aid == /*$audioid*/ ctx[0] ? '♫' : '') + "")) set_data_dev(t1, t1_value);
	            if (dirty[0] & /*$mediaurls, $audioid*/ 513) {
	                toggle_class(span, "selected", /*media*/ ctx[38].aid == /*$audioid*/ ctx[0]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	                detach_dev(t2);
	                detach_dev(br);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_3$3.name,
	        type: "if",
	        source: "(118:0) {#if media.incache || !media.aid}",
	        ctx
	    });
	    return block;
	}
	// (125:0) {#if downloading==media.aid}
	function create_if_block_6$2(ctx) {
	    let t;
	    const block = {
	        c: function create() {
	            t = text(/*progress*/ ctx[6]);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*progress*/ 64) set_data_dev(t, /*progress*/ ctx[6]);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_6$2.name,
	        type: "if",
	        source: "(125:0) {#if downloading==media.aid}",
	        ctx
	    });
	    return block;
	}
	// (126:0) {#if $audioid==media.vid&& $audioid}
	function create_if_block_5$3(ctx) {
	    let t_value = /*humanDuration*/ ctx[12](/*getDuration*/ ctx[13](/*$audioid*/ ctx[0])) + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*$audioid*/ 1 && t_value !== (t_value = /*humanDuration*/ ctx[12](/*getDuration*/ ctx[13](/*$audioid*/ ctx[0])) + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_5$3.name,
	        type: "if",
	        source: "(126:0) {#if $audioid==media.vid&& $audioid}",
	        ctx
	    });
	    return block;
	}
	// (113:0) {#each $mediaurls as media,idx}
	function create_each_block$f(ctx) {
	    let t;
	    let if_block1_anchor;
	    let if_block0 = /*idx*/ ctx[40] && !/*$playing*/ ctx[10] && /*media*/ ctx[38].youtube && create_if_block_7$1(ctx);
	    function select_block_type(ctx, dirty) {
	        if (/*media*/ ctx[38].incache || !/*media*/ ctx[38].aid) return create_if_block_3$3;
	        if (/*$online*/ ctx[11]) return create_if_block_4$3;
	    }
	    let current_block_type = select_block_type(ctx);
	    let if_block1 = current_block_type && current_block_type(ctx);
	    const block = {
	        c: function create() {
	            if (if_block0) if_block0.c();
	            t = space();
	            if (if_block1) if_block1.c();
	            if_block1_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if (if_block0) if_block0.m(target, anchor);
	            insert_dev(target, t, anchor);
	            if (if_block1) if_block1.m(target, anchor);
	            insert_dev(target, if_block1_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (/*idx*/ ctx[40] && !/*$playing*/ ctx[10] && /*media*/ ctx[38].youtube) {
	                if (if_block0) {
	                    if_block0.p(ctx, dirty);
	                } else {
	                    if_block0 = create_if_block_7$1(ctx);
	                    if_block0.c();
	                    if_block0.m(t.parentNode, t);
	                }
	            } else if (if_block0) {
	                if_block0.d(1);
	                if_block0 = null;
	            }
	            if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
	                if_block1.p(ctx, dirty);
	            } else {
	                if (if_block1) if_block1.d(1);
	                if_block1 = current_block_type && current_block_type(ctx);
	                if (if_block1) {
	                    if_block1.c();
	                    if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	                }
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	                detach_dev(if_block1_anchor);
	            }
	            if (if_block0) if_block0.d(detaching);
	            if (if_block1) {
	                if_block1.d(detaching);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$f.name,
	        type: "each",
	        source: "(113:0) {#each $mediaurls as media,idx}",
	        ctx
	    });
	    return block;
	}
	// (136:4) 
	function create_caption_slot$4(ctx) {
	    let span;
	    let t_value = /*rate*/ ctx[1][0] / 100 + _(" 播放速度") + "";
	    let t;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "slot", "caption");
	            set_style(span, "float", "right");
	            add_location(span, file$z, 135, 4, 4468);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*rate*/ 2 && t_value !== (t_value = /*rate*/ ctx[1][0] / 100 + _(" 播放速度") + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_caption_slot$4.name,
	        type: "slot",
	        source: "(136:4) ",
	        ctx
	    });
	    return block;
	}
	// (140:0) {#if rate[0]!==100}
	function create_if_block_2$5(ctx) {
	    let span;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span = element("span");
	            span.textContent = `${_("恢復正常速度")}`;
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            add_location(span, file$z, 140, 0, 4580);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*speed1x*/ ctx[20], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_2$5.name,
	        type: "if",
	        source: "(140:0) {#if rate[0]!==100}",
	        ctx
	    });
	    return block;
	}
	// (143:0) {#if value[0]>0}
	function create_if_block_1$a(ctx) {
	    let t_value = /*humanStoptime*/ ctx[17](/*value*/ ctx[2][0] * /*getDuration*/ ctx[13](/*$audioid*/ ctx[0])) + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*value, $audioid*/ 5 && t_value !== (t_value = /*humanStoptime*/ ctx[17](/*value*/ ctx[2][0] * /*getDuration*/ ctx[13](/*$audioid*/ ctx[0])) + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$a.name,
	        type: "if",
	        source: "(143:0) {#if value[0]>0}",
	        ctx
	    });
	    return block;
	}
	// (145:0) {#if ptk&&allJuan(ptk).length>1}
	function create_if_block$i(ctx) {
	    let switch_1;
	    let updating_value;
	    let current;
	    function switch_1_value_binding(value) {
	        /*switch_1_value_binding*/ ctx[26](value);
	    }
	    let switch_1_props = {
	        label: _('自動播放下一卷'),
	        design: "slider"
	    };
	    if (/*$playnextjuan*/ ctx[8] !== void 0) {
	        switch_1_props.value = /*$playnextjuan*/ ctx[8];
	    }
	    switch_1 = new Switch({
	        props: switch_1_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(switch_1, 'value', switch_1_value_binding));
	    const block = {
	        c: function create() {
	            create_component(switch_1.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(switch_1, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const switch_1_changes = {};
	            if (!updating_value && dirty[0] & /*$playnextjuan*/ 256) {
	                updating_value = true;
	                switch_1_changes.value = /*$playnextjuan*/ ctx[8];
	                add_flush_callback(()=>updating_value = false);
	            }
	            switch_1.$set(switch_1_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(switch_1.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(switch_1.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(switch_1, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$i.name,
	        type: "if",
	        source: "(145:0) {#if ptk&&allJuan(ptk).length>1}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$B(ctx) {
	    let div2;
	    let t0;
	    let br0;
	    let t1;
	    let slider0;
	    let updating_value;
	    let t2;
	    let br1;
	    let t3;
	    let t4;
	    let t5_value = _('重播次數') + "";
	    let t5;
	    let t6;
	    let t7_value = /*value*/ (ctx[2][0] > 0 ? /*value*/ ctx[2][0] : _('無限')) + "";
	    let t7;
	    let t8;
	    let t9;
	    let slider1;
	    let updating_value_1;
	    let t10;
	    let show_if = /*ptk*/ ctx[7] && allJuan(/*ptk*/ ctx[7]).length > 1;
	    let t11;
	    let hr;
	    let t12;
	    let div0;
	    let raw0_value = _(/*htmltext*/ ctx[14](/*subtitle2*/ ctx[4])) + "";
	    let t13;
	    let div1;
	    let raw1_value = _(/*htmltext*/ ctx[14](/*subtitle*/ ctx[3])) + "";
	    let t14;
	    let endmarker;
	    let current;
	    let each_value = ensure_array_like_dev(/*$mediaurls*/ ctx[9]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
	    }
	    function slider0_value_binding(value) {
	        /*slider0_value_binding*/ ctx[24](value);
	    }
	    let slider0_props = {
	        max: 300,
	        min: 30,
	        $$slots: {
	            caption: [
	                create_caption_slot$4
	            ]
	        },
	        $$scope: {
	            ctx
	        }
	    };
	    if (/*rate*/ ctx[1] !== void 0) {
	        slider0_props.value = /*rate*/ ctx[1];
	    }
	    slider0 = new Rangeslider({
	        props: slider0_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(slider0, 'value', slider0_value_binding));
	    slider0.$on("input", debounce(/*setPlayrate*/ ctx[19], 300));
	    let if_block0 = /*rate*/ ctx[1][0] !== 100 && create_if_block_2$5(ctx);
	    let if_block1 = /*value*/ ctx[2][0] > 0 && create_if_block_1$a(ctx);
	    function slider1_value_binding(value) {
	        /*slider1_value_binding*/ ctx[25](value);
	    }
	    let slider1_props = {
	        min: "0",
	        max: "10"
	    };
	    if (/*value*/ ctx[2] !== void 0) {
	        slider1_props.value = /*value*/ ctx[2];
	    }
	    slider1 = new Rangeslider({
	        props: slider1_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(slider1, 'value', slider1_value_binding));
	    slider1.$on("input", /*setRemain*/ ctx[16]);
	    let if_block2 = show_if && create_if_block$i(ctx);
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div2 = element("div");
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            t0 = space();
	            br0 = element("br");
	            t1 = space();
	            create_component(slider0.$$.fragment);
	            t2 = space();
	            br1 = element("br");
	            t3 = space();
	            if (if_block0) if_block0.c();
	            t4 = space();
	            t5 = text(t5_value);
	            t6 = text("：");
	            t7 = text(t7_value);
	            t8 = space();
	            if (if_block1) if_block1.c();
	            t9 = space();
	            create_component(slider1.$$.fragment);
	            t10 = space();
	            if (if_block2) if_block2.c();
	            t11 = space();
	            hr = element("hr");
	            t12 = space();
	            div0 = element("div");
	            t13 = space();
	            div1 = element("div");
	            t14 = space();
	            create_component(endmarker.$$.fragment);
	            add_location(br0, file$z, 133, 0, 4374);
	            add_location(br1, file$z, 138, 0, 4554);
	            add_location(hr, file$z, 148, 0, 4959);
	            attr_dev(div0, "class", "subtitle");
	            add_location(div0, file$z, 149, 0, 4965);
	            attr_dev(div1, "class", "subtitle");
	            add_location(div1, file$z, 150, 0, 5024);
	            attr_dev(div2, "class", "bodytext");
	            add_location(div2, file$z, 110, 0, 3549);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div2, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div2, null);
	                }
	            }
	            append_dev(div2, t0);
	            append_dev(div2, br0);
	            append_dev(div2, t1);
	            mount_component(slider0, div2, null);
	            append_dev(div2, t2);
	            append_dev(div2, br1);
	            append_dev(div2, t3);
	            if (if_block0) if_block0.m(div2, null);
	            append_dev(div2, t4);
	            append_dev(div2, t5);
	            append_dev(div2, t6);
	            append_dev(div2, t7);
	            append_dev(div2, t8);
	            if (if_block1) if_block1.m(div2, null);
	            append_dev(div2, t9);
	            mount_component(slider1, div2, null);
	            append_dev(div2, t10);
	            if (if_block2) if_block2.m(div2, null);
	            append_dev(div2, t11);
	            append_dev(div2, hr);
	            append_dev(div2, t12);
	            append_dev(div2, div0);
	            div0.innerHTML = raw0_value;
	            append_dev(div2, t13);
	            append_dev(div2, div1);
	            div1.innerHTML = raw1_value;
	            append_dev(div2, t14);
	            mount_component(endmarker, div2, null);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*$mediaurls, $audioid, downloading, humanDuration, getDuration, progress, downloadit, $online, goyoutube, $playing*/ 310881) {
	                each_value = ensure_array_like_dev(/*$mediaurls*/ ctx[9]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$f(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$f(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div2, t0);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	            const slider0_changes = {};
	            if (dirty[0] & /*rate*/ 2 | dirty[1] & /*$$scope*/ 1024) {
	                slider0_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            if (!updating_value && dirty[0] & /*rate*/ 2) {
	                updating_value = true;
	                slider0_changes.value = /*rate*/ ctx[1];
	                add_flush_callback(()=>updating_value = false);
	            }
	            slider0.$set(slider0_changes);
	            if (/*rate*/ ctx[1][0] !== 100) {
	                if (if_block0) {
	                    if_block0.p(ctx, dirty);
	                } else {
	                    if_block0 = create_if_block_2$5(ctx);
	                    if_block0.c();
	                    if_block0.m(div2, t4);
	                }
	            } else if (if_block0) {
	                if_block0.d(1);
	                if_block0 = null;
	            }
	            if ((!current || dirty[0] & /*value*/ 4) && t7_value !== (t7_value = /*value*/ (ctx[2][0] > 0 ? /*value*/ ctx[2][0] : _('無限')) + "")) set_data_dev(t7, t7_value);
	            if (/*value*/ ctx[2][0] > 0) {
	                if (if_block1) {
	                    if_block1.p(ctx, dirty);
	                } else {
	                    if_block1 = create_if_block_1$a(ctx);
	                    if_block1.c();
	                    if_block1.m(div2, t9);
	                }
	            } else if (if_block1) {
	                if_block1.d(1);
	                if_block1 = null;
	            }
	            const slider1_changes = {};
	            if (!updating_value_1 && dirty[0] & /*value*/ 4) {
	                updating_value_1 = true;
	                slider1_changes.value = /*value*/ ctx[2];
	                add_flush_callback(()=>updating_value_1 = false);
	            }
	            slider1.$set(slider1_changes);
	            if (dirty[0] & /*ptk*/ 128) show_if = /*ptk*/ ctx[7] && allJuan(/*ptk*/ ctx[7]).length > 1;
	            if (show_if) {
	                if (if_block2) {
	                    if_block2.p(ctx, dirty);
	                    if (dirty[0] & /*ptk*/ 128) {
	                        transition_in(if_block2, 1);
	                    }
	                } else {
	                    if_block2 = create_if_block$i(ctx);
	                    if_block2.c();
	                    transition_in(if_block2, 1);
	                    if_block2.m(div2, t11);
	                }
	            } else if (if_block2) {
	                group_outros();
	                transition_out(if_block2, 1, 1, ()=>{
	                    if_block2 = null;
	                });
	                check_outros();
	            }
	            if ((!current || dirty[0] & /*subtitle2*/ 16) && raw0_value !== (raw0_value = _(/*htmltext*/ ctx[14](/*subtitle2*/ ctx[4])) + "")) div0.innerHTML = raw0_value;
	            if ((!current || dirty[0] & /*subtitle*/ 8) && raw1_value !== (raw1_value = _(/*htmltext*/ ctx[14](/*subtitle*/ ctx[3])) + "")) div1.innerHTML = raw1_value;
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(slider0.$$.fragment, local);
	            transition_in(slider1.$$.fragment, local);
	            transition_in(if_block2);
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(slider0.$$.fragment, local);
	            transition_out(slider1.$$.fragment, local);
	            transition_out(if_block2);
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div2);
	            }
	            destroy_each(each_blocks, detaching);
	            destroy_component(slider0);
	            if (if_block0) if_block0.d();
	            if (if_block1) if_block1.d();
	            destroy_component(slider1);
	            if (if_block2) if_block2.d();
	            destroy_component(endmarker);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$B.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$B($$self, $$props, $$invalidate) {
	    let ptk;
	    let $playnextjuan;
	    let $audioid;
	    let $showyoutube;
	    let $activefolioid;
	    let $remainrollback;
	    let $playrate;
	    let $activePtk;
	    let $mediaurls;
	    let $playing;
	    let $online;
	    validate_store(playnextjuan, 'playnextjuan');
	    component_subscribe($$self, playnextjuan, ($$value)=>$$invalidate(8, $playnextjuan = $$value));
	    validate_store(audioid, 'audioid');
	    component_subscribe($$self, audioid, ($$value)=>$$invalidate(0, $audioid = $$value));
	    validate_store(showyoutube, 'showyoutube');
	    component_subscribe($$self, showyoutube, ($$value)=>$$invalidate(33, $showyoutube = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(34, $activefolioid = $$value));
	    validate_store(remainrollback, 'remainrollback');
	    component_subscribe($$self, remainrollback, ($$value)=>$$invalidate(35, $remainrollback = $$value));
	    validate_store(playrate, 'playrate');
	    component_subscribe($$self, playrate, ($$value)=>$$invalidate(36, $playrate = $$value));
	    validate_store(activePtk, 'activePtk');
	    component_subscribe($$self, activePtk, ($$value)=>$$invalidate(21, $activePtk = $$value));
	    validate_store(mediaurls, 'mediaurls');
	    component_subscribe($$self, mediaurls, ($$value)=>$$invalidate(9, $mediaurls = $$value));
	    validate_store(playing, 'playing');
	    component_subscribe($$self, playing, ($$value)=>$$invalidate(10, $playing = $$value));
	    validate_store(online, 'online');
	    component_subscribe($$self, online, ($$value)=>$$invalidate(11, $online = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Audio', slots, []);
	    let rate = [
	        $playrate || 100,
	        0
	    ];
	    let value = [
	        $remainrollback,
	        0
	    ];
	    let subtitles = [], subtitles2 = [], subtitle = '', subtitle2 = '', subtitletimer, nsub = 0;
	    onDestroy(()=>{
	        clearInterval(subtitletimer);
	    });
	    const humanDuration = (t)=>{
	        if (!t) return '';
	        const minutes = Math.floor(t / 60);
	        const seconds = t - minutes * 60;
	        return `${minutes}:${seconds}`;
	    };
	    const getDuration = (id)=>{
	        var _findByAudioId;
	        const timestamps = (_findByAudioId = findByAudioId(id)) === null || _findByAudioId === void 0 ? void 0 : _findByAudioId.timestamp;
	        if (!timestamps) return 0;
	        return timestamps[timestamps.length - 1] - timestamps[0];
	    };
	    let timestamp = [];
	    onMount(()=>{
	        subtitletimer = setInterval(()=>{
	            if (!$audioid) return;
	            // const plyr=player($audioid);
	            // if (!plyr)return;
	            const playertime = player.currentTime;
	            // const playertime=plyr.getCurrentTime&&plyr.getCurrentTime();
	            while(playertime >= timestamp[nsub] && nsub < timestamp.length){
	                $$invalidate(3, subtitle = subtitles[nsub] || subtitle || ''); //do not update empty line
	                $$invalidate(4, subtitle2 = subtitles2[nsub] || subtitle2 || ''); //do not update empty line
	                nsub++;
	            }
	            if (nsub >= timestamp.length) nsub = 0;
	        }, 500);
	    });
	    const loadSubtitle = async (id)=>{
	        var _findByAudioId;
	        $$invalidate(4, subtitle2 = $$invalidate(3, subtitle = ''));
	        subtitles2 = [], subtitles = [];
	        if (!id) return;
	        timestamp = ((_findByAudioId = findByAudioId(id, 'timestamp_sanskrit')) === null || _findByAudioId === void 0 ? void 0 : _findByAudioId.timestamp) || [];
	        if (!(timestamp === null || timestamp === void 0 ? void 0 : timestamp.length)) return;
	        const skptk = usePtk('dc_sanskrit');
	        subtitles2 = await skptk.fetchAddress('bk#' + $activefolioid);
	        subtitles = await ptk.fetchAddress('bk#' + $activefolioid);
	        nsub = 0;
	    };
	    const htmltext = (s)=>{
	        return parseOfftext(s)[0].replace(/[【《〔](.+?)[】》〕]/g, '<span class=bracket>$1 </span>');
	    };
	    let downloading = '', progress = '';
	    const downloadit = async (aid)=>{
	        $$invalidate(5, downloading = aid);
	        await downloadToCache(CacheName, audiofolder + aid + '.mp3', (msg)=>{
	            $$invalidate(6, progress = msg);
	        });
	        await sleep(1000); //wait for cache to sync
	        const list = await fetchAudioList($activefolioid, mediaurls, $showyoutube == 'on');
	        mediaurls.set(list);
	        $$invalidate(5, downloading = '');
	        $$invalidate(6, progress = '');
	    };
	    const setRemain = ()=>{
	        const v = value[0];
	        if (v && get_store_value(remainrollback) == value[0] || v == 0 && get_store_value(remainrollback) == -1) return;
	        if (v == 0) {
	            remainrollback.set(-1); //infinite
	        } else {
	            remainrollback.set(v);
	        }
	    };
	    const humanStoptime = (t)=>{
	        if (!t || $playnextjuan == 'on' && allJuan(ptk).length > 1) return '';
	        return new Date(Date.now() + t * 1000).toLocaleTimeString() + '停止';
	    };
	    const goyoutube = (id)=>{
	        stopAudio();
	        window.open("https://youtube.com/watch?v=" + id, "_blank");
	    };
	    const setPlayrate = (e)=>{
	        const rate = e.detail[0];
	        player.playbackRate = rate / 100;
	        playrate.set(rate);
	    };
	    const speed1x = ()=>{
	        $$invalidate(1, rate = [
	            100,
	            0
	        ]);
	        player.playbackRate = 1;
	        playrate.set(100);
	    };
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Audio> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (media)=>!downloading && selectmedia(media.aid, true);
	    const click_handler_1 = (media)=>!downloading && downloadit(media.aid);
	    function slider0_value_binding(value) {
	        rate = value;
	        $$invalidate(1, rate);
	    }
	    function slider1_value_binding(value$1) {
	        value = value$1;
	        $$invalidate(2, value);
	    }
	    function switch_1_value_binding(value) {
	        $playnextjuan = value;
	        playnextjuan.set($playnextjuan);
	    }
	    $$self.$capture_state = ()=>({
	            online,
	            player,
	            audioid,
	            activefolioid,
	            playnextjuan,
	            findByAudioId,
	            playrate,
	            activePtk,
	            remainrollback,
	            selectmedia,
	            mediaurls,
	            stopAudio,
	            playing,
	            showyoutube,
	            CacheName,
	            Slider: Rangeslider,
	            Switch,
	            usePtk,
	            parseOfftext,
	            sleep,
	            debounce,
	            onDestroy,
	            onMount,
	            get: get_store_value,
	            audiofolder,
	            fetchAudioList,
	            allJuan,
	            downloadicon,
	            youtubeicon,
	            downloadToCache,
	            _,
	            Endmarker,
	            rate,
	            value,
	            subtitles,
	            subtitles2,
	            subtitle,
	            subtitle2,
	            subtitletimer,
	            nsub,
	            humanDuration,
	            getDuration,
	            timestamp,
	            loadSubtitle,
	            htmltext,
	            downloading,
	            progress,
	            downloadit,
	            setRemain,
	            humanStoptime,
	            goyoutube,
	            setPlayrate,
	            speed1x,
	            ptk,
	            $playnextjuan,
	            $audioid,
	            $showyoutube,
	            $activefolioid,
	            $remainrollback,
	            $playrate,
	            $activePtk,
	            $mediaurls,
	            $playing,
	            $online
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('rate' in $$props) $$invalidate(1, rate = $$props.rate);
	        if ('value' in $$props) $$invalidate(2, value = $$props.value);
	        if ('subtitles' in $$props) subtitles = $$props.subtitles;
	        if ('subtitles2' in $$props) subtitles2 = $$props.subtitles2;
	        if ('subtitle' in $$props) $$invalidate(3, subtitle = $$props.subtitle);
	        if ('subtitle2' in $$props) $$invalidate(4, subtitle2 = $$props.subtitle2);
	        if ('subtitletimer' in $$props) subtitletimer = $$props.subtitletimer;
	        if ('nsub' in $$props) nsub = $$props.nsub;
	        if ('timestamp' in $$props) timestamp = $$props.timestamp;
	        if ('downloading' in $$props) $$invalidate(5, downloading = $$props.downloading);
	        if ('progress' in $$props) $$invalidate(6, progress = $$props.progress);
	        if ('ptk' in $$props) $$invalidate(7, ptk = $$props.ptk);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty[0] & /*$activePtk*/ 2097152) {
	            $$invalidate(7, ptk = usePtk($activePtk));
	        }
	        if ($$self.$$.dirty[0] & /*$audioid*/ 1) {
	            loadSubtitle($audioid);
	        }
	    };
	    return [
	        $audioid,
	        rate,
	        value,
	        subtitle,
	        subtitle2,
	        downloading,
	        progress,
	        ptk,
	        $playnextjuan,
	        $mediaurls,
	        $playing,
	        $online,
	        humanDuration,
	        getDuration,
	        htmltext,
	        downloadit,
	        setRemain,
	        humanStoptime,
	        goyoutube,
	        setPlayrate,
	        speed1x,
	        $activePtk,
	        click_handler,
	        click_handler_1,
	        slider0_value_binding,
	        slider1_value_binding,
	        switch_1_value_binding
	    ];
	}
	class Audio extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$B, create_fragment$B, safe_not_equal, {}, null, [
	            -1,
	            -1
	        ]);
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Audio",
	            options,
	            id: create_fragment$B.name
	        });
	    }
	}

	const file$y = "src\\hof.svelte";
	function create_fragment$A(ctx) {
	    let div4;
	    let div0;
	    let t1;
	    let div1;
	    let t3;
	    let table0;
	    let tr0;
	    let td0;
	    let td1;
	    let td2;
	    let t7;
	    let tr1;
	    let td3;
	    let td4;
	    let td5;
	    let t12;
	    let tr2;
	    let td6;
	    let td7;
	    let td8;
	    let t17;
	    let tr3;
	    let td9;
	    let td10;
	    let td11;
	    let t22;
	    let tr4;
	    let td12;
	    let td13;
	    let td14;
	    let t27;
	    let tr5;
	    let td15;
	    let td16;
	    let td17;
	    let t32;
	    let tr6;
	    let td18;
	    let td19;
	    let td20;
	    let t37;
	    let tr7;
	    let td21;
	    let td22;
	    let td23;
	    let t42;
	    let br0;
	    let div2;
	    let t44;
	    let table1;
	    let tr8;
	    let td24;
	    let td25;
	    let td26;
	    let t49;
	    let br1;
	    let div3;
	    let t51;
	    let table2;
	    let tr9;
	    let td27;
	    let td28;
	    let td29;
	    let t57;
	    let endmarker;
	    let current;
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div4 = element("div");
	            div0 = element("div");
	            div0.textContent = `${_("捐獻記錄。祈願諸護持者以此功德，獲得無量的利益。")}`;
	            t1 = space();
	            div1 = element("div");
	            div1.textContent = "2023年";
	            t3 = space();
	            table0 = element("table");
	            tr0 = element("tr");
	            td0 = element("td");
	            td0.textContent = "陳碧吟";
	            td1 = element("td");
	            td1.textContent = "1.12";
	            td2 = element("td");
	            td2.textContent = "美元 1,000";
	            t7 = space();
	            tr1 = element("tr");
	            td3 = element("td");
	            td3.textContent = "甯耀南";
	            td4 = element("td");
	            td4.textContent = "5.21";
	            td5 = element("td");
	            td5.textContent = `${_("台幣")}  10,000`;
	            t12 = space();
	            tr2 = element("tr");
	            td6 = element("td");
	            td6.textContent = `${_("葉雅柏")}`;
	            td7 = element("td");
	            td7.textContent = "8.19";
	            td8 = element("td");
	            td8.textContent = `${_("泰銖")}40,000`;
	            t17 = space();
	            tr3 = element("tr");
	            td9 = element("td");
	            td9.textContent = "李玉媚 ";
	            td10 = element("td");
	            td10.textContent = "8.19 ";
	            td11 = element("td");
	            td11.textContent = `${_("馬幣")} 5,000`;
	            t22 = space();
	            tr4 = element("tr");
	            td12 = element("td");
	            td12.textContent = "林嘉雯";
	            td13 = element("td");
	            td13.textContent = "8.27 ";
	            td14 = element("td");
	            td14.textContent = `${_("台幣")} 1,000`;
	            t27 = space();
	            tr5 = element("tr");
	            td15 = element("td");
	            td15.textContent = "法王講堂";
	            td16 = element("td");
	            td16.textContent = "9.9 ";
	            td17 = element("td");
	            td17.textContent = `${_("台幣")} 50,000`;
	            t32 = space();
	            tr6 = element("tr");
	            td18 = element("td");
	            td18.textContent = "施郁芳";
	            td19 = element("td");
	            td19.textContent = "9.13";
	            td20 = element("td");
	            td20.textContent = `${_("台幣")} 5,000`;
	            t37 = space();
	            tr7 = element("tr");
	            td21 = element("td");
	            td21.textContent = "香港天台精舍";
	            td22 = element("td");
	            td22.textContent = "12.30";
	            td23 = element("td");
	            td23.textContent = `${_("人民幣")} 5,000`;
	            t42 = space();
	            br0 = element("br");
	            div2 = element("div");
	            div2.textContent = "2024年";
	            t44 = space();
	            table1 = element("table");
	            tr8 = element("tr");
	            td24 = element("td");
	            td24.textContent = "金門福慧寺";
	            td25 = element("td");
	            td25.textContent = "3.15";
	            td26 = element("td");
	            td26.textContent = `${_("台幣")} 6,000`;
	            t49 = space();
	            br1 = element("br");
	            div3 = element("div");
	            div3.textContent = "2025年";
	            t51 = space();
	            table2 = element("table");
	            tr9 = element("tr");
	            td27 = element("td");
	            td27.textContent = `${_("紅坊老黃")} `;
	            td28 = element("td");
	            td28.textContent = "3.5";
	            td29 = element("td");
	            td29.textContent = `${_("人民幣")} 2,000`;
	            t57 = space();
	            create_component(endmarker.$$.fragment);
	            add_location(div0, file$y, 5, 0, 104);
	            add_location(div1, file$y, 6, 0, 147);
	            add_location(td0, file$y, 8, 8, 180);
	            add_location(td1, file$y, 8, 20, 192);
	            add_location(td2, file$y, 8, 33, 205);
	            add_location(tr0, file$y, 8, 4, 176);
	            add_location(td3, file$y, 9, 8, 236);
	            add_location(td4, file$y, 9, 20, 248);
	            add_location(td5, file$y, 9, 33, 261);
	            add_location(tr1, file$y, 9, 4, 232);
	            attr_dev(td6, "class", "deceased");
	            add_location(td6, file$y, 10, 8, 301);
	            add_location(td7, file$y, 10, 44, 337);
	            add_location(td8, file$y, 10, 57, 350);
	            add_location(tr2, file$y, 10, 4, 297);
	            add_location(td9, file$y, 11, 8, 389);
	            add_location(td10, file$y, 11, 21, 402);
	            add_location(td11, file$y, 11, 35, 416);
	            add_location(tr3, file$y, 11, 4, 385);
	            add_location(td12, file$y, 12, 8, 454);
	            add_location(td13, file$y, 12, 20, 466);
	            add_location(td14, file$y, 12, 34, 480);
	            add_location(tr4, file$y, 12, 4, 450);
	            add_location(td15, file$y, 13, 8, 518);
	            add_location(td16, file$y, 13, 21, 531);
	            add_location(td17, file$y, 13, 34, 544);
	            add_location(tr5, file$y, 13, 4, 514);
	            add_location(td18, file$y, 14, 8, 583);
	            add_location(td19, file$y, 14, 20, 595);
	            add_location(td20, file$y, 14, 33, 608);
	            add_location(tr6, file$y, 14, 4, 579);
	            add_location(td21, file$y, 15, 8, 646);
	            add_location(td22, file$y, 15, 23, 661);
	            add_location(td23, file$y, 15, 37, 675);
	            add_location(tr7, file$y, 15, 4, 642);
	            add_location(table0, file$y, 7, 0, 164);
	            add_location(br0, file$y, 17, 0, 715);
	            add_location(div2, file$y, 17, 5, 720);
	            add_location(td24, file$y, 19, 4, 749);
	            add_location(td25, file$y, 19, 18, 763);
	            add_location(td26, file$y, 19, 31, 776);
	            add_location(tr8, file$y, 19, 0, 745);
	            add_location(table1, file$y, 18, 0, 737);
	            add_location(br1, file$y, 21, 0, 815);
	            add_location(div3, file$y, 21, 5, 820);
	            add_location(td27, file$y, 23, 4, 849);
	            add_location(td28, file$y, 23, 25, 870);
	            add_location(td29, file$y, 23, 37, 882);
	            add_location(tr9, file$y, 23, 0, 845);
	            add_location(table2, file$y, 22, 0, 837);
	            add_location(div4, file$y, 4, 0, 98);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div4, anchor);
	            append_dev(div4, div0);
	            append_dev(div4, t1);
	            append_dev(div4, div1);
	            append_dev(div4, t3);
	            append_dev(div4, table0);
	            append_dev(table0, tr0);
	            append_dev(tr0, td0);
	            append_dev(tr0, td1);
	            append_dev(tr0, td2);
	            append_dev(table0, t7);
	            append_dev(table0, tr1);
	            append_dev(tr1, td3);
	            append_dev(tr1, td4);
	            append_dev(tr1, td5);
	            append_dev(table0, t12);
	            append_dev(table0, tr2);
	            append_dev(tr2, td6);
	            append_dev(tr2, td7);
	            append_dev(tr2, td8);
	            append_dev(table0, t17);
	            append_dev(table0, tr3);
	            append_dev(tr3, td9);
	            append_dev(tr3, td10);
	            append_dev(tr3, td11);
	            append_dev(table0, t22);
	            append_dev(table0, tr4);
	            append_dev(tr4, td12);
	            append_dev(tr4, td13);
	            append_dev(tr4, td14);
	            append_dev(table0, t27);
	            append_dev(table0, tr5);
	            append_dev(tr5, td15);
	            append_dev(tr5, td16);
	            append_dev(tr5, td17);
	            append_dev(table0, t32);
	            append_dev(table0, tr6);
	            append_dev(tr6, td18);
	            append_dev(tr6, td19);
	            append_dev(tr6, td20);
	            append_dev(table0, t37);
	            append_dev(table0, tr7);
	            append_dev(tr7, td21);
	            append_dev(tr7, td22);
	            append_dev(tr7, td23);
	            append_dev(div4, t42);
	            append_dev(div4, br0);
	            append_dev(div4, div2);
	            append_dev(div4, t44);
	            append_dev(div4, table1);
	            append_dev(table1, tr8);
	            append_dev(tr8, td24);
	            append_dev(tr8, td25);
	            append_dev(tr8, td26);
	            append_dev(div4, t49);
	            append_dev(div4, br1);
	            append_dev(div4, div3);
	            append_dev(div4, t51);
	            append_dev(div4, table2);
	            append_dev(table2, tr9);
	            append_dev(tr9, td27);
	            append_dev(tr9, td28);
	            append_dev(tr9, td29);
	            append_dev(div4, t57);
	            mount_component(endmarker, div4, null);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div4);
	            }
	            destroy_component(endmarker);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$A.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$A($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Hof', slots, []);
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Hof> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            Endmarker,
	            _
	        });
	    return [];
	}
	class Hof extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$A, create_fragment$A, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Hof",
	            options,
	            id: create_fragment$A.name
	        });
	    }
	}

	const file$x = "src\\workers.svelte";
	function create_fragment$z(ctx) {
	    let t0_value = _("圖版裁切：釋通泉　張淑楨") + "";
	    let t0;
	    let t1;
	    let hr0;
	    let t2;
	    let t3_value = _("分句標記：䆁常明　謝宇恆") + "";
	    let t3;
	    let t4;
	    let hr1;
	    let t5;
	    let t6_value = _("時間戳記：林煴如　永航（韓語）") + "";
	    let t6;
	    let t7;
	    let hr2;
	    let t8;
	    let t9_value = _("系統測試：") + "";
	    let t9;
	    let t10;
	    const block = {
	        c: function create() {
	            t0 = text(t0_value);
	            t1 = space();
	            hr0 = element("hr");
	            t2 = space();
	            t3 = text(t3_value);
	            t4 = space();
	            hr1 = element("hr");
	            t5 = space();
	            t6 = text(t6_value);
	            t7 = space();
	            hr2 = element("hr");
	            t8 = space();
	            t9 = text(t9_value);
	            t10 = text("桜井悟志(サトシ．サクライ)");
	            add_location(hr0, file$x, 4, 0, 70);
	            add_location(hr1, file$x, 6, 0, 96);
	            add_location(hr2, file$x, 8, 0, 125);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t0, anchor);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, hr0, anchor);
	            insert_dev(target, t2, anchor);
	            insert_dev(target, t3, anchor);
	            insert_dev(target, t4, anchor);
	            insert_dev(target, hr1, anchor);
	            insert_dev(target, t5, anchor);
	            insert_dev(target, t6, anchor);
	            insert_dev(target, t7, anchor);
	            insert_dev(target, hr2, anchor);
	            insert_dev(target, t8, anchor);
	            insert_dev(target, t9, anchor);
	            insert_dev(target, t10, anchor);
	        },
	        p: noop,
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(hr0);
	                detach_dev(t2);
	                detach_dev(t3);
	                detach_dev(t4);
	                detach_dev(hr1);
	                detach_dev(t5);
	                detach_dev(t6);
	                detach_dev(t7);
	                detach_dev(hr2);
	                detach_dev(t8);
	                detach_dev(t9);
	                detach_dev(t10);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$z.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$z($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Workers', slots, []);
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Workers> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            _
	        });
	    return [];
	}
	class Workers extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$z, create_fragment$z, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Workers",
	            options,
	            id: create_fragment$z.name
	        });
	    }
	}

	const file$w = "src\\project.svelte";
	function create_fragment$y(ctx) {
	    let div;
	    let a0;
	    let t1;
	    let br0;
	    let t2;
	    let br1;
	    let t3;
	    let br2;
	    let t4;
	    let br3;
	    let t5;
	    let br4;
	    let t6;
	    let br5;
	    let a1;
	    let t8;
	    let br6;
	    let t9;
	    let a2;
	    let t11;
	    let br7;
	    let t12;
	    let br8;
	    let t13;
	    let br9;
	    let br10;
	    let t14;
	    let br11;
	    let t15;
	    let br12;
	    let t16;
	    let br13;
	    let t17;
	    let br14;
	    let t18;
	    let br15;
	    let t19;
	    let br16;
	    let t20;
	    let br17;
	    let t21;
	    let br18;
	    let t22;
	    let br19;
	    let t23;
	    let br20;
	    let t24;
	    let br21;
	    let t25;
	    let br22;
	    let br23;
	    let t26;
	    let br24;
	    let t27;
	    let br25;
	    let t28;
	    let br26;
	    let t29;
	    let br27;
	    let br28;
	    let t30;
	    let br29;
	    let t31;
	    let br30;
	    let t32;
	    let br31;
	    let t33;
	    let br32;
	    let t34;
	    let br33;
	    let t35;
	    let endmarker;
	    let current;
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div = element("div");
	            a0 = element("a");
	            a0.textContent = "補版計劃";
	            t1 = text("\n佛法是中華文明的三大組成部份(儒釋道)中唯一的非原生文明，佛經的翻譯和編修是大規模的文化交流工程，其在文明史的地位，不亞於阿拉伯的百年翻譯運動。\n");
	            br0 = element("br");
	            t2 = text("因此，以佛法為依托的文化符號，能夠將中華文明以較小的阻力，散播至儒家文化圈以外。\n");
	            br1 = element("br");
	            t3 = text("漢傳佛教徒素有勇於嘗試新科技的傳統，公元868年（唐咸通九年），在雕版印刷術萌芽之初，印行了金剛經（敦煌唐刻本），比歐洲早五百年。\n");
	            br2 = element("br");
	            t4 = text("日本於一百年前編修的大正藏，是近代較為齊全、廣為流通的版本。由於大正藏，以及收錄大量中國祖師著作的，卍續藏之成就，日本人可以自豪地宣稱，漢傳佛教的研究重心，已由中土轉移到東瀛。\n\n");
	            br3 = element("br");
	            t5 = text("生為炎黃子孫、身為三寶弟子，感謝日本為保存漢文佛經投入的努力，但以佛法流傳的角度而言，這是歷史的異常及脫軌(Abberation)，理由是：\n");
	            br4 = element("br");
	            t6 = text("一）大正藏係由學者主導，而自二千五百年前，佛陀入滅不久後的王舍城七葉窟結集以來，古今中外歷代翻譯編修佛經皆由僧團主持。\n");
	            br5 = element("br");
	            a1 = element("a");
	            a1.textContent = "大蔵出版株式会社";
	            t8 = text("以編製校勘產生的法律保障，不許他人販售該版佛經，這違反佛經自古以來自由公開的天然屬性。\n");
	            br6 = element("br");
	            t9 = text("而CBETA的大正藏授權來自於日本，換言之，任何在其上的加工與加值，都受相關著作權法的");
	            a2 = element("a");
	            a2.textContent = "制約";
	            t11 = text("。\n");
	            br7 = element("br");
	            t12 = text("二）佛經不能只是學者的研究材料，也不該是燙金精印、絲綢包裹但卻束之高閣的文物，必須是任何人都容易親近的結緣品。\n");
	            br8 = element("br");
	            t13 = text("我們無法容忍一家日本書商限制佛經流通方式，我們必須捍衛佛經「三根普被」的自由。\n");
	            br9 = element("br");
	            br10 = element("br");
	            t14 = text("如今我們擁有幾項前人難以想像的技術條件，正是打破這個尷尬局面的大好機會。\n");
	            br11 = element("br");
	            t15 = text("一）大正藏考察了多個佛經版本，將經文的差異製成校勘，節省了學者蒐集資料的時間，這是大正藏的核心價值。因為在紙本時代，不可能人人坐擁所有版本的佛經，校勘在某個意義上起到，同時參照多個版本的作用。\n");
	            br12 = element("br");
	            t16 = text("但校勘畢竟是二手資料，保真度遠不如原始文物，如今所有經文掃圖檔（公有財產）得以納入行動載具，只要建立了圖檔之間的對照關係，從任何一段經文可輕易地調閱所有版本的原始圖檔，校勘之重要性大減。\n");
	            br13 = element("br");
	            t17 = text("二）古代佛經主要是印度文明和中華文明（以及兩者幅射區域）的結晶，但受限於彼此高昂的交流成本（當年取經本身就是九死一生的冒險），其編製體例不可能有事先商議好的規範，這就造成各種版本和語系的佛經很難彼此參照驗證，也讓魚目混珠的現象難以杜絕與防犯。\n");
	            br14 = element("br");
	            t18 = text("三）將所有版本和譯本的佛經整合，統一參照系統的工作，我們稱之為「經同軌」，不止是經文目錄層級的對照（目錄提供某標題的各種版本和譯本的收錄情況及所在位置），而是更進一步做到每個句子的精準對應。\n");
	            br15 = element("br");
	            t19 = text("舉例來說，給定任何一句經文，電腦將有能力告知對應的原文以及各種譯文，反之亦然。即所謂的「平行語料庫」，這也是自然語言處理（如機器翻譯）的基礎材料。\n");
	            br16 = element("br");
	            t20 = text("四）「經同軌」，即佛經句子層級的對應，提供了比辭典更有效的學習材料，也可以化解辭典無法處理的語境(context)和多義(ambiguity) 關係。\n");
	            br17 = element("br");
	            t21 = text("閱讀古文難點不在查字典本身，而是查到之後，義項(senses)太多，挑選困難，一個句子只要有幾個生字，每個生字又有幾個可能的解釋，產生歧義的現象將呈指數上升。\n");
	            br18 = element("br");
	            t22 = text("五）近年來電腦越來越快，即使是手機也能以不到一秒以查找整部大藏經。於是瓶頸是使用者輸入文字的速度，以前是人等電腦，如今則是反過來。\n");
	            br19 = element("br");
	            t23 = text("因此，軟件的重點應該盡量掌握讀者所在的語境，做一些背景工作。舉例而言，讀者卡停在某個頁面，背景程式就開始搜羅彙整該頁的相關訊息，\n");
	            br20 = element("br");
	            t24 = text("即：這一頁有哪些艱澀名詞？哪些法師講過這段經文？哪些其他經文可以幫助閱讀理解這頁經文？\n");
	            br21 = element("br");
	            t25 = text("六）古代藏經雕刻耗費的人力物力極為驚人，從譯經、編輯團隊，到媒材的準備，抄寫刻字工，印刷及發行流通，是非常龐大的生產鏈。\n");
	            br22 = element("br");
	            br23 = element("br");
	            t26 = text("成功的藏經，至少有兩個必要條件，一是政權的同意，二是足夠的經費。皇帝未必真心信佛，和尚也未必服膺統治，但佛經想要存活，卷首少不了歌功頌德。\n");
	            br24 = element("br");
	            t27 = text("贊助刻經的，婦女是主力，後宮妃女的捐獻記錄，在藏經中保留很多。\n");
	            br25 = element("br");
	            t28 = text("台灣第一部大正藏，是孫張清揚（孫立人將軍夫人）變賣首飾，從日本運來的。\n");
	            br26 = element("br");
	            t29 = text("如今我們做手機版，也應該比照古人的辦法，將緇素二眾的護持事蹟編入藏經，我們這一代也作出了無愧先人、讓後人感念的貢獻。\n");
	            br27 = element("br");
	            br28 = element("br");
	            t30 = text("因此，我們決心以已成為人類公共財產的中土大藏經為基礎材料，從頭做起，初步計劃是：\n");
	            br29 = element("br");
	            t31 = text("一）以山東圖書館公布之十七萬拍「高清永樂北藏彩圖」為基礎，裁切成適合手機閱讀的50萬折（每拍三折）。每折5行，每行17字，共85個字。\n");
	            br30 = element("br");
	            t32 = text("二）以CBETA校對過的大正藏文字檔為工作底本，按永樂北藏的版式逐句重排，這樣就完全擺脫大正藏的製版權。加工成品採用最寬鬆的授權方式(CC0)，還佛經以最大的自由。\n");
	            br31 = element("br");
	            t33 = text("三）使用者點擊的圖檔任何一處、立即由軟體換算為對應的文字，可搜尋、查字典、連結原文、誦讀、顯示相關的開示錄影等。\n");
	            br32 = element("br");
	            t34 = text("四）取得諸山長老的祝福，我們的目標是只要會按手機，都可以悠遊法海。\n");
	            br33 = element("br");
	            t35 = text("五）由於沒有版權的限制，可以將此成果與置入商品平板電腦，贈與經濟欠發達地區的僧人，以做為國際文化交流的拌手禮。\n");
	            create_component(endmarker.$$.fragment);
	            attr_dev(a0, "target", "_new");
	            attr_dev(a0, "href", "https://docs.google.com/document/d/16m-DGbSTMpM67WSWHaojbRRWtUi2FfovgkdeWhFitKk/edit?usp=sharing");
	            add_location(a0, file$w, 4, 0, 69);
	            add_location(br0, file$w, 6, 0, 270);
	            add_location(br1, file$w, 7, 0, 316);
	            add_location(br2, file$w, 8, 0, 387);
	            add_location(br3, file$w, 10, 0, 482);
	            add_location(br4, file$w, 11, 0, 558);
	            add_location(br5, file$w, 12, 0, 623);
	            attr_dev(a1, "href", "https://www.daizoshuppan.jp/");
	            attr_dev(a1, "target", "_new");
	            add_location(a1, file$w, 12, 5, 628);
	            add_location(br6, file$w, 13, 0, 735);
	            attr_dev(a2, "href", "https://www.cbeta.org/copyright.php");
	            attr_dev(a2, "target", "_new");
	            add_location(a2, file$w, 13, 48, 783);
	            add_location(br7, file$w, 14, 0, 851);
	            add_location(br8, file$w, 15, 0, 912);
	            add_location(br9, file$w, 16, 0, 957);
	            add_location(br10, file$w, 16, 5, 962);
	            add_location(br11, file$w, 17, 0, 1004);
	            add_location(br12, file$w, 18, 0, 1106);
	            add_location(br13, file$w, 19, 0, 1205);
	            add_location(br14, file$w, 20, 0, 1332);
	            add_location(br15, file$w, 21, 0, 1433);
	            add_location(br16, file$w, 22, 0, 1512);
	            add_location(br17, file$w, 23, 0, 1593);
	            add_location(br18, file$w, 24, 0, 1678);
	            add_location(br19, file$w, 25, 0, 1749);
	            add_location(br20, file$w, 26, 0, 1819);
	            add_location(br21, file$w, 27, 0, 1868);
	            add_location(br22, file$w, 28, 0, 1934);
	            add_location(br23, file$w, 28, 5, 1939);
	            add_location(br24, file$w, 29, 0, 2014);
	            add_location(br25, file$w, 30, 0, 2051);
	            add_location(br26, file$w, 31, 0, 2092);
	            add_location(br27, file$w, 32, 0, 2156);
	            add_location(br28, file$w, 32, 5, 2161);
	            add_location(br29, file$w, 33, 0, 2207);
	            add_location(br30, file$w, 34, 0, 2280);
	            add_location(br31, file$w, 35, 0, 2368);
	            add_location(br32, file$w, 36, 0, 2430);
	            add_location(br33, file$w, 37, 0, 2469);
	            add_location(div, file$w, 3, 0, 63);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, a0);
	            append_dev(div, t1);
	            append_dev(div, br0);
	            append_dev(div, t2);
	            append_dev(div, br1);
	            append_dev(div, t3);
	            append_dev(div, br2);
	            append_dev(div, t4);
	            append_dev(div, br3);
	            append_dev(div, t5);
	            append_dev(div, br4);
	            append_dev(div, t6);
	            append_dev(div, br5);
	            append_dev(div, a1);
	            append_dev(div, t8);
	            append_dev(div, br6);
	            append_dev(div, t9);
	            append_dev(div, a2);
	            append_dev(div, t11);
	            append_dev(div, br7);
	            append_dev(div, t12);
	            append_dev(div, br8);
	            append_dev(div, t13);
	            append_dev(div, br9);
	            append_dev(div, br10);
	            append_dev(div, t14);
	            append_dev(div, br11);
	            append_dev(div, t15);
	            append_dev(div, br12);
	            append_dev(div, t16);
	            append_dev(div, br13);
	            append_dev(div, t17);
	            append_dev(div, br14);
	            append_dev(div, t18);
	            append_dev(div, br15);
	            append_dev(div, t19);
	            append_dev(div, br16);
	            append_dev(div, t20);
	            append_dev(div, br17);
	            append_dev(div, t21);
	            append_dev(div, br18);
	            append_dev(div, t22);
	            append_dev(div, br19);
	            append_dev(div, t23);
	            append_dev(div, br20);
	            append_dev(div, t24);
	            append_dev(div, br21);
	            append_dev(div, t25);
	            append_dev(div, br22);
	            append_dev(div, br23);
	            append_dev(div, t26);
	            append_dev(div, br24);
	            append_dev(div, t27);
	            append_dev(div, br25);
	            append_dev(div, t28);
	            append_dev(div, br26);
	            append_dev(div, t29);
	            append_dev(div, br27);
	            append_dev(div, br28);
	            append_dev(div, t30);
	            append_dev(div, br29);
	            append_dev(div, t31);
	            append_dev(div, br30);
	            append_dev(div, t32);
	            append_dev(div, br31);
	            append_dev(div, t33);
	            append_dev(div, br32);
	            append_dev(div, t34);
	            append_dev(div, br33);
	            append_dev(div, t35);
	            mount_component(endmarker, div, null);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_component(endmarker);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$y.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$y($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Project', slots, []);
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Project> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            Endmarker
	        });
	    return [];
	}
	class Project extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$y, create_fragment$y, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Project",
	            options,
	            id: create_fragment$y.name
	        });
	    }
	}

	const file$v = "src\\styleintro.svelte";
	function get_each_context$e(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[2] = list[i];
	    return child_ctx;
	}
	// (23:0) {#each lines as line}
	function create_each_block$e(ctx) {
	    let div;
	    let t_value = /*line*/ ctx[2] + "";
	    let t;
	    const block = {
	        c: function create() {
	            div = element("div");
	            t = text(t_value);
	            add_location(div, file$v, 23, 0, 570);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, t);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*lines*/ 1 && t_value !== (t_value = /*line*/ ctx[2] + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$e.name,
	        type: "each",
	        source: "(23:0) {#each lines as line}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$x(ctx) {
	    let div;
	    let each_value = ensure_array_like_dev(/*lines*/ ctx[0]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            div = element("div");
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            add_location(div, file$v, 21, 0, 542);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div, null);
	                }
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*lines*/ 1) {
	                each_value = ensure_array_like_dev(/*lines*/ ctx[0]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$e(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$e(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div, null);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$x.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$x($$self, $$props, $$invalidate) {
	    let lines;
	    let $tosim;
	    validate_store(tosim, 'tosim');
	    component_subscribe($$self, tosim, ($$value)=>$$invalidate(1, $tosim = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Styleintro', slots, []);
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Styleintro> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            tosim,
	            _,
	            lines,
	            $tosim
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('lines' in $$props) $$invalidate(0, lines = $$props.lines);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$tosim*/ 2) {
	            $$invalidate(0, lines = _(`永樂藏：只是產品名稱，不是文獻學意義的藏經版本。
圖版：以山東圖書館藏永樂北藏為主，整卷缺漏或嚴重錯版（如增壹阿含卷23）改用同館永樂南藏，缺漏幾頁以乾隆大藏經補之。
文字：以CBETA為底本，只有字數不一致的情況才會修改，不保證與圖版一致。
不是永樂北藏、也不是大正藏的電子版，只是為了方便搜尋，不適合學術引用。
標點：使用CBETA bookcase_v074_20221027 版經文的標點。
聲音：為節約帶寬降為48~96kpbs，需要原始音質，請打開「顯示油管影片連結」。
唯名：性空唯名系經典。
唯心：真常唯心系經典。
經號：四部阿含使用大正藏經號。外連巴利藏使用緬甸版編號。
文件結構：
書號：英文字，agmm （中阿含經）
卷號：英文字加卷數，如agmm1。每卷對應一個圖版壓縮檔。
項號：對應到目次的一個項目。
段號：一段經文。也是雜阿含的一經。
文字檔的一行為一句經文、搜尋結果的最小顯示單元。

無量壽經句子對齊未完成。`, $tosim).split(/\r?\n/));
	        }
	    };
	    return [
	        lines,
	        $tosim
	    ];
	}
	class Styleintro extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$x, create_fragment$x, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Styleintro",
	            options,
	            id: create_fragment$x.name
	        });
	    }
	}

	const file$u = "src\\materials.svelte";
	function create_fragment$w(ctx) {
	    let t0_value = _("基於以下公開素材：") + "";
	    let t0;
	    let t1;
	    let br0;
	    let t2_value = _("永樂北藏、南藏圖檔(山東省圖書館)") + "";
	    let t2;
	    let t3;
	    let br1;
	    let t4_value = _("經文及新式標點(CBETA)") + "";
	    let t4;
	    let t5;
	    let br2;
	    let t6_value = _("金剛經集註(朱棣)") + "";
	    let t6;
	    let t7;
	    let br3;
	    let t8;
	    let a0;
	    let t10;
	    let br4;
	    let t11_value = _("梵漢佛經對勘叢書(黃寶生，中國社會科學出版社)") + "";
	    let t11;
	    let t12;
	    let br5;
	    let t13_value = _("四部阿含相似經文對照表") + "";
	    let t13;
	    let a1;
	    let t15;
	    let br6;
	    let t16_value = _("一行佛學詞典之詞條") + "";
	    let t16;
	    let t17;
	    let br7;
	    let t18_value = _("油管公開誦經影片") + "";
	    let t18;
	    let t19;
	    let hr0;
	    let t20;
	    let t21_value = _("進行以下加工：") + "";
	    let t21;
	    let t22;
	    let br8;
	    let t23_value = _("按手機比例裁圖及修圖") + "";
	    let t23;
	    let t24;
	    let br9;
	    let t25_value = _("文字與圖片逐頁逐行對齊") + "";
	    let t25;
	    let t26;
	    let br10;
	    let t27_value = _("原文及各種譯本逐句對齊") + "";
	    let t27;
	    let t28;
	    let br11;
	    let t29_value = _("誦經與圖片同步時間軸") + "";
	    let t29;
	    let t30;
	    let hr1;
	    let t31;
	    let br12;
	    let t32_value = _("成品數據庫分享方式") + "";
	    let t32;
	    let t33;
	    let br13;
	    let a2;
	    let t35;
	    let endmarker;
	    let current;
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            t0 = text(t0_value);
	            t1 = space();
	            br0 = element("br");
	            t2 = text(t2_value);
	            t3 = space();
	            br1 = element("br");
	            t4 = text(t4_value);
	            t5 = space();
	            br2 = element("br");
	            t6 = text(t6_value);
	            t7 = space();
	            br3 = element("br");
	            t8 = text("梵文原典 ");
	            a0 = element("a");
	            a0.textContent = "Digital Sanskrit Buddhist Canon";
	            t10 = space();
	            br4 = element("br");
	            t11 = text(t11_value);
	            t12 = space();
	            br5 = element("br");
	            t13 = text(t13_value);
	            a1 = element("a");
	            a1.textContent = "SuttaCentral";
	            t15 = space();
	            br6 = element("br");
	            t16 = text(t16_value);
	            t17 = space();
	            br7 = element("br");
	            t18 = text(t18_value);
	            t19 = space();
	            hr0 = element("hr");
	            t20 = space();
	            t21 = text(t21_value);
	            t22 = space();
	            br8 = element("br");
	            t23 = text(t23_value);
	            t24 = space();
	            br9 = element("br");
	            t25 = text(t25_value);
	            t26 = space();
	            br10 = element("br");
	            t27 = text(t27_value);
	            t28 = space();
	            br11 = element("br");
	            t29 = text(t29_value);
	            t30 = space();
	            hr1 = element("hr");
	            t31 = space();
	            br12 = element("br");
	            t32 = text(t32_value);
	            t33 = space();
	            br13 = element("br");
	            a2 = element("a");
	            a2.textContent = `${_("CC0 1.0 通用公共領域貢獻")}`;
	            t35 = space();
	            create_component(endmarker.$$.fragment);
	            add_location(br0, file$u, 5, 0, 111);
	            add_location(br1, file$u, 6, 0, 141);
	            add_location(br2, file$u, 7, 0, 168);
	            add_location(br3, file$u, 8, 0, 190);
	            attr_dev(a0, "target", "_new");
	            attr_dev(a0, "href", "https://www.dsbcproject.org/");
	            add_location(a0, file$u, 8, 10, 200);
	            add_location(br4, file$u, 9, 0, 287);
	            add_location(br5, file$u, 10, 0, 323);
	            attr_dev(a1, "target", "_new");
	            attr_dev(a1, "href", "https://suttacentral.net/");
	            add_location(a1, file$u, 10, 23, 346);
	            add_location(br6, file$u, 11, 0, 411);
	            add_location(br7, file$u, 12, 0, 433);
	            add_location(hr0, file$u, 13, 0, 454);
	            add_location(br8, file$u, 15, 0, 475);
	            add_location(br9, file$u, 16, 0, 498);
	            add_location(br10, file$u, 17, 0, 522);
	            add_location(br11, file$u, 18, 0, 546);
	            add_location(hr1, file$u, 19, 0, 569);
	            add_location(br12, file$u, 20, 0, 575);
	            add_location(br13, file$u, 21, 0, 597);
	            attr_dev(a2, "target", "_new");
	            attr_dev(a2, "href", "https://creativecommons.org/publicdomain/zero/1.0/deed.zh");
	            add_location(a2, file$u, 21, 5, 602);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t0, anchor);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, br0, anchor);
	            insert_dev(target, t2, anchor);
	            insert_dev(target, t3, anchor);
	            insert_dev(target, br1, anchor);
	            insert_dev(target, t4, anchor);
	            insert_dev(target, t5, anchor);
	            insert_dev(target, br2, anchor);
	            insert_dev(target, t6, anchor);
	            insert_dev(target, t7, anchor);
	            insert_dev(target, br3, anchor);
	            insert_dev(target, t8, anchor);
	            insert_dev(target, a0, anchor);
	            insert_dev(target, t10, anchor);
	            insert_dev(target, br4, anchor);
	            insert_dev(target, t11, anchor);
	            insert_dev(target, t12, anchor);
	            insert_dev(target, br5, anchor);
	            insert_dev(target, t13, anchor);
	            insert_dev(target, a1, anchor);
	            insert_dev(target, t15, anchor);
	            insert_dev(target, br6, anchor);
	            insert_dev(target, t16, anchor);
	            insert_dev(target, t17, anchor);
	            insert_dev(target, br7, anchor);
	            insert_dev(target, t18, anchor);
	            insert_dev(target, t19, anchor);
	            insert_dev(target, hr0, anchor);
	            insert_dev(target, t20, anchor);
	            insert_dev(target, t21, anchor);
	            insert_dev(target, t22, anchor);
	            insert_dev(target, br8, anchor);
	            insert_dev(target, t23, anchor);
	            insert_dev(target, t24, anchor);
	            insert_dev(target, br9, anchor);
	            insert_dev(target, t25, anchor);
	            insert_dev(target, t26, anchor);
	            insert_dev(target, br10, anchor);
	            insert_dev(target, t27, anchor);
	            insert_dev(target, t28, anchor);
	            insert_dev(target, br11, anchor);
	            insert_dev(target, t29, anchor);
	            insert_dev(target, t30, anchor);
	            insert_dev(target, hr1, anchor);
	            insert_dev(target, t31, anchor);
	            insert_dev(target, br12, anchor);
	            insert_dev(target, t32, anchor);
	            insert_dev(target, t33, anchor);
	            insert_dev(target, br13, anchor);
	            insert_dev(target, a2, anchor);
	            insert_dev(target, t35, anchor);
	            mount_component(endmarker, target, anchor);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(br0);
	                detach_dev(t2);
	                detach_dev(t3);
	                detach_dev(br1);
	                detach_dev(t4);
	                detach_dev(t5);
	                detach_dev(br2);
	                detach_dev(t6);
	                detach_dev(t7);
	                detach_dev(br3);
	                detach_dev(t8);
	                detach_dev(a0);
	                detach_dev(t10);
	                detach_dev(br4);
	                detach_dev(t11);
	                detach_dev(t12);
	                detach_dev(br5);
	                detach_dev(t13);
	                detach_dev(a1);
	                detach_dev(t15);
	                detach_dev(br6);
	                detach_dev(t16);
	                detach_dev(t17);
	                detach_dev(br7);
	                detach_dev(t18);
	                detach_dev(t19);
	                detach_dev(hr0);
	                detach_dev(t20);
	                detach_dev(t21);
	                detach_dev(t22);
	                detach_dev(br8);
	                detach_dev(t23);
	                detach_dev(t24);
	                detach_dev(br9);
	                detach_dev(t25);
	                detach_dev(t26);
	                detach_dev(br10);
	                detach_dev(t27);
	                detach_dev(t28);
	                detach_dev(br11);
	                detach_dev(t29);
	                detach_dev(t30);
	                detach_dev(hr1);
	                detach_dev(t31);
	                detach_dev(br12);
	                detach_dev(t32);
	                detach_dev(t33);
	                detach_dev(br13);
	                detach_dev(a2);
	                detach_dev(t35);
	            }
	            destroy_component(endmarker, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$w.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$w($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Materials', slots, []);
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Materials> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            _,
	            Endmarker
	        });
	    return [];
	}
	class Materials extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$w, create_fragment$w, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Materials",
	            options,
	            id: create_fragment$w.name
	        });
	    }
	}

	const file$t = "src\\checkupdate.svelte";
	function get_each_context$d(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[8] = list[i][0];
	    child_ctx[9] = list[i][1];
	    child_ctx[11] = i;
	    return child_ctx;
	}
	// (47:0) {#if status=='hasupdate'}
	function create_if_block_1$9(ctx) {
	    let span;
	    let t_value = _('更新', /*$tosim*/ ctx[2]) + /*ptkname*/ ctx[8] + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[5](/*idx*/ ctx[11]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable hyperlink needupdate");
	            add_location(span, file$t, 47, 0, 1450);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*$tosim, updatestatus*/ 5 && t_value !== (t_value = _('更新', /*$tosim*/ ctx[2]) + /*ptkname*/ ctx[8] + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$9.name,
	        type: "if",
	        source: "(47:0) {#if status=='hasupdate'}",
	        ctx
	    });
	    return block;
	}
	// (46:0) {#each updatestatus as [ptkname,status],idx}
	function create_each_block$d(ctx) {
	    let if_block_anchor;
	    let if_block = /*status*/ ctx[9] == 'hasupdate' && create_if_block_1$9(ctx);
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (/*status*/ ctx[9] == 'hasupdate') {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block_1$9(ctx);
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$d.name,
	        type: "each",
	        source: "(46:0) {#each updatestatus as [ptkname,status],idx}",
	        ctx
	    });
	    return block;
	}
	// (53:0) {#if !$hasupdate}
	function create_if_block$h(ctx) {
	    let t_value = _("數據庫是最新版", /*$tosim*/ ctx[2]) + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*$tosim*/ 4 && t_value !== (t_value = _("數據庫是最新版", /*$tosim*/ ctx[2]) + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$h.name,
	        type: "if",
	        source: "(53:0) {#if !$hasupdate}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$v(ctx) {
	    let t0;
	    let t1;
	    let t2;
	    let if_block_anchor;
	    let each_value = ensure_array_like_dev(/*updatestatus*/ ctx[0]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
	    }
	    let if_block = !/*$hasupdate*/ ctx[3] && create_if_block$h(ctx);
	    const block = {
	        c: function create() {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            t0 = space();
	            t1 = text(/*downloadmsg*/ ctx[1]);
	            t2 = space();
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, t0, anchor);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, t2, anchor);
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*updateptk, $tosim, updatestatus*/ 21) {
	                each_value = ensure_array_like_dev(/*updatestatus*/ ctx[0]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$d(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$d(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(t0.parentNode, t0);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	            if (dirty & /*downloadmsg*/ 2) set_data_dev(t1, /*downloadmsg*/ ctx[1]);
	            if (!/*$hasupdate*/ ctx[3]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block$h(ctx);
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(t2);
	                detach_dev(if_block_anchor);
	            }
	            destroy_each(each_blocks, detaching);
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$v.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$v($$self, $$props, $$invalidate) {
	    let $tosim;
	    let $hasupdate;
	    validate_store(tosim, 'tosim');
	    component_subscribe($$self, tosim, ($$value)=>$$invalidate(2, $tosim = $$value));
	    validate_store(hasupdate, 'hasupdate');
	    component_subscribe($$self, hasupdate, ($$value)=>$$invalidate(3, $hasupdate = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Checkupdate', slots, []);
	    let updatestatus = [];
	    let needupdate = 0;
	    onMount(async ()=>{
	        $$invalidate(0, updatestatus = allptks.map((it)=>[
	                it,
	                'checking'
	            ]));
	        needupdate = allptks.length;
	        for(let i = 0; i < allptks.length; i++){
	            const same = await isLatest(allptks[i] + '.ptk', CacheName);
	            $$invalidate(0, updatestatus[i][1] = same ? '' : 'hasupdate', updatestatus);
	            if (same) needupdate--;
	        }
	        hasupdate.set(needupdate > 0);
	        $$invalidate(0, updatestatus);
	    });
	    let downloading = false, downloadmsg = '';
	    const updateptk = async (idx)=>{
	        const name = updatestatus[idx][0];
	        if (downloading) return;
	        downloading = true;
	        //append timestamp to url to force check 
	        const res = await downloadToCache(CacheName, name + '.ptk?' + new Date().toISOString(), (msg)=>{
	            $$invalidate(1, downloadmsg = msg);
	        });
	        poolDel(name);
	        const buf = await res.arrayBuffer();
	        const ptk = await openPtk(name, new Uint8Array(buf));
	        enableAccelon23Features(ptk);
	        downloading = false;
	        $$invalidate(0, updatestatus[idx][1] = '', updatestatus);
	        $$invalidate(0, updatestatus);
	        $$invalidate(1, downloadmsg = '');
	        needupdate--;
	        hasupdate.set(needupdate > 0);
	    };
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Checkupdate> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (idx)=>updateptk(idx);
	    $$self.$capture_state = ()=>({
	            tosim,
	            hasupdate,
	            allptks,
	            onMount,
	            isLatest,
	            downloadToCache,
	            enableAccelon23Features,
	            poolDel,
	            openPtk,
	            CacheName,
	            _,
	            updatestatus,
	            needupdate,
	            downloading,
	            downloadmsg,
	            updateptk,
	            $tosim,
	            $hasupdate
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('updatestatus' in $$props) $$invalidate(0, updatestatus = $$props.updatestatus);
	        if ('needupdate' in $$props) needupdate = $$props.needupdate;
	        if ('downloading' in $$props) downloading = $$props.downloading;
	        if ('downloadmsg' in $$props) $$invalidate(1, downloadmsg = $$props.downloadmsg);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        updatestatus,
	        downloadmsg,
	        $tosim,
	        $hasupdate,
	        updateptk,
	        click_handler
	    ];
	}
	class Checkupdate extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$v, create_fragment$v, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Checkupdate",
	            options,
	            id: create_fragment$v.name
	        });
	    }
	}

	const { Object: Object_1 } = globals;
	const file$s = "src\\comps\\statebutton.svelte";
	function create_fragment$u(ctx) {
	    let span1;
	    let span0;
	    let raw_value = /*highlight*/ ctx[4](/*caption*/ ctx[1], /*selectedIndex*/ ctx[0]) + "";
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span1 = element("span");
	            span0 = element("span");
	            add_location(span0, file$s, 56, 4, 1707);
	            attr_dev(span1, "class", "statebutton");
	            attr_dev(span1, "title", /*title*/ ctx[3]);
	            attr_dev(span1, "aria-hidden", true);
	            toggle_class(span1, "disabled", /*disabled*/ ctx[2]);
	            toggle_class(span1, "unselected", /*selectedIndex*/ ctx[0] == -1);
	            add_location(span1, file$s, 55, 0, 1579);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span1, anchor);
	            append_dev(span1, span0);
	            span0.innerHTML = raw_value;
	            if (!mounted) {
	                dispose = listen_dev(span1, "click", /*click*/ ctx[5], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*caption, selectedIndex*/ 3 && raw_value !== (raw_value = /*highlight*/ ctx[4](/*caption*/ ctx[1], /*selectedIndex*/ ctx[0]) + "")) span0.innerHTML = raw_value;
	            if (dirty & /*title*/ 8) {
	                attr_dev(span1, "title", /*title*/ ctx[3]);
	            }
	            if (dirty & /*disabled*/ 4) {
	                toggle_class(span1, "disabled", /*disabled*/ ctx[2]);
	            }
	            if (dirty & /*selectedIndex*/ 1) {
	                toggle_class(span1, "unselected", /*selectedIndex*/ ctx[0] == -1);
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span1);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$u.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$u($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Statebutton', slots, []);
	    let { onclick = null } = $$props;
	    let { disabled = false } = $$props;
	    let { title = '' } = $$props;
	    let { states = {} } = $$props;
	    let { storeid = null } = $$props;
	    let { styles = null } = $$props;
	    let { caption = '' } = $$props;
	    let unselectedcaption = caption;
	    let { unselectable = false } = $$props;
	    const statekeys = Object.keys(states);
	    let { selectedIndex = storeid && statekeys.indexOf(get_store_value(storeid).toString()) || -1 } = $$props;
	    if (selectedIndex == -1 && !unselectable) {
	        //invalid value
	        selectedIndex = 0; //force to first value
	        if (storeid && get_store_value(storeid).toString() !== statekeys[selectedIndex]) storeid.set(statekeys[selectedIndex]);
	    }
	    const setcaption = ()=>{
	        if (storeid) $$invalidate(1, caption = states[get_store_value(storeid)]);
	        else $$invalidate(1, caption = selectedIndex == -1 ? unselectedcaption : states[selectedIndex]);
	    };
	    const highlight = (str, selectedIndex)=>{
	        if (!styles) return str;
	        return str.replace(/\$(\w+)/g, (m, m1)=>{
	            if (typeof styles[m1] == 'string') {
	                return styles[m1];
	            } else if (typeof styles == 'function') {
	                return styles(m1);
	            } else {
	                return get_store_value(styles[m1]) || 'auto';
	            }
	        });
	    };
	    const click = (evt)=>{
	        if (disabled) return;
	        $$invalidate(0, selectedIndex++, selectedIndex);
	        if (selectedIndex >= statekeys.length) {
	            if (unselectable) {
	                if (selectedIndex == -1) $$invalidate(0, selectedIndex = 0);
	                else $$invalidate(0, selectedIndex = -1);
	            } else $$invalidate(0, selectedIndex = 0);
	        }
	        if (storeid) storeid.set(statekeys[selectedIndex]);
	        onclick && onclick(selectedIndex);
	    };
	    onMount(()=>setcaption());
	    const writable_props = [
	        'onclick',
	        'disabled',
	        'title',
	        'states',
	        'storeid',
	        'styles',
	        'caption',
	        'unselectable',
	        'selectedIndex'
	    ];
	    Object_1.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Statebutton> was created with unknown prop '${key}'`);
	    });
	    $$self.$$set = ($$props)=>{
	        if ('onclick' in $$props) $$invalidate(6, onclick = $$props.onclick);
	        if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
	        if ('title' in $$props) $$invalidate(3, title = $$props.title);
	        if ('states' in $$props) $$invalidate(7, states = $$props.states);
	        if ('storeid' in $$props) $$invalidate(8, storeid = $$props.storeid);
	        if ('styles' in $$props) $$invalidate(9, styles = $$props.styles);
	        if ('caption' in $$props) $$invalidate(1, caption = $$props.caption);
	        if ('unselectable' in $$props) $$invalidate(10, unselectable = $$props.unselectable);
	        if ('selectedIndex' in $$props) $$invalidate(0, selectedIndex = $$props.selectedIndex);
	    };
	    $$self.$capture_state = ()=>({
	            onMount,
	            get: get_store_value,
	            onclick,
	            disabled,
	            title,
	            states,
	            storeid,
	            styles,
	            caption,
	            unselectedcaption,
	            unselectable,
	            statekeys,
	            selectedIndex,
	            setcaption,
	            highlight,
	            click
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('onclick' in $$props) $$invalidate(6, onclick = $$props.onclick);
	        if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
	        if ('title' in $$props) $$invalidate(3, title = $$props.title);
	        if ('states' in $$props) $$invalidate(7, states = $$props.states);
	        if ('storeid' in $$props) $$invalidate(8, storeid = $$props.storeid);
	        if ('styles' in $$props) $$invalidate(9, styles = $$props.styles);
	        if ('caption' in $$props) $$invalidate(1, caption = $$props.caption);
	        if ('unselectedcaption' in $$props) unselectedcaption = $$props.unselectedcaption;
	        if ('unselectable' in $$props) $$invalidate(10, unselectable = $$props.unselectable);
	        if ('selectedIndex' in $$props) $$invalidate(0, selectedIndex = $$props.selectedIndex);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*selectedIndex*/ 1) {
	            setcaption();
	        }
	    };
	    return [
	        selectedIndex,
	        caption,
	        disabled,
	        title,
	        highlight,
	        click,
	        onclick,
	        states,
	        storeid,
	        styles,
	        unselectable
	    ];
	}
	class Statebutton extends SvelteComponentDev {
	    get onclick() {
	        throw new Error("<Statebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set onclick(value) {
	        throw new Error("<Statebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get disabled() {
	        throw new Error("<Statebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set disabled(value) {
	        throw new Error("<Statebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get title() {
	        throw new Error("<Statebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set title(value) {
	        throw new Error("<Statebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get states() {
	        throw new Error("<Statebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set states(value) {
	        throw new Error("<Statebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get storeid() {
	        throw new Error("<Statebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set storeid(value) {
	        throw new Error("<Statebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get styles() {
	        throw new Error("<Statebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set styles(value) {
	        throw new Error("<Statebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get caption() {
	        throw new Error("<Statebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set caption(value) {
	        throw new Error("<Statebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get unselectable() {
	        throw new Error("<Statebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set unselectable(value) {
	        throw new Error("<Statebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get selectedIndex() {
	        throw new Error("<Statebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set selectedIndex(value) {
	        throw new Error("<Statebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$u, create_fragment$u, safe_not_equal, {
	            onclick: 6,
	            disabled: 2,
	            title: 3,
	            states: 7,
	            storeid: 8,
	            styles: 9,
	            caption: 1,
	            unselectable: 10,
	            selectedIndex: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Statebutton",
	            options,
	            id: create_fragment$u.name
	        });
	    }
	}

	const file$r = "src\\about.svelte";
	// (67:0) {#if $vip && getVip("title")}
	function create_if_block_6$1(ctx) {
	    let span;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span = element("span");
	            span.textContent = `${_("項目")}`;
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*show*/ ctx[0] == 6);
	            add_location(span, file$r, 67, 0, 2616);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*toggleshowstyle*/ ctx[13], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*show*/ 1) {
	                toggle_class(span, "selected", /*show*/ ctx[0] == 6);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_6$1.name,
	        type: "if",
	        source: "(67:0) {#if $vip && getVip(\\\"title\\\")}",
	        ctx
	    });
	    return block;
	}
	// (60:0) {#key $tosim}
	function create_key_block_2(ctx) {
	    let span0;
	    let t1;
	    let span1;
	    let t3;
	    let span2;
	    let t5;
	    let span3;
	    let t7;
	    let show_if = /*$vip*/ ctx[4] && getVip("title");
	    let if_block_anchor;
	    let mounted;
	    let dispose;
	    let if_block = show_if && create_if_block_6$1(ctx);
	    const block = {
	        c: function create() {
	            span0 = element("span");
	            span0.textContent = "芳名";
	            t1 = space();
	            span1 = element("span");
	            span1.textContent = "伙伴";
	            t3 = space();
	            span2 = element("span");
	            span2.textContent = "素材";
	            t5 = space();
	            span3 = element("span");
	            span3.textContent = `${_("關於")}`;
	            t7 = space();
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	            attr_dev(span0, "aria-hidden", "true");
	            attr_dev(span0, "class", "clickable");
	            toggle_class(span0, "selected", /*show*/ ctx[0] == 2);
	            add_location(span0, file$r, 61, 0, 2145);
	            attr_dev(span1, "aria-hidden", "true");
	            attr_dev(span1, "class", "clickable");
	            toggle_class(span1, "selected", /*show*/ ctx[0] == 3);
	            add_location(span1, file$r, 62, 0, 2252);
	            attr_dev(span2, "aria-hidden", "true");
	            attr_dev(span2, "class", "clickable");
	            toggle_class(span2, "selected", /*show*/ ctx[0] == 4);
	            add_location(span2, file$r, 63, 0, 2360);
	            attr_dev(span3, "aria-hidden", "true");
	            attr_dev(span3, "class", "clickable");
	            toggle_class(span3, "selected", /*show*/ ctx[0] == 5);
	            add_location(span3, file$r, 65, 0, 2471);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span0, anchor);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, span1, anchor);
	            insert_dev(target, t3, anchor);
	            insert_dev(target, span2, anchor);
	            insert_dev(target, t5, anchor);
	            insert_dev(target, span3, anchor);
	            insert_dev(target, t7, anchor);
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	            if (!mounted) {
	                dispose = [
	                    listen_dev(span0, "click", /*toggleshowdonors*/ ctx[10], false, false, false, false),
	                    listen_dev(span1, "click", /*toggleshowworkers*/ ctx[11], false, false, false, false),
	                    listen_dev(span2, "click", /*toggleshowmaterials*/ ctx[12], false, false, false, false),
	                    listen_dev(span3, "click", /*toggleshowproject*/ ctx[14], false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*show*/ 1) {
	                toggle_class(span0, "selected", /*show*/ ctx[0] == 2);
	            }
	            if (dirty & /*show*/ 1) {
	                toggle_class(span1, "selected", /*show*/ ctx[0] == 3);
	            }
	            if (dirty & /*show*/ 1) {
	                toggle_class(span2, "selected", /*show*/ ctx[0] == 4);
	            }
	            if (dirty & /*show*/ 1) {
	                toggle_class(span3, "selected", /*show*/ ctx[0] == 5);
	            }
	            if (dirty & /*$vip*/ 16) show_if = /*$vip*/ ctx[4] && getVip("title");
	            if (show_if) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block_6$1(ctx);
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span0);
	                detach_dev(t1);
	                detach_dev(span1);
	                detach_dev(t3);
	                detach_dev(span2);
	                detach_dev(t5);
	                detach_dev(span3);
	                detach_dev(t7);
	                detach_dev(if_block_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block_2.name,
	        type: "key",
	        source: "(60:0) {#key $tosim}",
	        ctx
	    });
	    return block;
	}
	// (85:0) {:else}
	function create_else_block$7(ctx) {
	    let span;
	    let t0_value = _("永樂藏", /*$tosim*/ ctx[5]) + "";
	    let t0;
	    let t1;
	    let checkupdate;
	    let t2;
	    let previous_key = /*$tosim*/ ctx[5];
	    let t3;
	    let hr;
	    let t4;
	    let slider0;
	    let updating_value;
	    let t5;
	    let br0;
	    let t6_value = _("看不到圖版最底下的行才需要調整", /*$tosim*/ ctx[5]) + "";
	    let t6;
	    let t7;
	    let slider1;
	    let updating_value_1;
	    let t8;
	    let br1;
	    let t9;
	    let previous_key_1 = /*$tosim*/ ctx[5];
	    let t10;
	    let endmarker;
	    let current;
	    checkupdate = new Checkupdate({
	        $$inline: true
	    });
	    let key_block0 = create_key_block_1(ctx);
	    function slider0_value_binding(value) {
	        /*slider0_value_binding*/ ctx[19](value);
	    }
	    let slider0_props = {
	        max: 250,
	        min: 80,
	        $$slots: {
	            caption: [
	                create_caption_slot_1
	            ]
	        },
	        $$scope: {
	            ctx
	        }
	    };
	    if (/*textsz*/ ctx[3] !== void 0) {
	        slider0_props.value = /*textsz*/ ctx[3];
	    }
	    slider0 = new Rangeslider({
	        props: slider0_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(slider0, 'value', slider0_value_binding));
	    slider0.$on("input", debounce(/*setTextsize*/ ctx[16], 300));
	    function slider1_value_binding(value) {
	        /*slider1_value_binding*/ ctx[20](value);
	    }
	    let slider1_props = {
	        max: 100,
	        min: 1,
	        $$slots: {
	            caption: [
	                create_caption_slot$3
	            ]
	        },
	        $$scope: {
	            ctx
	        }
	    };
	    if (/*hratio*/ ctx[2] !== void 0) {
	        slider1_props.value = /*hratio*/ ctx[2];
	    }
	    slider1 = new Rangeslider({
	        props: slider1_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(slider1, 'value', slider1_value_binding));
	    slider1.$on("input", debounce(/*setRatio*/ ctx[15], 300));
	    let key_block1 = create_key_block$8(ctx);
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            span = element("span");
	            t0 = text(t0_value);
	            t1 = space();
	            create_component(checkupdate.$$.fragment);
	            t2 = space();
	            key_block0.c();
	            t3 = space();
	            hr = element("hr");
	            t4 = space();
	            create_component(slider0.$$.fragment);
	            t5 = space();
	            br0 = element("br");
	            t6 = text(t6_value);
	            t7 = space();
	            create_component(slider1.$$.fragment);
	            t8 = space();
	            br1 = element("br");
	            t9 = space();
	            key_block1.c();
	            t10 = space();
	            create_component(endmarker.$$.fragment);
	            attr_dev(span, "class", "logotitle");
	            add_location(span, file$r, 86, 0, 2972);
	            add_location(hr, file$r, 98, 0, 3437);
	            add_location(br0, file$r, 102, 0, 3623);
	            add_location(br1, file$r, 106, 0, 3816);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t0);
	            insert_dev(target, t1, anchor);
	            mount_component(checkupdate, target, anchor);
	            insert_dev(target, t2, anchor);
	            key_block0.m(target, anchor);
	            insert_dev(target, t3, anchor);
	            insert_dev(target, hr, anchor);
	            insert_dev(target, t4, anchor);
	            mount_component(slider0, target, anchor);
	            insert_dev(target, t5, anchor);
	            insert_dev(target, br0, anchor);
	            insert_dev(target, t6, anchor);
	            insert_dev(target, t7, anchor);
	            mount_component(slider1, target, anchor);
	            insert_dev(target, t8, anchor);
	            insert_dev(target, br1, anchor);
	            insert_dev(target, t9, anchor);
	            key_block1.m(target, anchor);
	            insert_dev(target, t10, anchor);
	            mount_component(endmarker, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if ((!current || dirty & /*$tosim*/ 32) && t0_value !== (t0_value = _("永樂藏", /*$tosim*/ ctx[5]) + "")) set_data_dev(t0, t0_value);
	            if (dirty & /*$tosim*/ 32 && safe_not_equal(previous_key, previous_key = /*$tosim*/ ctx[5])) {
	                group_outros();
	                transition_out(key_block0, 1, 1, noop);
	                check_outros();
	                key_block0 = create_key_block_1(ctx);
	                key_block0.c();
	                transition_in(key_block0, 1);
	                key_block0.m(t3.parentNode, t3);
	            } else {
	                key_block0.p(ctx, dirty);
	            }
	            const slider0_changes = {};
	            if (dirty & /*$$scope, $tosim, textsz*/ 536870952) {
	                slider0_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            if (!updating_value && dirty & /*textsz*/ 8) {
	                updating_value = true;
	                slider0_changes.value = /*textsz*/ ctx[3];
	                add_flush_callback(()=>updating_value = false);
	            }
	            slider0.$set(slider0_changes);
	            if ((!current || dirty & /*$tosim*/ 32) && t6_value !== (t6_value = _("看不到圖版最底下的行才需要調整", /*$tosim*/ ctx[5]) + "")) set_data_dev(t6, t6_value);
	            const slider1_changes = {};
	            if (dirty & /*$$scope, hratio*/ 536870916) {
	                slider1_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            if (!updating_value_1 && dirty & /*hratio*/ 4) {
	                updating_value_1 = true;
	                slider1_changes.value = /*hratio*/ ctx[2];
	                add_flush_callback(()=>updating_value_1 = false);
	            }
	            slider1.$set(slider1_changes);
	            if (dirty & /*$tosim*/ 32 && safe_not_equal(previous_key_1, previous_key_1 = /*$tosim*/ ctx[5])) {
	                group_outros();
	                transition_out(key_block1, 1, 1, noop);
	                check_outros();
	                key_block1 = create_key_block$8(ctx);
	                key_block1.c();
	                transition_in(key_block1, 1);
	                key_block1.m(t10.parentNode, t10);
	            } else {
	                key_block1.p(ctx, dirty);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(checkupdate.$$.fragment, local);
	            transition_in(key_block0);
	            transition_in(slider0.$$.fragment, local);
	            transition_in(slider1.$$.fragment, local);
	            transition_in(key_block1);
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(checkupdate.$$.fragment, local);
	            transition_out(key_block0);
	            transition_out(slider0.$$.fragment, local);
	            transition_out(slider1.$$.fragment, local);
	            transition_out(key_block1);
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	                detach_dev(t1);
	                detach_dev(t2);
	                detach_dev(t3);
	                detach_dev(hr);
	                detach_dev(t4);
	                detach_dev(t5);
	                detach_dev(br0);
	                detach_dev(t6);
	                detach_dev(t7);
	                detach_dev(t8);
	                detach_dev(br1);
	                detach_dev(t9);
	                detach_dev(t10);
	            }
	            destroy_component(checkupdate, detaching);
	            key_block0.d(detaching);
	            destroy_component(slider0, detaching);
	            destroy_component(slider1, detaching);
	            key_block1.d(detaching);
	            destroy_component(endmarker, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$7.name,
	        type: "else",
	        source: "(85:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (83:18) 
	function create_if_block_5$2(ctx) {
	    let projectintro;
	    let current;
	    projectintro = new Project({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(projectintro.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(projectintro, target, anchor);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(projectintro.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(projectintro.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(projectintro, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_5$2.name,
	        type: "if",
	        source: "(83:18) ",
	        ctx
	    });
	    return block;
	}
	// (81:18) 
	function create_if_block_4$2(ctx) {
	    let styleintro;
	    let current;
	    styleintro = new Styleintro({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(styleintro.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(styleintro, target, anchor);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(styleintro.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(styleintro.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(styleintro, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_4$2.name,
	        type: "if",
	        source: "(81:18) ",
	        ctx
	    });
	    return block;
	}
	// (79:18) 
	function create_if_block_3$2(ctx) {
	    let materials;
	    let current;
	    materials = new Materials({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(materials.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(materials, target, anchor);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(materials.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(materials.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(materials, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_3$2.name,
	        type: "if",
	        source: "(79:18) ",
	        ctx
	    });
	    return block;
	}
	// (77:18) 
	function create_if_block_2$4(ctx) {
	    let workers;
	    let current;
	    workers = new Workers({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(workers.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(workers, target, anchor);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(workers.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(workers.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(workers, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_2$4.name,
	        type: "if",
	        source: "(77:18) ",
	        ctx
	    });
	    return block;
	}
	// (75:18) 
	function create_if_block_1$8(ctx) {
	    let hof;
	    let current;
	    hof = new Hof({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(hof.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(hof, target, anchor);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(hof.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(hof.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(hof, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$8.name,
	        type: "if",
	        source: "(75:18) ",
	        ctx
	    });
	    return block;
	}
	// (73:0) {#if show==1}
	function create_if_block$g(ctx) {
	    const block = {
	        c: noop,
	        m: noop,
	        p: noop,
	        i: noop,
	        o: noop,
	        d: noop
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$g.name,
	        type: "if",
	        source: "(73:0) {#if show==1}",
	        ctx
	    });
	    return block;
	}
	// (89:0) {#key $tosim}
	function create_key_block_1(ctx) {
	    let br0;
	    let t0_value = _("漢字顯示") + "";
	    let t0;
	    let t1;
	    let statebtn;
	    let t2;
	    let br1;
	    let t3;
	    let t4;
	    let t5_value = (getVip('title', /*$vip*/ ctx[4]) || /*$vip*/ (ctx[4] ? _("查無此碼") : "")) + "";
	    let t5;
	    let t6;
	    let br2;
	    let t7_value = _("VIP碼 ") + "";
	    let t7;
	    let input;
	    let t8;
	    let br3;
	    let t9;
	    let br4;
	    let a;
	    let t11;
	    let br5;
	    let t12_value = _("點焦點文字（紅色背景）分享") + "";
	    let t12;
	    let current;
	    let mounted;
	    let dispose;
	    statebtn = new Statebutton({
	        props: {
	            states: {
	                0: "原貌",
	                1: _("简體（「乾後發」等不變）"),
	                2: "简体"
	            },
	            storeid: tosim
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            br0 = element("br");
	            t0 = text(t0_value);
	            t1 = text("：");
	            create_component(statebtn.$$.fragment);
	            t2 = space();
	            br1 = element("br");
	            t3 = text("版本 ");
	            t4 = text(APPVER);
	            t5 = text(t5_value);
	            t6 = space();
	            br2 = element("br");
	            t7 = text(t7_value);
	            input = element("input");
	            t8 = space();
	            br3 = element("br");
	            t9 = text("微信 Sukhanika\n");
	            br4 = element("br");
	            a = element("a");
	            a.textContent = "sukhanika[at]gmail.com";
	            t11 = space();
	            br5 = element("br");
	            t12 = text(t12_value);
	            add_location(br0, file$r, 89, 0, 3050);
	            add_location(br1, file$r, 90, 0, 3140);
	            add_location(br2, file$r, 91, 0, 3201);
	            attr_dev(input, "placeholder", _("沒有也可正常使用"));
	            attr_dev(input, "size", "12");
	            attr_dev(input, "type", "text");
	            add_location(input, file$r, 91, 17, 3218);
	            add_location(br3, file$r, 94, 0, 3317);
	            add_location(br4, file$r, 95, 0, 3335);
	            attr_dev(a, "href", "mailto:sukhanika@gmail.com");
	            add_location(a, file$r, 95, 5, 3340);
	            add_location(br5, file$r, 96, 0, 3404);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, br0, anchor);
	            insert_dev(target, t0, anchor);
	            insert_dev(target, t1, anchor);
	            mount_component(statebtn, target, anchor);
	            insert_dev(target, t2, anchor);
	            insert_dev(target, br1, anchor);
	            insert_dev(target, t3, anchor);
	            insert_dev(target, t4, anchor);
	            insert_dev(target, t5, anchor);
	            insert_dev(target, t6, anchor);
	            insert_dev(target, br2, anchor);
	            insert_dev(target, t7, anchor);
	            insert_dev(target, input, anchor);
	            set_input_value(input, /*vipcode*/ ctx[1]);
	            insert_dev(target, t8, anchor);
	            insert_dev(target, br3, anchor);
	            insert_dev(target, t9, anchor);
	            insert_dev(target, br4, anchor);
	            insert_dev(target, a, anchor);
	            insert_dev(target, t11, anchor);
	            insert_dev(target, br5, anchor);
	            insert_dev(target, t12, anchor);
	            current = true;
	            if (!mounted) {
	                dispose = [
	                    listen_dev(input, "keyup", /*onkeyup*/ ctx[17], false, false, false, false),
	                    listen_dev(input, "input", /*input_input_handler*/ ctx[18])
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if ((!current || dirty & /*$vip*/ 16) && t5_value !== (t5_value = (getVip('title', /*$vip*/ ctx[4]) || /*$vip*/ (ctx[4] ? _("查無此碼") : "")) + "")) set_data_dev(t5, t5_value);
	            if (dirty & /*vipcode*/ 2 && input.value !== /*vipcode*/ ctx[1]) {
	                set_input_value(input, /*vipcode*/ ctx[1]);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(statebtn.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(statebtn.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(br0);
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(t2);
	                detach_dev(br1);
	                detach_dev(t3);
	                detach_dev(t4);
	                detach_dev(t5);
	                detach_dev(t6);
	                detach_dev(br2);
	                detach_dev(t7);
	                detach_dev(input);
	                detach_dev(t8);
	                detach_dev(br3);
	                detach_dev(t9);
	                detach_dev(br4);
	                detach_dev(a);
	                detach_dev(t11);
	                detach_dev(br5);
	                detach_dev(t12);
	            }
	            destroy_component(statebtn, detaching);
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block_1.name,
	        type: "key",
	        source: "(89:0) {#key $tosim}",
	        ctx
	    });
	    return block;
	}
	// (101:4) 
	function create_caption_slot_1(ctx) {
	    let span;
	    let t0_value = /*textsz*/ ctx[3][0] + "";
	    let t0;
	    let t1;
	    let t2_value = _("字體大小", /*$tosim*/ ctx[5]) + "";
	    let t2;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t0 = text(t0_value);
	            t1 = text("% ");
	            t2 = text(t2_value);
	            attr_dev(span, "slot", "caption");
	            set_style(span, "float", "right");
	            add_location(span, file$r, 100, 4, 3533);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t0);
	            append_dev(span, t1);
	            append_dev(span, t2);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*textsz*/ 8 && t0_value !== (t0_value = /*textsz*/ ctx[3][0] + "")) set_data_dev(t0, t0_value);
	            if (dirty & /*$tosim*/ 32 && t2_value !== (t2_value = _("字體大小", /*$tosim*/ ctx[5]) + "")) set_data_dev(t2, t2_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_caption_slot_1.name,
	        type: "slot",
	        source: "(101:4) ",
	        ctx
	    });
	    return block;
	}
	// (105:0) 
	function create_caption_slot$3(ctx) {
	    let span;
	    let t0_value = /*hratio*/ ctx[2][0] + "";
	    let t0;
	    let t1;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t0 = text(t0_value);
	            t1 = text("% 全屏高度");
	            attr_dev(span, "slot", "caption");
	            set_style(span, "float", "right");
	            add_location(span, file$r, 104, 0, 3740);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t0);
	            append_dev(span, t1);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*hratio*/ 4 && t0_value !== (t0_value = /*hratio*/ ctx[2][0] + "")) set_data_dev(t0, t0_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_caption_slot$3.name,
	        type: "slot",
	        source: "(105:0) ",
	        ctx
	    });
	    return block;
	}
	// (108:0) {#key $tosim}
	function create_key_block$8(ctx) {
	    let switch0;
	    let updating_value;
	    let t0;
	    let switch1;
	    let updating_value_1;
	    let t1;
	    let switch2;
	    let updating_value_2;
	    let t2;
	    let switch3;
	    let updating_value_3;
	    let current;
	    function switch0_value_binding(value) {
	        /*switch0_value_binding*/ ctx[21](value);
	    }
	    let switch0_props = {
	        label: _("顯示標點符號"),
	        design: "slider"
	    };
	    if (/*$showpunc*/ ctx[6] !== void 0) {
	        switch0_props.value = /*$showpunc*/ ctx[6];
	    }
	    switch0 = new Switch({
	        props: switch0_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(switch0, 'value', switch0_value_binding));
	    function switch1_value_binding(value) {
	        /*switch1_value_binding*/ ctx[22](value);
	    }
	    let switch1_props = {
	        label: _("靜置時顯示施主"),
	        design: "slider"
	    };
	    if (/*$showsponsor*/ ctx[7] !== void 0) {
	        switch1_props.value = /*$showsponsor*/ ctx[7];
	    }
	    switch1 = new Switch({
	        props: switch1_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(switch1, 'value', switch1_value_binding));
	    function switch2_value_binding(value) {
	        /*switch2_value_binding*/ ctx[23](value);
	    }
	    let switch2_props = {
	        label: _("顯示油管影片連結"),
	        design: "slider"
	    };
	    if (/*$showyoutube*/ ctx[8] !== void 0) {
	        switch2_props.value = /*$showyoutube*/ ctx[8];
	    }
	    switch2 = new Switch({
	        props: switch2_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(switch2, 'value', switch2_value_binding));
	    function switch3_value_binding(value) {
	        /*switch3_value_binding*/ ctx[24](value);
	    }
	    let switch3_props = {
	        label: _("啟動時顯示歡迎畫面"),
	        design: "slider"
	    };
	    if (/*$newbie*/ ctx[9] !== void 0) {
	        switch3_props.value = /*$newbie*/ ctx[9];
	    }
	    switch3 = new Switch({
	        props: switch3_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(switch3, 'value', switch3_value_binding));
	    const block = {
	        c: function create() {
	            create_component(switch0.$$.fragment);
	            t0 = space();
	            create_component(switch1.$$.fragment);
	            t1 = space();
	            create_component(switch2.$$.fragment);
	            t2 = space();
	            create_component(switch3.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(switch0, target, anchor);
	            insert_dev(target, t0, anchor);
	            mount_component(switch1, target, anchor);
	            insert_dev(target, t1, anchor);
	            mount_component(switch2, target, anchor);
	            insert_dev(target, t2, anchor);
	            mount_component(switch3, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const switch0_changes = {};
	            if (!updating_value && dirty & /*$showpunc*/ 64) {
	                updating_value = true;
	                switch0_changes.value = /*$showpunc*/ ctx[6];
	                add_flush_callback(()=>updating_value = false);
	            }
	            switch0.$set(switch0_changes);
	            const switch1_changes = {};
	            if (!updating_value_1 && dirty & /*$showsponsor*/ 128) {
	                updating_value_1 = true;
	                switch1_changes.value = /*$showsponsor*/ ctx[7];
	                add_flush_callback(()=>updating_value_1 = false);
	            }
	            switch1.$set(switch1_changes);
	            const switch2_changes = {};
	            if (!updating_value_2 && dirty & /*$showyoutube*/ 256) {
	                updating_value_2 = true;
	                switch2_changes.value = /*$showyoutube*/ ctx[8];
	                add_flush_callback(()=>updating_value_2 = false);
	            }
	            switch2.$set(switch2_changes);
	            const switch3_changes = {};
	            if (!updating_value_3 && dirty & /*$newbie*/ 512) {
	                updating_value_3 = true;
	                switch3_changes.value = /*$newbie*/ ctx[9];
	                add_flush_callback(()=>updating_value_3 = false);
	            }
	            switch3.$set(switch3_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(switch0.$$.fragment, local);
	            transition_in(switch1.$$.fragment, local);
	            transition_in(switch2.$$.fragment, local);
	            transition_in(switch3.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(switch0.$$.fragment, local);
	            transition_out(switch1.$$.fragment, local);
	            transition_out(switch2.$$.fragment, local);
	            transition_out(switch3.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(t2);
	            }
	            destroy_component(switch0, detaching);
	            destroy_component(switch1, detaching);
	            destroy_component(switch2, detaching);
	            destroy_component(switch3, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$8.name,
	        type: "key",
	        source: "(108:0) {#key $tosim}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$t(ctx) {
	    let div0;
	    let previous_key = /*$tosim*/ ctx[5];
	    let t;
	    let div1;
	    let current_block_type_index;
	    let if_block;
	    let current;
	    let key_block = create_key_block_2(ctx);
	    const if_block_creators = [
	        create_if_block$g,
	        create_if_block_1$8,
	        create_if_block_2$4,
	        create_if_block_3$2,
	        create_if_block_4$2,
	        create_if_block_5$2,
	        create_else_block$7
	    ];
	    const if_blocks = [];
	    function select_block_type(ctx, dirty) {
	        if (/*show*/ ctx[0] == 1) return 0;
	        if (/*show*/ ctx[0] == 2) return 1;
	        if (/*show*/ ctx[0] == 3) return 2;
	        if (/*show*/ ctx[0] == 4) return 3;
	        if (/*show*/ ctx[0] == 5) return 4;
	        if (/*show*/ ctx[0] == 6) return 5;
	        return 6;
	    }
	    current_block_type_index = select_block_type(ctx);
	    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    const block = {
	        c: function create() {
	            div0 = element("div");
	            key_block.c();
	            t = space();
	            div1 = element("div");
	            if_block.c();
	            attr_dev(div0, "class", "tabs");
	            add_location(div0, file$r, 58, 0, 1985);
	            attr_dev(div1, "class", "bodytext");
	            add_location(div1, file$r, 71, 0, 2749);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div0, anchor);
	            key_block.m(div0, null);
	            insert_dev(target, t, anchor);
	            insert_dev(target, div1, anchor);
	            if_blocks[current_block_type_index].m(div1, null);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*$tosim*/ 32 && safe_not_equal(previous_key, previous_key = /*$tosim*/ ctx[5])) {
	                key_block.d(1);
	                key_block = create_key_block_2(ctx);
	                key_block.c();
	                key_block.m(div0, null);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	            let previous_block_index = current_block_type_index;
	            current_block_type_index = select_block_type(ctx);
	            if (current_block_type_index === previous_block_index) {
	                if_blocks[current_block_type_index].p(ctx, dirty);
	            } else {
	                group_outros();
	                transition_out(if_blocks[previous_block_index], 1, 1, ()=>{
	                    if_blocks[previous_block_index] = null;
	                });
	                check_outros();
	                if_block = if_blocks[current_block_type_index];
	                if (!if_block) {
	                    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	                    if_block.c();
	                } else {
	                    if_block.p(ctx, dirty);
	                }
	                transition_in(if_block, 1);
	                if_block.m(div1, null);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div0);
	                detach_dev(t);
	                detach_dev(div1);
	            }
	            key_block.d(detaching);
	            if_blocks[current_block_type_index].d();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$t.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$t($$self, $$props, $$invalidate) {
	    let $textsize;
	    let $heightratio;
	    let $vip;
	    let $tosim;
	    let $showpunc;
	    let $showsponsor;
	    let $showyoutube;
	    let $newbie;
	    validate_store(textsize, 'textsize');
	    component_subscribe($$self, textsize, ($$value)=>$$invalidate(26, $textsize = $$value));
	    validate_store(heightratio, 'heightratio');
	    component_subscribe($$self, heightratio, ($$value)=>$$invalidate(27, $heightratio = $$value));
	    validate_store(vip, 'vip');
	    component_subscribe($$self, vip, ($$value)=>$$invalidate(4, $vip = $$value));
	    validate_store(tosim, 'tosim');
	    component_subscribe($$self, tosim, ($$value)=>$$invalidate(5, $tosim = $$value));
	    validate_store(showpunc, 'showpunc');
	    component_subscribe($$self, showpunc, ($$value)=>$$invalidate(6, $showpunc = $$value));
	    validate_store(showsponsor, 'showsponsor');
	    component_subscribe($$self, showsponsor, ($$value)=>$$invalidate(7, $showsponsor = $$value));
	    validate_store(showyoutube, 'showyoutube');
	    component_subscribe($$self, showyoutube, ($$value)=>$$invalidate(8, $showyoutube = $$value));
	    validate_store(newbie, 'newbie');
	    component_subscribe($$self, newbie, ($$value)=>$$invalidate(9, $newbie = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('About', slots, []);
	    let show = 0, vipcode = $vip;
	    let hratio = [
	        Math.floor(($heightratio * 100 - 90) * 10),
	        0
	    ];
	    let textsz = [
	        $textsize,
	        0
	    ];
	    const toggleshowsponsoring = ()=>$$invalidate(0, show = show == 1 ? 0 : 1);
	    const toggleshowdonors = ()=>$$invalidate(0, show = show == 2 ? 0 : 2);
	    const toggleshowworkers = ()=>$$invalidate(0, show = show == 3 ? 0 : 3);
	    const toggleshowmaterials = ()=>$$invalidate(0, show = show == 4 ? 0 : 4);
	    const toggleshowstyle = ()=>$$invalidate(0, show = show == 6 ? 0 : 6);
	    const toggleshowproject = ()=>$$invalidate(0, show = show == 5 ? 0 : 5);
	    /*
	const clearCache=async (ext)=>{
	    const cache=await caches.open(CacheName);
	    let keys=await cache.keys();
	    keys=keys.filter(it=>!ext || it.url.endsWith(ext));
	    clearcount=keys.length;
	    keys.forEach(key=>cache.delete(key))
	}*/ const setRatio = (e)=>{
	        const j = e.detail[0] || 100;
	        heightratio.set((j / 10 + 90) / 100);
	        documentHeight();
	    };
	    const setTextsize = (e)=>{
	        const j = e.detail[0] || 100;
	        textsize.set(j);
	    };
	    let timer = 0;
	    const onkeyup = (e)=>{
	        const ele = e.target;
	        const start = ele.selectionStart;
	        const end = ele.selectionEnd;
	        ele.value = ele.value.toUpperCase().replace(/[^a-zA-Z\d]/g, '');
	        ele.setSelectionRange(start, end);
	        clearTimeout(timer);
	        timer = setTimeout(()=>{
	            vip.set(ele.value);
	        }, 1000);
	    };
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<About> was created with unknown prop '${key}'`);
	    });
	    function input_input_handler() {
	        vipcode = this.value;
	        $$invalidate(1, vipcode);
	    }
	    function slider0_value_binding(value) {
	        textsz = value;
	        $$invalidate(3, textsz);
	    }
	    function slider1_value_binding(value) {
	        hratio = value;
	        $$invalidate(2, hratio);
	    }
	    function switch0_value_binding(value) {
	        $showpunc = value;
	        showpunc.set($showpunc);
	    }
	    function switch1_value_binding(value) {
	        $showsponsor = value;
	        showsponsor.set($showsponsor);
	    }
	    function switch2_value_binding(value) {
	        $showyoutube = value;
	        showyoutube.set($showyoutube);
	    }
	    function switch3_value_binding(value) {
	        $newbie = value;
	        newbie.set($newbie);
	    }
	    $$self.$capture_state = ()=>({
	            newbie,
	            showyoutube,
	            showpunc,
	            showsponsor,
	            vip,
	            heightratio,
	            tosim,
	            textsize,
	            _,
	            Switch,
	            HOF: Hof,
	            Workers,
	            ProjectIntro: Project,
	            StyleIntro: Styleintro,
	            Materials,
	            githubicon,
	            Slider: Rangeslider,
	            debounce,
	            documentHeight,
	            CheckUpdate: Checkupdate,
	            StateBtn: Statebutton,
	            Endmarker,
	            APPVER,
	            getVip,
	            show,
	            vipcode,
	            hratio,
	            textsz,
	            toggleshowsponsoring,
	            toggleshowdonors,
	            toggleshowworkers,
	            toggleshowmaterials,
	            toggleshowstyle,
	            toggleshowproject,
	            setRatio,
	            setTextsize,
	            timer,
	            onkeyup,
	            $textsize,
	            $heightratio,
	            $vip,
	            $tosim,
	            $showpunc,
	            $showsponsor,
	            $showyoutube,
	            $newbie
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('show' in $$props) $$invalidate(0, show = $$props.show);
	        if ('vipcode' in $$props) $$invalidate(1, vipcode = $$props.vipcode);
	        if ('hratio' in $$props) $$invalidate(2, hratio = $$props.hratio);
	        if ('textsz' in $$props) $$invalidate(3, textsz = $$props.textsz);
	        if ('timer' in $$props) timer = $$props.timer;
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        show,
	        vipcode,
	        hratio,
	        textsz,
	        $vip,
	        $tosim,
	        $showpunc,
	        $showsponsor,
	        $showyoutube,
	        $newbie,
	        toggleshowdonors,
	        toggleshowworkers,
	        toggleshowmaterials,
	        toggleshowstyle,
	        toggleshowproject,
	        setRatio,
	        setTextsize,
	        onkeyup,
	        input_input_handler,
	        slider0_value_binding,
	        slider1_value_binding,
	        switch0_value_binding,
	        switch1_value_binding,
	        switch2_value_binding,
	        switch3_value_binding
	    ];
	}
	class About extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$t, create_fragment$t, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "About",
	            options,
	            id: create_fragment$t.name
	        });
	    }
	}

	const swipeprev = '<svg width="150px" height="150px" viewBox="0 0 1024 1024" fill="#cfcfcf" color="#000000" ><path d="M768 903.232l-50.432 56.768L256 512l461.568-448 50.432 56.768L364.928 512z" ></path></svg>';
	const swipenext = '<svg width="150px" height="150px" viewBox="0 0 1024 1024" fill="#cfcfcf" color="#000000"><path d="M256 120.768L306.432 64 768 512l-461.568 448L256 903.232 659.072 512z"></path></svg>';

	const file$q = "..\\offtextview\\comps\\swipeview.svelte";
	// (65:0) {#if touching==1&&direction}
	function create_if_block$f(ctx) {
	    let span;
	    let raw_value = /*swipeshapes*/ (ctx[3][/*direction*/ ctx[2] + 1] || "empty") + "";
	    const block = {
	        c: function create() {
	            span = element("span");
	            attr_dev(span, "class", "arrow svelte-5h9ge");
	            add_location(span, file$q, 64, 28, 1413);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            span.innerHTML = raw_value;
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*direction*/ 4 && raw_value !== (raw_value = /*swipeshapes*/ (ctx[3][/*direction*/ ctx[2] + 1] || "empty") + "")) span.innerHTML = raw_value;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$f.name,
	        type: "if",
	        source: "(65:0) {#if touching==1&&direction}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$s(ctx) {
	    let t0;
	    let div;
	    let span;
	    let t1;
	    let t2;
	    let current;
	    let mounted;
	    let dispose;
	    let if_block = /*touching*/ ctx[1] == 1 && /*direction*/ ctx[2] && create_if_block$f(ctx);
	    const default_slot_template = /*#slots*/ ctx[12].default;
	    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            t0 = space();
	            div = element("div");
	            span = element("span");
	            t1 = text(/*caption*/ ctx[0]);
	            t2 = space();
	            if (default_slot) default_slot.c();
	            attr_dev(span, "aria-hidden", "true");
	            add_location(span, file$q, 70, 0, 1668);
	            attr_dev(div, "name", "swipeview");
	            set_style(div, "height", "100%");
	            add_location(div, file$q, 65, 0, 1487);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, t0, anchor);
	            insert_dev(target, div, anchor);
	            append_dev(div, span);
	            append_dev(span, t1);
	            append_dev(div, t2);
	            if (default_slot) {
	                default_slot.m(div, null);
	            }
	            current = true;
	            if (!mounted) {
	                dispose = [
	                    listen_dev(span, "click", /*next*/ ctx[8], false, false, false, false),
	                    listen_dev(div, "touchstart", /*ontouchstart*/ ctx[4], {
	                        passive: true
	                    }, false, false, false),
	                    listen_dev(div, "touchmove", /*ontouchmove*/ ctx[5], {
	                        passive: true
	                    }, false, false, false),
	                    listen_dev(div, "touchend", /*ontouchend*/ ctx[6], {
	                        passive: true
	                    }, false, false, false),
	                    listen_dev(div, "wheel", /*wheel_handler*/ ctx[13], false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (/*touching*/ ctx[1] == 1 && /*direction*/ ctx[2]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block$f(ctx);
	                    if_block.c();
	                    if_block.m(t0.parentNode, t0);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	            if (!current || dirty & /*caption*/ 1) set_data_dev(t1, /*caption*/ ctx[0]);
	            if (default_slot) {
	                if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
	                    update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[11]) : get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null), null);
	                }
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(default_slot, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(default_slot, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(div);
	            }
	            if (if_block) if_block.d(detaching);
	            if (default_slot) default_slot.d(detaching);
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$s.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$s($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Swipeview', slots, [
	        'default'
	    ]);
	    let { onSwipe } = $$props;
	    let { caption = '' } = $$props;
	    let { reverse = false } = $$props;
	    const swipeshapes = [
	        swipeprev,
	        ,
	        swipenext
	    ];
	    let touching = -1;
	    let touchx = 0, touchy = 0, startx = 0, starty = 0, direction = 0;
	    const ontouchstart = (e)=>{
	        $$invalidate(2, direction = 0);
	        if (e.touches.length == 1) {
	            startx = e.touches[0].pageX;
	            starty = e.touches[0].pageY;
	            touchx = startx;
	            touchy = starty;
	            $$invalidate(1, touching = 1);
	        }
	    };
	    const getDirection = ()=>{
	        // if (Math.abs(touchy-starty)>30) return 0;
	        const deltax = touchx - startx;
	        const deltay = touchy - starty;
	        let dir = 0;
	        if (deltax > window.innerWidth / 10 && Math.abs(deltay) < Math.abs(deltax) / 2) {
	            dir = 1;
	        } else if (deltax < -window.innerWidth / 10 && Math.abs(deltay) < Math.abs(deltax) / 2) {
	            dir = -1;
	        }
	        return reverse ? -dir : dir;
	    };
	    const ontouchmove = (e)=>{
	        if (touching == -1) return;
	        if (touching > -1) {
	            touchx = e.touches[0].pageX;
	            touchy = e.touches[0].pageY;
	            $$invalidate(2, direction = getDirection());
	        }
	    };
	    const ontouchend = (e)=>{
	        if (touching !== -1 && direction !== 0) {
	            onSwipe && onSwipe(direction);
	        } // onclick(e,touchx,touchy);
	        $$invalidate(1, touching = -1);
	        $$invalidate(2, direction = 0);
	    };
	    const mousewheel = (e, idx)=>{
	        if (!e.altKey) return;
	        let dir = 1;
	        //if (reverse) dir=-dir;
	        if (e.deltaY > 0) {
	            onSwipe && onSwipe(dir);
	        } else {
	            onSwipe && onSwipe(-dir);
	        }
	        e.preventDefault();
	    };
	    const next = ()=>{
	        onSwipe && onSwipe(1);
	    };
	    $$self.$$.on_mount.push(function() {
	        if (onSwipe === undefined && !('onSwipe' in $$props || $$self.$$.bound[$$self.$$.props['onSwipe']])) {
	            console.warn("<Swipeview> was created without expected prop 'onSwipe'");
	        }
	    });
	    const writable_props = [
	        'onSwipe',
	        'caption',
	        'reverse'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Swipeview> was created with unknown prop '${key}'`);
	    });
	    const wheel_handler = (e)=>mousewheel(e);
	    $$self.$$set = ($$props)=>{
	        if ('onSwipe' in $$props) $$invalidate(9, onSwipe = $$props.onSwipe);
	        if ('caption' in $$props) $$invalidate(0, caption = $$props.caption);
	        if ('reverse' in $$props) $$invalidate(10, reverse = $$props.reverse);
	        if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	    };
	    $$self.$capture_state = ()=>({
	            swipeprev,
	            swipenext,
	            onSwipe,
	            caption,
	            reverse,
	            swipeshapes,
	            touching,
	            touchx,
	            touchy,
	            startx,
	            starty,
	            direction,
	            ontouchstart,
	            getDirection,
	            ontouchmove,
	            ontouchend,
	            mousewheel,
	            next
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('onSwipe' in $$props) $$invalidate(9, onSwipe = $$props.onSwipe);
	        if ('caption' in $$props) $$invalidate(0, caption = $$props.caption);
	        if ('reverse' in $$props) $$invalidate(10, reverse = $$props.reverse);
	        if ('touching' in $$props) $$invalidate(1, touching = $$props.touching);
	        if ('touchx' in $$props) touchx = $$props.touchx;
	        if ('touchy' in $$props) touchy = $$props.touchy;
	        if ('startx' in $$props) startx = $$props.startx;
	        if ('starty' in $$props) starty = $$props.starty;
	        if ('direction' in $$props) $$invalidate(2, direction = $$props.direction);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        caption,
	        touching,
	        direction,
	        swipeshapes,
	        ontouchstart,
	        ontouchmove,
	        ontouchend,
	        mousewheel,
	        next,
	        onSwipe,
	        reverse,
	        $$scope,
	        slots,
	        wheel_handler
	    ];
	}
	class Swipeview extends SvelteComponentDev {
	    get onSwipe() {
	        throw new Error("<Swipeview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set onSwipe(value) {
	        throw new Error("<Swipeview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get caption() {
	        throw new Error("<Swipeview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set caption(value) {
	        throw new Error("<Swipeview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get reverse() {
	        throw new Error("<Swipeview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set reverse(value) {
	        throw new Error("<Swipeview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$s, create_fragment$s, safe_not_equal, {
	            onSwipe: 9,
	            caption: 0,
	            reverse: 10
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Swipeview",
	            options,
	            id: create_fragment$s.name
	        });
	    }
	}

	const get_default_slot_changes_2 = (dirty)=>({
	        active: dirty & /*last, now*/ 18,
	        caption: dirty & /*last*/ 16,
	        idx: dirty & /*last*/ 16,
	        id: dirty & /*last*/ 16
	    });
	const get_default_slot_context_2 = (ctx)=>({
	        active: /*last*/ ctx[4].idx == /*now*/ ctx[1],
	        caption: /*last*/ ctx[4].caption + ']',
	        idx: /*last*/ ctx[4].idx,
	        id: /*last*/ ctx[4].id
	    });
	function get_each_context$c(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[16] = list[i];
	    return child_ctx;
	}
	const get_default_slot_changes_1 = (dirty)=>({
	        active: dirty & /*neighbors, now*/ 10,
	        caption: dirty & /*neighbors*/ 8,
	        idx: dirty & /*neighbors*/ 8,
	        id: dirty & /*neighbors*/ 8
	    });
	const get_default_slot_context_1 = (ctx)=>({
	        active: /*page*/ ctx[16].idx == /*now*/ ctx[1],
	        caption: /*page*/ ctx[16].caption + ' ',
	        idx: /*page*/ ctx[16].idx,
	        id: /*page*/ ctx[16].id
	    });
	const get_default_slot_changes$1 = (dirty)=>({
	        active: dirty & /*pages, now*/ 3,
	        caption: dirty & /*pages*/ 1,
	        id: dirty & /*pages*/ 1
	    });
	const get_default_slot_context$1 = (ctx)=>({
	        active: /*pages*/ ctx[0][0].idx == /*now*/ ctx[1],
	        caption: '[' + /*pages*/ ctx[0][0].caption,
	        idx: "0",
	        id: /*pages*/ ctx[0][0].id
	    });
	// (56:0) {#if pages.length}
	function create_if_block_1$7(ctx) {
	    let current;
	    const default_slot_template = /*#slots*/ ctx[10].default;
	    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], get_default_slot_context$1);
	    const block = {
	        c: function create() {
	            if (default_slot) default_slot.c();
	        },
	        m: function mount(target, anchor) {
	            if (default_slot) {
	                default_slot.m(target, anchor);
	            }
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (default_slot) {
	                if (default_slot.p && (!current || dirty & /*$$scope, pages, now*/ 2051)) {
	                    update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[11]) : get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, get_default_slot_changes$1), get_default_slot_context$1);
	                }
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(default_slot, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(default_slot, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (default_slot) default_slot.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$7.name,
	        type: "if",
	        source: "(56:0) {#if pages.length}",
	        ctx
	    });
	    return block;
	}
	// (59:0) {#each neighbors as page}
	function create_each_block$c(ctx) {
	    let current;
	    const default_slot_template = /*#slots*/ ctx[10].default;
	    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], get_default_slot_context_1);
	    const block = {
	        c: function create() {
	            if (default_slot) default_slot.c();
	        },
	        m: function mount(target, anchor) {
	            if (default_slot) {
	                default_slot.m(target, anchor);
	            }
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (default_slot) {
	                if (default_slot.p && (!current || dirty & /*$$scope, neighbors, now*/ 2058)) {
	                    update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[11]) : get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, get_default_slot_changes_1), get_default_slot_context_1);
	                }
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(default_slot, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(default_slot, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (default_slot) default_slot.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$c.name,
	        type: "each",
	        source: "(59:0) {#each neighbors as page}",
	        ctx
	    });
	    return block;
	}
	// (63:0) {#if last}
	function create_if_block$e(ctx) {
	    let current;
	    const default_slot_template = /*#slots*/ ctx[10].default;
	    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], get_default_slot_context_2);
	    const block = {
	        c: function create() {
	            if (default_slot) default_slot.c();
	        },
	        m: function mount(target, anchor) {
	            if (default_slot) {
	                default_slot.m(target, anchor);
	            }
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (default_slot) {
	                if (default_slot.p && (!current || dirty & /*$$scope, last, now*/ 2066)) {
	                    update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[11]) : get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, get_default_slot_changes_2), get_default_slot_context_2);
	                }
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(default_slot, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(default_slot, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (default_slot) default_slot.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$e.name,
	        type: "if",
	        source: "(63:0) {#if last}",
	        ctx
	    });
	    return block;
	}
	// (55:0) <SwipeView onSwipe={onswipe} caption={caption?"→"+caption:''}>
	function create_default_slot$6(ctx) {
	    let t0;
	    let t1;
	    let if_block1_anchor;
	    let current;
	    let if_block0 = /*pages*/ ctx[0].length && create_if_block_1$7(ctx);
	    let each_value = ensure_array_like_dev(/*neighbors*/ ctx[3]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
	    }
	    const out = (i)=>transition_out(each_blocks[i], 1, 1, ()=>{
	            each_blocks[i] = null;
	        });
	    let if_block1 = /*last*/ ctx[4] && create_if_block$e(ctx);
	    const block = {
	        c: function create() {
	            if (if_block0) if_block0.c();
	            t0 = space();
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            t1 = space();
	            if (if_block1) if_block1.c();
	            if_block1_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if (if_block0) if_block0.m(target, anchor);
	            insert_dev(target, t0, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, t1, anchor);
	            if (if_block1) if_block1.m(target, anchor);
	            insert_dev(target, if_block1_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (/*pages*/ ctx[0].length) {
	                if (if_block0) {
	                    if_block0.p(ctx, dirty);
	                    if (dirty & /*pages*/ 1) {
	                        transition_in(if_block0, 1);
	                    }
	                } else {
	                    if_block0 = create_if_block_1$7(ctx);
	                    if_block0.c();
	                    transition_in(if_block0, 1);
	                    if_block0.m(t0.parentNode, t0);
	                }
	            } else if (if_block0) {
	                group_outros();
	                transition_out(if_block0, 1, 1, ()=>{
	                    if_block0 = null;
	                });
	                check_outros();
	            }
	            if (dirty & /*$$scope, neighbors, now*/ 2058) {
	                each_value = ensure_array_like_dev(/*neighbors*/ ctx[3]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$c(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                        transition_in(each_blocks[i], 1);
	                    } else {
	                        each_blocks[i] = create_each_block$c(child_ctx);
	                        each_blocks[i].c();
	                        transition_in(each_blocks[i], 1);
	                        each_blocks[i].m(t1.parentNode, t1);
	                    }
	                }
	                group_outros();
	                for(i = each_value.length; i < each_blocks.length; i += 1){
	                    out(i);
	                }
	                check_outros();
	            }
	            if (/*last*/ ctx[4]) {
	                if (if_block1) {
	                    if_block1.p(ctx, dirty);
	                    if (dirty & /*last*/ 16) {
	                        transition_in(if_block1, 1);
	                    }
	                } else {
	                    if_block1 = create_if_block$e(ctx);
	                    if_block1.c();
	                    transition_in(if_block1, 1);
	                    if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	                }
	            } else if (if_block1) {
	                group_outros();
	                transition_out(if_block1, 1, 1, ()=>{
	                    if_block1 = null;
	                });
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block0);
	            for(let i = 0; i < each_value.length; i += 1){
	                transition_in(each_blocks[i]);
	            }
	            transition_in(if_block1);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block0);
	            each_blocks = each_blocks.filter(Boolean);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                transition_out(each_blocks[i]);
	            }
	            transition_out(if_block1);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(if_block1_anchor);
	            }
	            if (if_block0) if_block0.d(detaching);
	            destroy_each(each_blocks, detaching);
	            if (if_block1) if_block1.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot$6.name,
	        type: "slot",
	        source: "(55:0) <SwipeView onSwipe={onswipe} caption={caption?\\\"→\\\"+caption:''}>",
	        ctx
	    });
	    return block;
	}
	function create_fragment$r(ctx) {
	    let swipeview;
	    let current;
	    swipeview = new Swipeview({
	        props: {
	            onSwipe: /*onswipe*/ ctx[5],
	            caption: /*caption*/ ctx[2] ? "→" + /*caption*/ ctx[2] : '',
	            $$slots: {
	                default: [
	                    create_default_slot$6
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(swipeview.$$.fragment);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            mount_component(swipeview, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            const swipeview_changes = {};
	            if (dirty & /*caption*/ 4) swipeview_changes.caption = /*caption*/ ctx[2] ? "→" + /*caption*/ ctx[2] : '';
	            if (dirty & /*$$scope, last, now, neighbors, pages*/ 2075) {
	                swipeview_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            swipeview.$set(swipeview_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(swipeview.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(swipeview.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(swipeview, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$r.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$r($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Pager', slots, [
	        'default'
	    ]);
	    let { pages = [] } = $$props;
	    let { count = 0 } = $$props;
	    let { now = 0 } = $$props;
	    let { previtems = 1 } = $$props;
	    let { nextitems = 3 } = $$props;
	    let { onselect } = $$props;
	    let { caption = '' } = $$props;
	    let left = now - previtems;
	    let right = now + nextitems + 1;
	    const neighbors = [];
	    let last = null;
	    const makeNeighbors = ()=>{
	        $$invalidate(1, now = parseInt(now));
	        if (now >= pages.length) $$invalidate(1, now = 0);
	        left = now - previtems;
	        right = now + nextitems + 1;
	        if (left < 2) left = 1;
	        if (right >= pages.length) right = pages.length - 1;
	        $$invalidate(3, neighbors.length = 0, neighbors);
	        for(let j = left; j < right; j++){
	            neighbors.push(pages[j]);
	        }
	        right += 10;
	        if (right < pages.length - 2) neighbors.push(pages[right]);
	        right += 30;
	        if (right < pages.length - 2) neighbors.push(pages[right]);
	        if (pages.length > 1) $$invalidate(4, last = pages[pages.length - 1]);
	        else $$invalidate(4, last = null);
	    };
	    const makepages = ()=>{
	        if (count && pages.length !== count) {
	            $$invalidate(0, pages.length = 0, pages);
	            for(let i = 0; i < count; i++){
	                pages.push({
	                    caption: i + 1,
	                    id: i + 1,
	                    idx: i
	                });
	            }
	            makeNeighbors();
	        }
	    };
	    const onswipe = (direction)=>{
	        $$invalidate(1, now += direction);
	        if (now < 0) $$invalidate(1, now = 0);
	        if (now >= pages.length - 1) $$invalidate(1, now = pages.length - 1);
	        onselect && onselect(now);
	    };
	    $$self.$$.on_mount.push(function() {
	        if (onselect === undefined && !('onselect' in $$props || $$self.$$.bound[$$self.$$.props['onselect']])) {
	            console.warn("<Pager> was created without expected prop 'onselect'");
	        }
	    });
	    const writable_props = [
	        'pages',
	        'count',
	        'now',
	        'previtems',
	        'nextitems',
	        'onselect',
	        'caption'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pager> was created with unknown prop '${key}'`);
	    });
	    $$self.$$set = ($$props)=>{
	        if ('pages' in $$props) $$invalidate(0, pages = $$props.pages);
	        if ('count' in $$props) $$invalidate(6, count = $$props.count);
	        if ('now' in $$props) $$invalidate(1, now = $$props.now);
	        if ('previtems' in $$props) $$invalidate(7, previtems = $$props.previtems);
	        if ('nextitems' in $$props) $$invalidate(8, nextitems = $$props.nextitems);
	        if ('onselect' in $$props) $$invalidate(9, onselect = $$props.onselect);
	        if ('caption' in $$props) $$invalidate(2, caption = $$props.caption);
	        if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	    };
	    $$self.$capture_state = ()=>({
	            pages,
	            count,
	            now,
	            previtems,
	            nextitems,
	            onselect,
	            caption,
	            SwipeView: Swipeview,
	            left,
	            right,
	            neighbors,
	            last,
	            makeNeighbors,
	            makepages,
	            onswipe
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('pages' in $$props) $$invalidate(0, pages = $$props.pages);
	        if ('count' in $$props) $$invalidate(6, count = $$props.count);
	        if ('now' in $$props) $$invalidate(1, now = $$props.now);
	        if ('previtems' in $$props) $$invalidate(7, previtems = $$props.previtems);
	        if ('nextitems' in $$props) $$invalidate(8, nextitems = $$props.nextitems);
	        if ('onselect' in $$props) $$invalidate(9, onselect = $$props.onselect);
	        if ('caption' in $$props) $$invalidate(2, caption = $$props.caption);
	        if ('left' in $$props) left = $$props.left;
	        if ('right' in $$props) right = $$props.right;
	        if ('last' in $$props) $$invalidate(4, last = $$props.last);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*now, pages*/ 3) {
	            makeNeighbors();
	        }
	        if ($$self.$$.dirty & /*pages, count*/ 65) {
	            makepages();
	        }
	    };
	    return [
	        pages,
	        now,
	        caption,
	        neighbors,
	        last,
	        onswipe,
	        count,
	        previtems,
	        nextitems,
	        onselect,
	        slots,
	        $$scope
	    ];
	}
	class Pager extends SvelteComponentDev {
	    get pages() {
	        throw new Error("<Pager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set pages(value) {
	        throw new Error("<Pager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get count() {
	        throw new Error("<Pager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set count(value) {
	        throw new Error("<Pager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get now() {
	        throw new Error("<Pager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set now(value) {
	        throw new Error("<Pager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get previtems() {
	        throw new Error("<Pager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set previtems(value) {
	        throw new Error("<Pager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get nextitems() {
	        throw new Error("<Pager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set nextitems(value) {
	        throw new Error("<Pager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get onselect() {
	        throw new Error("<Pager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set onselect(value) {
	        throw new Error("<Pager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get caption() {
	        throw new Error("<Pager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set caption(value) {
	        throw new Error("<Pager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$r, create_fragment$r, safe_not_equal, {
	            pages: 0,
	            count: 6,
	            now: 1,
	            previtems: 7,
	            nextitems: 8,
	            onselect: 9,
	            caption: 2
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Pager",
	            options,
	            id: create_fragment$r.name
	        });
	    }
	}

	const file$p = "src\\sentencenav.svelte";
	// (29:0) <Pager {caption} count={linecount} nextitems={5} previtems={4} now={sentnow} onselect={gosent} let:active let:caption let:idx>
	function create_default_slot$5(ctx) {
	    let span;
	    let t_value = _(/*caption*/ ctx[2]) + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[6](/*idx*/ ctx[10]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*active*/ ctx[9]);
	            add_location(span, file$p, 29, 4, 959);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*caption*/ 4 && t_value !== (t_value = _(/*caption*/ ctx[2]) + "")) set_data_dev(t, t_value);
	            if (dirty & /*active*/ 512) {
	                toggle_class(span, "selected", /*active*/ ctx[9]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot$5.name,
	        type: "slot",
	        source: "(29:0) <Pager {caption} count={linecount} nextitems={5} previtems={4} now={sentnow} onselect={gosent} let:active let:caption let:idx>",
	        ctx
	    });
	    return block;
	}
	function create_fragment$q(ctx) {
	    let pager;
	    let current;
	    pager = new Pager({
	        props: {
	            caption: /*caption*/ ctx[2],
	            count: /*linecount*/ ctx[1],
	            nextitems: 5,
	            previtems: 4,
	            now: /*sentnow*/ ctx[0],
	            onselect: /*gosent*/ ctx[3],
	            $$slots: {
	                default: [
	                    create_default_slot$5,
	                    ({ active, caption, idx })=>({
	                            9: active,
	                            2: caption,
	                            10: idx
	                        }),
	                    ({ active, caption, idx })=>(active ? 512 : 0) | (caption ? 4 : 0) | (idx ? 1024 : 0)
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(pager.$$.fragment);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            mount_component(pager, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            const pager_changes = {};
	            if (dirty & /*caption*/ 4) pager_changes.caption = /*caption*/ ctx[2];
	            if (dirty & /*linecount*/ 2) pager_changes.count = /*linecount*/ ctx[1];
	            if (dirty & /*sentnow*/ 1) pager_changes.now = /*sentnow*/ ctx[0];
	            if (dirty & /*$$scope, active, idx, caption*/ 3588) {
	                pager_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            pager.$set(pager_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(pager.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(pager.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(pager, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$q.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$q($$self, $$props, $$invalidate) {
	    let $tapmark;
	    let $foliotext;
	    validate_store(tapmark, 'tapmark');
	    component_subscribe($$self, tapmark, ($$value)=>$$invalidate(5, $tapmark = $$value));
	    validate_store(foliotext, 'foliotext');
	    component_subscribe($$self, foliotext, ($$value)=>$$invalidate(7, $foliotext = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Sentencenav', slots, []);
	    let { ptk } = $$props;
	    let sentnow = 0;
	    const gosent = (idx)=>{
	        const ft = $foliotext;
	        if (!ft) return;
	        const fpos = ft.toFolioPos($foliotext === null || $foliotext === void 0 ? void 0 : $foliotext.fromFolioPos($tapmark).ckid, idx);
	        activepb.set(fpos[0]);
	        tapmark.set(fpos);
	        $$invalidate(0, sentnow = idx);
	    };
	    let linecount = 0, caption = '';
	    const humancaption = ()=>{
	        const ft = $foliotext;
	        if (!ft || !ft.fromFolioPos) return;
	        const cl = ft.fromFolioPos($tapmark);
	        if (!cl || !cl.ckid) return '';
	        $$invalidate(1, linecount = cl.linecount || 0);
	        const styled = parseInt(cl.ckid).toString() == cl.ckid ? styledNumber(parseInt(cl.ckid), '①') : (cl.ckid || '') + '.';
	        $$invalidate(2, caption = styled + ptk.caption(cl.at));
	    };
	    $$self.$$.on_mount.push(function() {
	        if (ptk === undefined && !('ptk' in $$props || $$self.$$.bound[$$self.$$.props['ptk']])) {
	            console.warn("<Sentencenav> was created without expected prop 'ptk'");
	        }
	    });
	    const writable_props = [
	        'ptk'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sentencenav> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (idx)=>gosent(idx);
	    $$self.$$set = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(4, ptk = $$props.ptk);
	    };
	    $$self.$capture_state = ()=>({
	            styledNumber,
	            foliotext,
	            tapmark,
	            activepb,
	            ptk,
	            _,
	            Pager,
	            sentnow,
	            gosent,
	            linecount,
	            caption,
	            humancaption,
	            $tapmark,
	            $foliotext
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(4, ptk = $$props.ptk);
	        if ('sentnow' in $$props) $$invalidate(0, sentnow = $$props.sentnow);
	        if ('linecount' in $$props) $$invalidate(1, linecount = $$props.linecount);
	        if ('caption' in $$props) $$invalidate(2, caption = $$props.caption);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$tapmark*/ 32) {
	            humancaption();
	        }
	    };
	    return [
	        sentnow,
	        linecount,
	        caption,
	        gosent,
	        ptk,
	        $tapmark,
	        click_handler
	    ];
	}
	class Sentencenav extends SvelteComponentDev {
	    get ptk() {
	        throw new Error("<Sentencenav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set ptk(value) {
	        throw new Error("<Sentencenav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$q, create_fragment$q, safe_not_equal, {
	            ptk: 4
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Sentencenav",
	            options,
	            id: create_fragment$q.name
	        });
	    }
	}

	const file$o = "src\\translations.svelte";
	function get_each_context$b(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[13] = list[i];
	    return child_ctx;
	}
	// (64:0) {#if !~item.heading?.bkid?.indexOf('_variorum')}
	function create_if_block$d(ctx) {
	    var /*item*/ _ctx__heading_bk, _ctx__heading;
	    let div;
	    let span;
	    let t0_value = _(/*getBookTitle*/ ctx[3](/*item*/ ctx[13].ptk, (_ctx__heading = ctx[13].heading) === null || _ctx__heading === void 0 ? void 0 : (_ctx__heading_bk = _ctx__heading.bk) === null || _ctx__heading_bk === void 0 ? void 0 : _ctx__heading_bk.at)) + "";
	    let t0;
	    let t1;
	    let t2_value = /*hasfolio*/ (ctx[5](/*item*/ ctx[13].ptk) ? '←' : ' ') + "";
	    let t2;
	    let t3_value = _(/*puretext*/ ctx[6](/*item*/ ctx[13].linetext)) + "";
	    let t3;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[10](/*item*/ ctx[13]);
	    }
	    const block = {
	        c: function create() {
	            var /*item*/ _ctx__heading;
	            div = element("div");
	            span = element("span");
	            t0 = text(t0_value);
	            t1 = space();
	            t2 = text(t2_value);
	            t3 = text(t3_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable author");
	            add_location(span, file$o, 65, 0, 1990);
	            toggle_class(div, "selecteditem", ((_ctx__heading = ctx[13].heading) === null || _ctx__heading === void 0 ? void 0 : _ctx__heading.bkid) == /*$activefolioid*/ ctx[2]);
	            add_location(div, file$o, 64, 0, 1928);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, span);
	            append_dev(span, t0);
	            append_dev(span, t1);
	            append_dev(span, t2);
	            append_dev(div, t3);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            var /*item*/ _ctx__heading_bk, _ctx__heading;
	            ctx = new_ctx;
	            if (dirty & /*translations*/ 2 && t0_value !== (t0_value = _(/*getBookTitle*/ ctx[3](/*item*/ ctx[13].ptk, (_ctx__heading = ctx[13].heading) === null || _ctx__heading === void 0 ? void 0 : (_ctx__heading_bk = _ctx__heading.bk) === null || _ctx__heading_bk === void 0 ? void 0 : _ctx__heading_bk.at)) + "")) set_data_dev(t0, t0_value);
	            if (dirty & /*translations*/ 2 && t2_value !== (t2_value = /*hasfolio*/ (ctx[5](/*item*/ ctx[13].ptk) ? '←' : ' ') + "")) set_data_dev(t2, t2_value);
	            if (dirty & /*translations*/ 2 && t3_value !== (t3_value = _(/*puretext*/ ctx[6](/*item*/ ctx[13].linetext)) + "")) set_data_dev(t3, t3_value);
	            if (dirty & /*translations, $activefolioid*/ 6) {
	                var /*item*/ _ctx__heading1;
	                toggle_class(div, "selecteditem", ((_ctx__heading1 = ctx[13].heading) === null || _ctx__heading1 === void 0 ? void 0 : _ctx__heading1.bkid) == /*$activefolioid*/ ctx[2]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$d.name,
	        type: "if",
	        source: "(64:0) {#if !~item.heading?.bkid?.indexOf('_variorum')}",
	        ctx
	    });
	    return block;
	}
	// (63:0) {#each translations as item}
	function create_each_block$b(ctx) {
	    var /*item*/ _ctx__heading_bkid, _ctx__heading;
	    let show_if = !~((_ctx__heading = ctx[13].heading) === null || _ctx__heading === void 0 ? void 0 : (_ctx__heading_bkid = _ctx__heading.bkid) === null || _ctx__heading_bkid === void 0 ? void 0 : _ctx__heading_bkid.indexOf('_variorum'));
	    let t;
	    let div;
	    let if_block = show_if && create_if_block$d(ctx);
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            t = space();
	            div = element("div");
	            attr_dev(div, "class", "hr");
	            add_location(div, file$o, 69, 0, 2224);
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, t, anchor);
	            insert_dev(target, div, anchor);
	        },
	        p: function update(ctx, dirty) {
	            var /*item*/ _ctx__heading_bkid, _ctx__heading;
	            if (dirty & /*translations*/ 2) show_if = !~((_ctx__heading = ctx[13].heading) === null || _ctx__heading === void 0 ? void 0 : (_ctx__heading_bkid = _ctx__heading.bkid) === null || _ctx__heading_bkid === void 0 ? void 0 : _ctx__heading_bkid.indexOf('_variorum'));
	            if (show_if) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block$d(ctx);
	                    if_block.c();
	                    if_block.m(t.parentNode, t);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	                detach_dev(div);
	            }
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$b.name,
	        type: "each",
	        source: "(63:0) {#each translations as item}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$p(ctx) {
	    let div1;
	    let sentencenav;
	    let t0;
	    let div0;
	    let t1;
	    let t2;
	    let endmarker;
	    let current;
	    sentencenav = new Sentencenav({
	        props: {
	            ptk: /*ptk*/ ctx[0]
	        },
	        $$inline: true
	    });
	    let each_value = ensure_array_like_dev(/*translations*/ ctx[1]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
	    }
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div1 = element("div");
	            create_component(sentencenav.$$.fragment);
	            t0 = space();
	            div0 = element("div");
	            t1 = space();
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            t2 = space();
	            create_component(endmarker.$$.fragment);
	            attr_dev(div0, "class", "hr");
	            add_location(div0, file$o, 61, 0, 1832);
	            attr_dev(div1, "class", "bodytext");
	            add_location(div1, file$o, 59, 0, 1788);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div1, anchor);
	            mount_component(sentencenav, div1, null);
	            append_dev(div1, t0);
	            append_dev(div1, div0);
	            append_dev(div1, t1);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div1, null);
	                }
	            }
	            append_dev(div1, t2);
	            mount_component(endmarker, div1, null);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            const sentencenav_changes = {};
	            if (dirty & /*ptk*/ 1) sentencenav_changes.ptk = /*ptk*/ ctx[0];
	            sentencenav.$set(sentencenav_changes);
	            if (dirty & /*translations, $activefolioid, puretext, goFolioByLine, hasfolio, getBookTitle*/ 126) {
	                each_value = ensure_array_like_dev(/*translations*/ ctx[1]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$b(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$b(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div1, t2);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(sentencenav.$$.fragment, local);
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(sentencenav.$$.fragment, local);
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div1);
	            }
	            destroy_component(sentencenav);
	            destroy_each(each_blocks, detaching);
	            destroy_component(endmarker);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$p.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$p($$self, $$props, $$invalidate) {
	    let $loadingfolio;
	    let $tapmark;
	    let $foliotext;
	    let $activefolioid;
	    validate_store(loadingfolio, 'loadingfolio');
	    component_subscribe($$self, loadingfolio, ($$value)=>$$invalidate(8, $loadingfolio = $$value));
	    validate_store(tapmark, 'tapmark');
	    component_subscribe($$self, tapmark, ($$value)=>$$invalidate(9, $tapmark = $$value));
	    validate_store(foliotext, 'foliotext');
	    component_subscribe($$self, foliotext, ($$value)=>$$invalidate(11, $foliotext = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(2, $activefolioid = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Translations', slots, []);
	    let { closePopup = function() {} } = $$props;
	    let { ptk } = $$props;
	    let translations = [];
	    const getBookTitle = (ptk, nbk)=>{
	        const bk = ptk.defines.bk;
	        const line = bk.linepos[nbk]; //assuming folio tag at bk
	        const folio = ptk.defines.folio;
	        const at = bsearchNumber(folio.linepos, line + 1) - 1;
	        if (folio.linepos[at] !== line) {
	            return bk._innertext.get(nbk);
	        } else {
	            return ~at ? folio._innertext.get(at) : bk._innertext.get(nbk);
	        }
	    };
	    const goFolioByLine = (ptk, line)=>{
	        const pb = ptk.defines.pb;
	        const folio = ptk.defines.folio;
	        if (!pb) return;
	        const pbat = ptk.nearestTag(line, 'pb');
	        const folioat = ptk.nearestTag(line, 'folio');
	        const pbid = pb.fields.id.values[pbat];
	        const newfolio = folio.fields.id.values[folioat];
	        loadFolio(newfolio, ()=>{
	            activePtk.set(ptk.name);
	            activepb.set((parseInt(pbid) || 1) - 1);
	            marktap(pbid, line);
	        });
	        closePopup();
	    };
	    const hasfolio = (ptk, line)=>{
	        const folioat = ptk.nearestTag(line + 1, 'folio');
	        return folioat > -1;
	    };
	    const puretext = (_text)=>{
	        const [text] = parseOfftext(_text);
	        return text;
	    };
	    const updateTranslation = async (mark, loading)=>{
	        if (loading) return [];
	        const cl = $foliotext === null || $foliotext === void 0 ? void 0 : $foliotext.fromFolioPos(mark);
	        if (!cl) return;
	        $$invalidate(1, translations = await getParallelLines(ptk, cl.ptkline, null, {
	            local: true,
	            remote: false
	        })); //same ptk only
	    };
	    $$self.$$.on_mount.push(function() {
	        if (ptk === undefined && !('ptk' in $$props || $$self.$$.bound[$$self.$$.props['ptk']])) {
	            console.warn("<Translations> was created without expected prop 'ptk'");
	        }
	    });
	    const writable_props = [
	        'closePopup',
	        'ptk'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Translations> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (item)=>goFolioByLine(item.ptk, item.line);
	    $$self.$$set = ($$props)=>{
	        if ('closePopup' in $$props) $$invalidate(7, closePopup = $$props.closePopup);
	        if ('ptk' in $$props) $$invalidate(0, ptk = $$props.ptk);
	    };
	    $$self.$capture_state = ()=>({
	            getParallelLines,
	            activepb,
	            activefolioid,
	            activePtk,
	            foliotext,
	            tapmark,
	            loadingfolio,
	            parseOfftext,
	            bsearchNumber,
	            SentenceNav: Sentencenav,
	            loadFolio,
	            _,
	            Endmarker,
	            closePopup,
	            ptk,
	            translations,
	            getBookTitle,
	            goFolioByLine,
	            hasfolio,
	            puretext,
	            updateTranslation,
	            $loadingfolio,
	            $tapmark,
	            $foliotext,
	            $activefolioid
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('closePopup' in $$props) $$invalidate(7, closePopup = $$props.closePopup);
	        if ('ptk' in $$props) $$invalidate(0, ptk = $$props.ptk);
	        if ('translations' in $$props) $$invalidate(1, translations = $$props.translations);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$tapmark, $loadingfolio*/ 768) {
	            updateTranslation($tapmark, $loadingfolio);
	        }
	    };
	    return [
	        ptk,
	        translations,
	        $activefolioid,
	        getBookTitle,
	        goFolioByLine,
	        hasfolio,
	        puretext,
	        closePopup,
	        $loadingfolio,
	        $tapmark,
	        click_handler
	    ];
	}
	class Translations extends SvelteComponentDev {
	    get closePopup() {
	        throw new Error("<Translations>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set closePopup(value) {
	        throw new Error("<Translations>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get ptk() {
	        throw new Error("<Translations>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set ptk(value) {
	        throw new Error("<Translations>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$p, create_fragment$p, safe_not_equal, {
	            closePopup: 7,
	            ptk: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Translations",
	            options,
	            id: create_fragment$p.name
	        });
	    }
	}

	const file$n = "src\\chunknav.svelte";
	// (44:0) <Pager onselect={gochunk} pages={chunks} nextitems={2} now={cknow} let:active let:caption let:idx>
	function create_default_slot$4(ctx) {
	    let span;
	    let t_value = _(/*caption*/ ctx[10]) + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[5](/*idx*/ ctx[11]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*active*/ ctx[9]);
	            add_location(span, file$n, 44, 0, 1354);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*caption*/ 1024 && t_value !== (t_value = _(/*caption*/ ctx[10]) + "")) set_data_dev(t, t_value);
	            if (dirty & /*active*/ 512) {
	                toggle_class(span, "selected", /*active*/ ctx[9]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot$4.name,
	        type: "slot",
	        source: "(44:0) <Pager onselect={gochunk} pages={chunks} nextitems={2} now={cknow} let:active let:caption let:idx>",
	        ctx
	    });
	    return block;
	}
	function create_fragment$o(ctx) {
	    let pager;
	    let current;
	    pager = new Pager({
	        props: {
	            onselect: /*gochunk*/ ctx[2],
	            pages: /*chunks*/ ctx[1],
	            nextitems: 2,
	            now: /*cknow*/ ctx[0],
	            $$slots: {
	                default: [
	                    create_default_slot$4,
	                    ({ active, caption, idx })=>({
	                            9: active,
	                            10: caption,
	                            11: idx
	                        }),
	                    ({ active, caption, idx })=>(active ? 512 : 0) | (caption ? 1024 : 0) | (idx ? 2048 : 0)
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(pager.$$.fragment);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            mount_component(pager, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            const pager_changes = {};
	            if (dirty & /*chunks*/ 2) pager_changes.pages = /*chunks*/ ctx[1];
	            if (dirty & /*cknow*/ 1) pager_changes.now = /*cknow*/ ctx[0];
	            if (dirty & /*$$scope, active, idx, caption*/ 7680) {
	                pager_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            pager.$set(pager_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(pager.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(pager.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(pager, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$o.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$o($$self, $$props, $$invalidate) {
	    let $tapmark;
	    let $activefolioid;
	    let $foliotext;
	    validate_store(tapmark, 'tapmark');
	    component_subscribe($$self, tapmark, ($$value)=>$$invalidate(4, $tapmark = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(6, $activefolioid = $$value));
	    validate_store(foliotext, 'foliotext');
	    component_subscribe($$self, foliotext, ($$value)=>$$invalidate(7, $foliotext = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Chunknav', slots, []);
	    let { ptk } = $$props;
	    let cknow = 0;
	    const chunks = [];
	    const loadChunks = ()=>{
	        const ft = $foliotext;
	        if (!ft || !ft.fromFolioPos) return;
	        const { ckid } = ft.fromFolioPos($tapmark);
	        //if (ckid==chunks[cknow]?.ckid) return;
	        const book = bookByFolio($activefolioid);
	        const [from, to] = ptk.rangeOfAddress('bk#' + book);
	        const [start, end] = ptk.tagInRange('ck', from, to);
	        const ck = ptk.defines.ck;
	        let idx = 0;
	        $$invalidate(1, chunks.length = 0, chunks);
	        const tapckid = ckid;
	        for(let ckat = start; ckat <= end; ckat++){
	            const ckid = ck.fields.id.values[ckat];
	            const styled = parseInt(ckid) ? styledNumber(parseInt(ckid), '①') : ckid + '.';
	            chunks.push({
	                caption: styled + ck._innertext.get(ckat),
	                idx,
	                id: ckat,
	                ckid
	            }); //id is pager id
	            if (ckid == tapckid) $$invalidate(0, cknow = idx);
	            idx++;
	        }
	    };
	    const gochunk = (idx)=>{
	        const ckat = chunks[idx].id;
	        const ck = ptk.defines.ck;
	        const ckid = ck.fields.id.values[ckat];
	        goChunk(ptk, bookByFolio($activefolioid), ckid);
	        $$invalidate(0, cknow = idx);
	    };
	    $$self.$$.on_mount.push(function() {
	        if (ptk === undefined && !('ptk' in $$props || $$self.$$.bound[$$self.$$.props['ptk']])) {
	            console.warn("<Chunknav> was created without expected prop 'ptk'");
	        }
	    });
	    const writable_props = [
	        'ptk'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Chunknav> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (idx)=>gochunk(idx);
	    $$self.$$set = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(3, ptk = $$props.ptk);
	    };
	    $$self.$capture_state = ()=>({
	            ptk,
	            Pager,
	            styledNumber,
	            bookByFolio,
	            activefolioid,
	            tapmark,
	            foliotext,
	            goChunk,
	            _,
	            cknow,
	            chunks,
	            loadChunks,
	            gochunk,
	            $tapmark,
	            $activefolioid,
	            $foliotext
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(3, ptk = $$props.ptk);
	        if ('cknow' in $$props) $$invalidate(0, cknow = $$props.cknow);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$tapmark*/ 16) {
	            loadChunks();
	        }
	    };
	    return [
	        cknow,
	        chunks,
	        gochunk,
	        ptk,
	        $tapmark,
	        click_handler
	    ];
	}
	class Chunknav extends SvelteComponentDev {
	    get ptk() {
	        throw new Error("<Chunknav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set ptk(value) {
	        throw new Error("<Chunknav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$o, create_fragment$o, safe_not_equal, {
	            ptk: 3
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Chunknav",
	            options,
	            id: create_fragment$o.name
	        });
	    }
	}

	const file$m = "src\\chunktext.svelte";
	function get_each_context$a(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[23] = list[i];
	    child_ctx[25] = i;
	    return child_ctx;
	}
	// (105:0) {#if sutras.length}
	function create_if_block$c(ctx) {
	    let slider;
	    let updating_value;
	    let current;
	    function slider_value_binding(value) {
	        /*slider_value_binding*/ ctx[15](value);
	    }
	    let slider_props = {
	        max: /*sutras*/ ctx[4].length - 2,
	        min: 0,
	        $$slots: {
	            caption: [
	                create_caption_slot$2
	            ]
	        },
	        $$scope: {
	            ctx
	        }
	    };
	    if (/*sutra*/ ctx[3] !== void 0) {
	        slider_props.value = /*sutra*/ ctx[3];
	    }
	    slider = new Rangeslider({
	        props: slider_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(slider, 'value', slider_value_binding));
	    slider.$on("input", debounce(/*setSutra*/ ctx[12], 100));
	    const block = {
	        c: function create() {
	            create_component(slider.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(slider, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const slider_changes = {};
	            if (dirty & /*sutras*/ 16) slider_changes.max = /*sutras*/ ctx[4].length - 2;
	            if (dirty & /*$$scope, maxsutra, minsutra, sutra*/ 67108968) {
	                slider_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            if (!updating_value && dirty & /*sutra*/ 8) {
	                updating_value = true;
	                slider_changes.value = /*sutra*/ ctx[3];
	                add_flush_callback(()=>updating_value = false);
	            }
	            slider.$set(slider_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(slider.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(slider.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(slider, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$c.name,
	        type: "if",
	        source: "(105:0) {#if sutras.length}",
	        ctx
	    });
	    return block;
	}
	// (107:4) 
	function create_caption_slot$2(ctx) {
	    let span;
	    let t0;
	    let t1_value = /*minsutra*/ (ctx[5] + /*sutra*/ ctx[3][0] || 0) + "";
	    let t1;
	    let t2;
	    let t3;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t0 = text("經");
	            t1 = text(t1_value);
	            t2 = text("/");
	            t3 = text(/*maxsutra*/ ctx[6]);
	            attr_dev(span, "slot", "caption");
	            set_style(span, "float", "right");
	            add_location(span, file$m, 106, 4, 3104);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t0);
	            append_dev(span, t1);
	            append_dev(span, t2);
	            append_dev(span, t3);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*minsutra, sutra*/ 40 && t1_value !== (t1_value = /*minsutra*/ (ctx[5] + /*sutra*/ ctx[3][0] || 0) + "")) set_data_dev(t1, t1_value);
	            if (dirty & /*maxsutra*/ 64) set_data_dev(t3, /*maxsutra*/ ctx[6]);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_caption_slot$2.name,
	        type: "slot",
	        source: "(107:4) ",
	        ctx
	    });
	    return block;
	}
	// (111:0) {#each lines as line,idx}
	function create_each_block$a(ctx) {
	    let div;
	    let raw_value = /*renderLine*/ ctx[8](/*line*/ ctx[23]) + "";
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[16](/*idx*/ ctx[25]);
	    }
	    const block = {
	        c: function create() {
	            div = element("div");
	            attr_dev(div, "aria-hidden", "true");
	            toggle_class(div, "activeline", /*activeline*/ ctx[7] == /*idx*/ ctx[25]);
	            add_location(div, file$m, 111, 0, 3254);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            div.innerHTML = raw_value;
	            if (!mounted) {
	                dispose = listen_dev(div, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*lines*/ 4 && raw_value !== (raw_value = /*renderLine*/ ctx[8](/*line*/ ctx[23]) + "")) div.innerHTML = raw_value;
	            if (dirty & /*activeline*/ 128) {
	                toggle_class(div, "activeline", /*activeline*/ ctx[7] == /*idx*/ ctx[25]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$a.name,
	        type: "each",
	        source: "(111:0) {#each lines as line,idx}",
	        ctx
	    });
	    return block;
	}
	// (110:0) {#key activeline}
	function create_key_block$7(ctx) {
	    let each_1_anchor;
	    let each_value = ensure_array_like_dev(/*lines*/ ctx[2]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            each_1_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, each_1_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*activeline, setAddress, displayline, renderLine, lines*/ 902) {
	                each_value = ensure_array_like_dev(/*lines*/ ctx[2]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$a(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$a(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(each_1_anchor);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$7.name,
	        type: "key",
	        source: "(110:0) {#key activeline}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$n(ctx) {
	    let div;
	    let span0;
	    let t1;
	    let span1;
	    let t3;
	    let chunknav;
	    let t4;
	    let t5;
	    let hr;
	    let t6;
	    let previous_key = /*activeline*/ ctx[7];
	    let t7;
	    let endmarker;
	    let current;
	    let mounted;
	    let dispose;
	    chunknav = new Chunknav({
	        props: {
	            ptk: /*ptk*/ ctx[0]
	        },
	        $$inline: true
	    });
	    let if_block = /*sutras*/ ctx[4].length && create_if_block$c(ctx);
	    let key_block = create_key_block$7(ctx);
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div = element("div");
	            span0 = element("span");
	            span0.textContent = "↑";
	            t1 = space();
	            span1 = element("span");
	            span1.textContent = "▃";
	            t3 = space();
	            create_component(chunknav.$$.fragment);
	            t4 = space();
	            if (if_block) if_block.c();
	            t5 = space();
	            hr = element("hr");
	            t6 = space();
	            key_block.c();
	            t7 = space();
	            create_component(endmarker.$$.fragment);
	            attr_dev(span0, "aria-hidden", "true");
	            attr_dev(span0, "class", "clickable gotop");
	            add_location(span0, file$m, 100, 0, 2804);
	            attr_dev(span1, "aria-hidden", "true");
	            attr_dev(span1, "class", "clickable goactiveline");
	            add_location(span1, file$m, 101, 0, 2879);
	            add_location(hr, file$m, 108, 0, 3204);
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$m, 99, 0, 2781);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, span0);
	            append_dev(div, t1);
	            append_dev(div, span1);
	            append_dev(div, t3);
	            mount_component(chunknav, div, null);
	            append_dev(div, t4);
	            if (if_block) if_block.m(div, null);
	            append_dev(div, t5);
	            append_dev(div, hr);
	            append_dev(div, t6);
	            key_block.m(div, null);
	            append_dev(div, t7);
	            mount_component(endmarker, div, null);
	            current = true;
	            if (!mounted) {
	                dispose = [
	                    listen_dev(span0, "click", /*gotop*/ ctx[11], false, false, false, false),
	                    listen_dev(span1, "click", /*goactiveline*/ ctx[10], false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            const chunknav_changes = {};
	            if (dirty & /*ptk*/ 1) chunknav_changes.ptk = /*ptk*/ ctx[0];
	            chunknav.$set(chunknav_changes);
	            if (/*sutras*/ ctx[4].length) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                    if (dirty & /*sutras*/ 16) {
	                        transition_in(if_block, 1);
	                    }
	                } else {
	                    if_block = create_if_block$c(ctx);
	                    if_block.c();
	                    transition_in(if_block, 1);
	                    if_block.m(div, t5);
	                }
	            } else if (if_block) {
	                group_outros();
	                transition_out(if_block, 1, 1, ()=>{
	                    if_block = null;
	                });
	                check_outros();
	            }
	            if (dirty & /*activeline*/ 128 && safe_not_equal(previous_key, previous_key = /*activeline*/ ctx[7])) {
	                key_block.d(1);
	                key_block = create_key_block$7(ctx);
	                key_block.c();
	                key_block.m(div, t7);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(chunknav.$$.fragment, local);
	            transition_in(if_block);
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(chunknav.$$.fragment, local);
	            transition_out(if_block);
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_component(chunknav);
	            if (if_block) if_block.d();
	            key_block.d(detaching);
	            destroy_component(endmarker);
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$n.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$n($$self, $$props, $$invalidate) {
	    let activeline;
	    let $loadingfolio;
	    let $tapmark;
	    validate_store(loadingfolio, 'loadingfolio');
	    component_subscribe($$self, loadingfolio, ($$value)=>$$invalidate(13, $loadingfolio = $$value));
	    validate_store(tapmark, 'tapmark');
	    component_subscribe($$self, tapmark, ($$value)=>$$invalidate(14, $tapmark = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Chunktext', slots, []);
	    let { ptk } = $$props;
	    let ck, loff, displayline = 0, settingaddress = false, alllines = [], lines = [], sutra = [
	        0,
	        0
	    ], sutras = [], minsutra = 0, maxsutra = 0;
	    const loadChunkText = (mark, loading)=>{
	        if (loading) return;
	        const ft = get_store_value(foliotext);
	        if (!ft || !ft.fromFolioPos) return;
	        let nsutra = 0;
	        const { ckid, lineoff } = ft.fromFolioPos(mark);
	        if (settingaddress && ck == ckid) {
	            settingaddress = false;
	            return;
	        }
	        loff = lineoff;
	        $$invalidate(4, sutras.length = 0, sutras);
	        alllines = [];
	        $$invalidate(1, displayline = 0);
	        alllines = ft.chunkText(ckid).split('\n');
	        $$invalidate(5, minsutra = 0), $$invalidate(6, maxsutra = 0);
	        for(let i = 0; i < alllines.length; i++){
	            const m = alllines[i].match(/\^n(\d+)/);
	            if (m) {
	                const n = parseInt(m[1]);
	                if (minsutra == 0 && n) {
	                    $$invalidate(5, minsutra = n);
	                }
	                $$invalidate(6, maxsutra = n);
	                if (i < lineoff) nsutra = sutras.length;
	                sutras.push(i);
	            }
	        }
	        if (nsutra !== sutra[0]) $$invalidate(3, sutra[0] = nsutra, sutra);
	        $$invalidate(7, activeline = lineoff - sutras[nsutra]);
	        updateText();
	        if (ck == ckid) {
	            const idx = sutra[0];
	            $$invalidate(2, lines = alllines.slice(sutras[idx], sutras[idx + 1]));
	            $$invalidate(1, displayline = sutras[idx] || 0);
	        } else {
	            $$invalidate(3, sutra[0] = 0, sutra); //select first sutra of this chunk
	            $$invalidate(1, displayline = sutras[0] || 0);
	        }
	        ck = ckid;
	    };
	    const updateText = ()=>{
	        if (sutras.length) {
	            sutras.push(alllines.length - 1); //has sutra
	            $$invalidate(2, lines = alllines.slice(sutras[0], sutras[1]));
	        } else {
	            $$invalidate(2, lines = alllines);
	        }
	    };
	    const renderLine = (line)=>{
	        return _(line.replace(/\^[a-z_]#?[a-z\d]*/g, ''));
	    };
	    const setAddress = (lineoff)=>{
	        const ft = get_store_value(foliotext);
	        if (!ft || !ft.fromFolioPos) return;
	        const [pbid, line, ch] = ft.toFolioPos(ck, lineoff);
	        goPb(pbid, ck);
	        settingaddress = true;
	        tapmark.set([
	            pbid,
	            line,
	            ch
	        ]);
	        $$invalidate(7, activeline = lineoff - displayline);
	        updateUrl(tapAddress());
	    };
	    const goactiveline = ()=>{
	        const ele = document.querySelector('.bodytext .activeline');
	        if (!ele) return;
	        ele.parentElement.parentElement.parentElement.scrollTop = ele.offsetTop;
	    };
	    const gotop = ()=>{
	        const ele = document.querySelector('.bodytext .activeline');
	        if (!ele) return;
	        ele.parentElement.parentElement.parentElement.scrollTop = 0;
	    };
	    const setSutra = (e)=>{
	        const idx = e.detail[0];
	        $$invalidate(2, lines = alllines.slice(sutras[idx], sutras[idx + 1]));
	        $$invalidate(1, displayline = sutras[idx]);
	        $$invalidate(7, activeline = 0);
	    };
	    $$self.$$.on_mount.push(function() {
	        if (ptk === undefined && !('ptk' in $$props || $$self.$$.bound[$$self.$$.props['ptk']])) {
	            console.warn("<Chunktext> was created without expected prop 'ptk'");
	        }
	    });
	    const writable_props = [
	        'ptk'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Chunktext> was created with unknown prop '${key}'`);
	    });
	    function slider_value_binding(value) {
	        sutra = value;
	        $$invalidate(3, sutra);
	    }
	    const click_handler = (idx)=>setAddress(displayline + idx);
	    $$self.$$set = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(0, ptk = $$props.ptk);
	    };
	    $$self.$capture_state = ()=>({
	            Slider: Rangeslider,
	            tapmark,
	            foliotext,
	            loadingfolio,
	            tapAddress,
	            get: get_store_value,
	            debounce,
	            updateUrl,
	            ChunkNav: Chunknav,
	            Endmarker,
	            goPb,
	            _,
	            ptk,
	            ck,
	            loff,
	            displayline,
	            settingaddress,
	            alllines,
	            lines,
	            sutra,
	            sutras,
	            minsutra,
	            maxsutra,
	            loadChunkText,
	            updateText,
	            renderLine,
	            setAddress,
	            goactiveline,
	            gotop,
	            setSutra,
	            activeline,
	            $loadingfolio,
	            $tapmark
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(0, ptk = $$props.ptk);
	        if ('ck' in $$props) ck = $$props.ck;
	        if ('loff' in $$props) loff = $$props.loff;
	        if ('displayline' in $$props) $$invalidate(1, displayline = $$props.displayline);
	        if ('settingaddress' in $$props) settingaddress = $$props.settingaddress;
	        if ('alllines' in $$props) alllines = $$props.alllines;
	        if ('lines' in $$props) $$invalidate(2, lines = $$props.lines);
	        if ('sutra' in $$props) $$invalidate(3, sutra = $$props.sutra);
	        if ('sutras' in $$props) $$invalidate(4, sutras = $$props.sutras);
	        if ('minsutra' in $$props) $$invalidate(5, minsutra = $$props.minsutra);
	        if ('maxsutra' in $$props) $$invalidate(6, maxsutra = $$props.maxsutra);
	        if ('activeline' in $$props) $$invalidate(7, activeline = $$props.activeline);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$tapmark, $loadingfolio*/ 24576) {
	            loadChunkText($tapmark, $loadingfolio);
	        }
	    };
	    $$invalidate(7, activeline = 0);
	    return [
	        ptk,
	        displayline,
	        lines,
	        sutra,
	        sutras,
	        minsutra,
	        maxsutra,
	        activeline,
	        renderLine,
	        setAddress,
	        goactiveline,
	        gotop,
	        setSutra,
	        $loadingfolio,
	        $tapmark,
	        slider_value_binding,
	        click_handler
	    ];
	}
	class Chunktext extends SvelteComponentDev {
	    get ptk() {
	        throw new Error("<Chunktext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set ptk(value) {
	        throw new Error("<Chunktext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$n, create_fragment$n, safe_not_equal, {
	            ptk: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Chunktext",
	            options,
	            id: create_fragment$n.name
	        });
	    }
	}

	const file$l = "src\\sourcetext.svelte";
	function get_each_context$9(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[7] = list[i];
	    return child_ctx;
	}
	// (25:4) {#each sourcetexts as item}
	function create_each_block$9(ctx) {
	    let div0;
	    let t0_value = _(/*puretext*/ ctx[2](/*item*/ ctx[7].linetext)) + "";
	    let t0;
	    let t1;
	    let div1;
	    const block = {
	        c: function create() {
	            div0 = element("div");
	            t0 = text(t0_value);
	            t1 = space();
	            div1 = element("div");
	            add_location(div0, file$l, 25, 4, 809);
	            attr_dev(div1, "class", "hr");
	            add_location(div1, file$l, 26, 4, 853);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div0, anchor);
	            append_dev(div0, t0);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, div1, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*sourcetexts*/ 2 && t0_value !== (t0_value = _(/*puretext*/ ctx[2](/*item*/ ctx[7].linetext)) + "")) set_data_dev(t0, t0_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div0);
	                detach_dev(t1);
	                detach_dev(div1);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$9.name,
	        type: "each",
	        source: "(25:4) {#each sourcetexts as item}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$m(ctx) {
	    let div;
	    let sentencenav;
	    let t0;
	    let t1;
	    let endmarker;
	    let current;
	    sentencenav = new Sentencenav({
	        props: {
	            ptk: /*ptk*/ ctx[0]
	        },
	        $$inline: true
	    });
	    let each_value = ensure_array_like_dev(/*sourcetexts*/ ctx[1]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	    }
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div = element("div");
	            create_component(sentencenav.$$.fragment);
	            t0 = space();
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            t1 = space();
	            create_component(endmarker.$$.fragment);
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$l, 22, 0, 724);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            mount_component(sentencenav, div, null);
	            append_dev(div, t0);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div, null);
	                }
	            }
	            append_dev(div, t1);
	            mount_component(endmarker, div, null);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            const sentencenav_changes = {};
	            if (dirty & /*ptk*/ 1) sentencenav_changes.ptk = /*ptk*/ ctx[0];
	            sentencenav.$set(sentencenav_changes);
	            if (dirty & /*puretext, sourcetexts*/ 6) {
	                each_value = ensure_array_like_dev(/*sourcetexts*/ ctx[1]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$9(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$9(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div, t1);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(sentencenav.$$.fragment, local);
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(sentencenav.$$.fragment, local);
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_component(sentencenav);
	            destroy_each(each_blocks, detaching);
	            destroy_component(endmarker);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$m.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$m($$self, $$props, $$invalidate) {
	    let $loadingfolio;
	    let $tapmark;
	    let $foliotext;
	    validate_store(loadingfolio, 'loadingfolio');
	    component_subscribe($$self, loadingfolio, ($$value)=>$$invalidate(3, $loadingfolio = $$value));
	    validate_store(tapmark, 'tapmark');
	    component_subscribe($$self, tapmark, ($$value)=>$$invalidate(4, $tapmark = $$value));
	    validate_store(foliotext, 'foliotext');
	    component_subscribe($$self, foliotext, ($$value)=>$$invalidate(5, $foliotext = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Sourcetext', slots, []);
	    let { ptk } = $$props;
	    let sourcetexts = [];
	    const updateParallels = async (mark, loading)=>{
	        if (loading) return;
	        const cl = $foliotext === null || $foliotext === void 0 ? void 0 : $foliotext.fromFolioPos($tapmark);
	        if (!cl) return;
	        $$invalidate(1, sourcetexts = await getParallelLines(ptk, cl.ptkline, null, {
	            remote: true,
	            local: false
	        })); //different ptk only
	    };
	    const puretext = (_text)=>{
	        const [text] = parseOfftext(_text);
	        return text;
	    };
	    $$self.$$.on_mount.push(function() {
	        if (ptk === undefined && !('ptk' in $$props || $$self.$$.bound[$$self.$$.props['ptk']])) {
	            console.warn("<Sourcetext> was created without expected prop 'ptk'");
	        }
	    });
	    const writable_props = [
	        'ptk'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sourcetext> was created with unknown prop '${key}'`);
	    });
	    $$self.$$set = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(0, ptk = $$props.ptk);
	    };
	    $$self.$capture_state = ()=>({
	            SentenceNav: Sentencenav,
	            ptk,
	            getParallelLines,
	            tapmark,
	            foliotext,
	            loadingfolio,
	            parseOfftext,
	            _,
	            Endmarker,
	            sourcetexts,
	            updateParallels,
	            puretext,
	            $loadingfolio,
	            $tapmark,
	            $foliotext
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(0, ptk = $$props.ptk);
	        if ('sourcetexts' in $$props) $$invalidate(1, sourcetexts = $$props.sourcetexts);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$tapmark, $loadingfolio*/ 24) {
	            updateParallels($tapmark, $loadingfolio);
	        }
	    };
	    return [
	        ptk,
	        sourcetexts,
	        puretext,
	        $loadingfolio,
	        $tapmark
	    ];
	}
	class Sourcetext extends SvelteComponentDev {
	    get ptk() {
	        throw new Error("<Sourcetext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set ptk(value) {
	        throw new Error("<Sourcetext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$m, create_fragment$m, safe_not_equal, {
	            ptk: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Sourcetext",
	            options,
	            id: create_fragment$m.name
	        });
	    }
	}

	const file$k = "src\\variorum.svelte";
	function create_fragment$l(ctx) {
	    let div;
	    let sentencenav0;
	    let t0;
	    let html_tag;
	    let raw_value = _(/*text*/ ctx[0]) + "";
	    let t1;
	    let sentencenav1;
	    let t2;
	    let endmarker;
	    let current;
	    sentencenav0 = new Sentencenav({
	        props: {
	            ptk: usePtk('dc')
	        },
	        $$inline: true
	    });
	    sentencenav1 = new Sentencenav({
	        props: {
	            ptk: usePtk('dc')
	        },
	        $$inline: true
	    });
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div = element("div");
	            create_component(sentencenav0.$$.fragment);
	            t0 = space();
	            html_tag = new HtmlTag(false);
	            t1 = space();
	            create_component(sentencenav1.$$.fragment);
	            t2 = space();
	            create_component(endmarker.$$.fragment);
	            html_tag.a = t1;
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$k, 38, 0, 1230);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            mount_component(sentencenav0, div, null);
	            append_dev(div, t0);
	            html_tag.m(raw_value, div);
	            append_dev(div, t1);
	            mount_component(sentencenav1, div, null);
	            append_dev(div, t2);
	            mount_component(endmarker, div, null);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            if ((!current || dirty & /*text*/ 1) && raw_value !== (raw_value = _(/*text*/ ctx[0]) + "")) html_tag.p(raw_value);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(sentencenav0.$$.fragment, local);
	            transition_in(sentencenav1.$$.fragment, local);
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(sentencenav0.$$.fragment, local);
	            transition_out(sentencenav1.$$.fragment, local);
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_component(sentencenav0);
	            destroy_component(sentencenav1);
	            destroy_component(endmarker);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$l.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$l($$self, $$props, $$invalidate) {
	    let $loadingfolio;
	    validate_store(loadingfolio, 'loadingfolio');
	    component_subscribe($$self, loadingfolio, ($$value)=>$$invalidate(1, $loadingfolio = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Variorum', slots, []);
	    let text = '';
	    const updateVariorum = async (address, loading)=>{
	        const ptk = usePtk("dc");
	        const r = ptk.defines.r;
	        if (!r || loading) return;
	        const addr = parseAddress(address);
	        const obj = parseAction(addr.action, true);
	        if (!obj) return;
	        const id = obj.ck + ':' + addr.highlightline;
	        let at = r.fields.id.values.indexOf(id);
	        if (~at) {
	            const from = r.linepos[at];
	            let to = r.linepos[at + 1]; //need terminator at the end
	            at++;
	            while(to == from){
	                at++;
	                to = r.linepos[at];
	            }
	            await ptk.loadLines([
	                [
	                    from,
	                    to + 1
	                ]
	            ]);
	            const lines = ptk.slice(from, to + 1);
	            if (lines[lines.length - 1].indexOf('^ck')) lines.pop(); //drop ^ck line at the end
	            if (lines.length) {
	                lines[0] = '<div class="sourcetext">' + lines[0].replace(/\^r(\d+):/g, (m, m1)=>styledNumber(m1)) + '</div>';
	            }
	            $$invalidate(0, text = lines.join('<br/>'));
	        }
	    };
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Variorum> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            parseAddress,
	            parseAction,
	            styledNumber,
	            usePtk,
	            SentenceNav: Sentencenav,
	            tapAddress,
	            loadingfolio,
	            Endmarker,
	            _,
	            text,
	            updateVariorum,
	            $loadingfolio
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('text' in $$props) $$invalidate(0, text = $$props.text);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$loadingfolio*/ 2) {
	            updateVariorum(tapAddress(), $loadingfolio);
	        }
	    };
	    return [
	        text,
	        $loadingfolio
	    ];
	}
	class Variorum extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$l, create_fragment$l, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Variorum",
	            options,
	            id: create_fragment$l.name
	        });
	    }
	}

	const { console: console_1 } = globals;
	const file$j = "src\\tofindhistory.svelte";
	function get_each_context$8(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[6] = list[i];
	    return child_ctx;
	}
	// (12:0) {#each items as item}
	function create_each_block$8(ctx) {
	    let span0;
	    let t0_value = /*item*/ ctx[6] + "";
	    let t0;
	    let span1;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[4](/*item*/ ctx[6]);
	    }
	    function click_handler_1() {
	        return /*click_handler_1*/ ctx[5](/*item*/ ctx[6]);
	    }
	    const block = {
	        c: function create() {
	            span0 = element("span");
	            t0 = text(t0_value);
	            span1 = element("span");
	            span1.textContent = "✕";
	            attr_dev(span0, "aria-hidden", "true");
	            attr_dev(span0, "class", "clickable");
	            add_location(span0, file$j, 12, 0, 272);
	            attr_dev(span1, "aria-hidden", "true");
	            attr_dev(span1, "class", "delete clickable");
	            add_location(span1, file$j, 12, 87, 359);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span0, anchor);
	            append_dev(span0, t0);
	            insert_dev(target, span1, anchor);
	            if (!mounted) {
	                dispose = [
	                    listen_dev(span0, "click", click_handler, false, false, false, false),
	                    listen_dev(span1, "click", click_handler_1, false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*items*/ 2 && t0_value !== (t0_value = /*item*/ ctx[6] + "")) set_data_dev(t0, t0_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span0);
	                detach_dev(span1);
	            }
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$8.name,
	        type: "each",
	        source: "(12:0) {#each items as item}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$k(ctx) {
	    let div;
	    let each_value = ensure_array_like_dev(/*items*/ ctx[1]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            div = element("div");
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$j, 10, 0, 227);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div, null);
	                }
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*items, setTofind*/ 3) {
	                each_value = ensure_array_like_dev(/*items*/ ctx[1]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$8(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$8(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div, null);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$k.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$k($$self, $$props, $$invalidate) {
	    let items;
	    let $tofind;
	    let $tofindhistory;
	    validate_store(tofind, 'tofind');
	    component_subscribe($$self, tofind, ($$value)=>$$invalidate(2, $tofind = $$value));
	    validate_store(tofindhistory, 'tofindhistory');
	    component_subscribe($$self, tofindhistory, ($$value)=>$$invalidate(3, $tofindhistory = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Tofindhistory', slots, []);
	    const setTofind = (tf)=>{
	        tofind.set(tf);
	    };
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Tofindhistory> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (item)=>setTofind(item);
	    const click_handler_1 = (item)=>removeTofind(item);
	    $$self.$capture_state = ()=>({
	            tofindhistory,
	            removeTofind,
	            tofind,
	            setTofind,
	            items,
	            $tofind,
	            $tofindhistory
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('items' in $$props) $$invalidate(1, items = $$props.items);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$tofindhistory*/ 8) {
	            $$invalidate(1, items = $tofindhistory.slice(0, $tofindhistory.length));
	        }
	        if ($$self.$$.dirty & /*$tofind*/ 4) {
	            console.log('tofind', $tofind);
	        }
	    };
	    return [
	        setTofind,
	        items,
	        $tofind,
	        $tofindhistory,
	        click_handler,
	        click_handler_1
	    ];
	}
	class Tofindhistory extends SvelteComponentDev {
	    get setTofind() {
	        return this.$$.ctx[0];
	    }
	    set setTofind(value) {
	        throw new Error("<Tofindhistory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$k, create_fragment$k, safe_not_equal, {
	            setTofind: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Tofindhistory",
	            options,
	            id: create_fragment$k.name
	        });
	    }
	}

	const file$i = "src\\searchhelp.svelte";
	function create_fragment$j(ctx) {
	    let tofindhistory;
	    let t0;
	    let hr;
	    let t1;
	    let div;
	    let t2_value = _("點圖片任何一字，將短句帶入候選區，預設前三個字為關鍵字。") + "";
	    let t2;
	    let t3;
	    let br0;
	    let t4_value = _("點紅色背景的字，分享該段經文。") + "";
	    let t4;
	    let t5;
	    let br1;
	    let t6_value = _("♡書籤。閃爍時再點擊改變顏色，不閃爍時再點取消。") + "";
	    let t6;
	    let t7;
	    let br2;
	    let t8_value = _("點候選區改變關鍵的長度，同個位置再點一次，貼到輸入區。") + "";
	    let t8;
	    let t9;
	    let br3;
	    let t10_value = _("候選區與輸入區文字相同，再點候選區清除輸入區。") + "";
	    let t10;
	    let t11;
	    let br4;
	    let t12_value = _("搜尋結果：") + "";
	    let t12;
	    let t13;
	    let br5;
	    let t14_value = _("搜尋分頁為開頭為→的行，可以左右滑動翻頁，點擊翻下一頁。") + "";
	    let t14;
	    let t15;
	    let br6;
	    let t16_value = _("部類名右邊的紅色數字表示關鍵字出現次數，點擊顯示所有摘要行。") + "";
	    let t16;
	    let t17;
	    let br7;
	    let t18_value = _("點部類名統計標題內關鍵字出現次數，點出現次數顯示該章節內之摘要行。") + "";
	    let t18;
	    let t19;
	    let br8;
	    let t20_value = _("輸入時會顯示開頭符合、結尾符合或中間符合的推薦詞，點一下帶入候選區。") + "";
	    let t20;
	    let t21;
	    let br9;
	    let t22_value = _("從搜尋結果跳轉到本文，搜尋文字會加入記憶，最多二十組，超過刪去最初的記憶。按旁邊的紅色叉可刪除。") + "";
	    let t22;
	    let current;
	    tofindhistory = new Tofindhistory({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(tofindhistory.$$.fragment);
	            t0 = space();
	            hr = element("hr");
	            t1 = space();
	            div = element("div");
	            t2 = text(t2_value);
	            t3 = space();
	            br0 = element("br");
	            t4 = text(t4_value);
	            t5 = space();
	            br1 = element("br");
	            t6 = text(t6_value);
	            t7 = space();
	            br2 = element("br");
	            t8 = text(t8_value);
	            t9 = space();
	            br3 = element("br");
	            t10 = text(t10_value);
	            t11 = space();
	            br4 = element("br");
	            t12 = text(t12_value);
	            t13 = space();
	            br5 = element("br");
	            t14 = text(t14_value);
	            t15 = space();
	            br6 = element("br");
	            t16 = text(t16_value);
	            t17 = space();
	            br7 = element("br");
	            t18 = text(t18_value);
	            t19 = space();
	            br8 = element("br");
	            t20 = text(t20_value);
	            t21 = space();
	            br9 = element("br");
	            t22 = text(t22_value);
	            add_location(hr, file$i, 5, 0, 118);
	            add_location(br0, file$i, 8, 0, 183);
	            add_location(br1, file$i, 9, 0, 211);
	            add_location(br2, file$i, 10, 0, 248);
	            add_location(br3, file$i, 11, 0, 288);
	            add_location(br4, file$i, 12, 0, 324);
	            add_location(br5, file$i, 13, 0, 342);
	            add_location(br6, file$i, 14, 0, 383);
	            add_location(br7, file$i, 15, 0, 426);
	            add_location(br8, file$i, 16, 0, 472);
	            add_location(br9, file$i, 17, 0, 519);
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$i, 6, 0, 124);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            mount_component(tofindhistory, target, anchor);
	            insert_dev(target, t0, anchor);
	            insert_dev(target, hr, anchor);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, div, anchor);
	            append_dev(div, t2);
	            append_dev(div, t3);
	            append_dev(div, br0);
	            append_dev(div, t4);
	            append_dev(div, t5);
	            append_dev(div, br1);
	            append_dev(div, t6);
	            append_dev(div, t7);
	            append_dev(div, br2);
	            append_dev(div, t8);
	            append_dev(div, t9);
	            append_dev(div, br3);
	            append_dev(div, t10);
	            append_dev(div, t11);
	            append_dev(div, br4);
	            append_dev(div, t12);
	            append_dev(div, t13);
	            append_dev(div, br5);
	            append_dev(div, t14);
	            append_dev(div, t15);
	            append_dev(div, br6);
	            append_dev(div, t16);
	            append_dev(div, t17);
	            append_dev(div, br7);
	            append_dev(div, t18);
	            append_dev(div, t19);
	            append_dev(div, br8);
	            append_dev(div, t20);
	            append_dev(div, t21);
	            append_dev(div, br9);
	            append_dev(div, t22);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(tofindhistory.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(tofindhistory.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(hr);
	                detach_dev(t1);
	                detach_dev(div);
	            }
	            destroy_component(tofindhistory, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$j.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$j($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Searchhelp', slots, []);
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Searchhelp> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            TofindHistory: Tofindhistory,
	            _
	        });
	    return [];
	}
	class Searchhelp extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$j, create_fragment$j, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Searchhelp",
	            options,
	            id: create_fragment$j.name
	        });
	    }
	}

	const makeAddressFromLine = (line, _ptk)=>{
	    const ptk = _ptk || curPtk();
	    const bk = ptk.nearestTag(line + 1, 'bk', 'id');
	    const ck = ptk.nearestTag(line + 1, 'ck', 'id');
	    const n = ptk.nearestTag(line + 1, 'n', 'id');
	    if (typeof bk == 'undefined' || typeof ck == 'undefined' || typeof n == 'undefined') return '';
	    const addr = 'bk#' + bk + '.ck#' + ck + '.n' + n;
	    const [start] = ptk.rangeOfAddress(addr);
	    return line - start > 0 ? addr + ':' + (line - start) : addr;
	};
	const humanAddress = (addr)=>{
	    const ptk = curPtk();
	    let out = '';
	    const [start] = ptk.rangeOfAddress(addr);
	    const ck = ptk.nearestChunk(start);
	    out += (ck === null || ck === void 0 ? void 0 : ck.caption.replace(/\d+$/g, '')) || ''; //remove tailing number
	    return out;
	};
	const paliHumanAddress = (addr)=>{
	    const m = addr.match(/ak#([dmsa])n\.ck#([^\.]+)(.*)/);
	    if (!m) return '';
	    let r = '';
	    const section = m[2].replace(/[dmsa]/, '');
	    const sutta = m[3].replace('.n', '');
	    if (m[1] == 'd') {
	        r = '長部' + section + '經';
	    } else if (m[1] == 'm') {
	        r = '中部' + section + '經';
	    } else if (m[1] == 's') {
	        r = section + '相應' + sutta + '經';
	    } else if (m[1] == 'a') {
	        r = '增支' + section + '集' + sutta + '經';
	    }
	    return r;
	};

	const file$h = "src\\comps\\simplebutton.svelte";
	function create_fragment$i(ctx) {
	    let span;
	    let span_class_value;
	    let current;
	    let mounted;
	    let dispose;
	    const default_slot_template = /*#slots*/ ctx[5].default;
	    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	    const block = {
	        c: function create() {
	            span = element("span");
	            if (default_slot) default_slot.c();
	            attr_dev(span, "class", span_class_value = /*className*/ ctx[1] + /*clicked*/ (ctx[3] ? ' clicked' : ''));
	            attr_dev(span, "title", /*title*/ ctx[2]);
	            attr_dev(span, "aria-hidden", "true");
	            add_location(span, file$h, 6, 0, 127);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            if (default_slot) {
	                default_slot.m(span, null);
	            }
	            current = true;
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*click_handler*/ ctx[6], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (default_slot) {
	                if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
	                    update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[4]) : get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null), null);
	                }
	            }
	            if (!current || dirty & /*className, clicked*/ 10 && span_class_value !== (span_class_value = /*className*/ ctx[1] + /*clicked*/ (ctx[3] ? ' clicked' : ''))) {
	                attr_dev(span, "class", span_class_value);
	            }
	            if (!current || dirty & /*title*/ 4) {
	                attr_dev(span, "title", /*title*/ ctx[2]);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(default_slot, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(default_slot, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            if (default_slot) default_slot.d(detaching);
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$i.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$i($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Simplebutton', slots, [
	        'default'
	    ]);
	    let { onclick = ()=>{} } = $$props;
	    let { className = 'clickable' } = $$props;
	    let { title = '' } = $$props;
	    let { clicked = false } = $$props;
	    const writable_props = [
	        'onclick',
	        'className',
	        'title',
	        'clicked'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Simplebutton> was created with unknown prop '${key}'`);
	    });
	    const click_handler = ()=>onclick();
	    $$self.$$set = ($$props)=>{
	        if ('onclick' in $$props) $$invalidate(0, onclick = $$props.onclick);
	        if ('className' in $$props) $$invalidate(1, className = $$props.className);
	        if ('title' in $$props) $$invalidate(2, title = $$props.title);
	        if ('clicked' in $$props) $$invalidate(3, clicked = $$props.clicked);
	        if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	    };
	    $$self.$capture_state = ()=>({
	            onclick,
	            className,
	            title,
	            clicked
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('onclick' in $$props) $$invalidate(0, onclick = $$props.onclick);
	        if ('className' in $$props) $$invalidate(1, className = $$props.className);
	        if ('title' in $$props) $$invalidate(2, title = $$props.title);
	        if ('clicked' in $$props) $$invalidate(3, clicked = $$props.clicked);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        onclick,
	        className,
	        title,
	        clicked,
	        $$scope,
	        slots,
	        click_handler
	    ];
	}
	class Simplebutton extends SvelteComponentDev {
	    get onclick() {
	        throw new Error("<Simplebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set onclick(value) {
	        throw new Error("<Simplebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get className() {
	        throw new Error("<Simplebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set className(value) {
	        throw new Error("<Simplebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get title() {
	        throw new Error("<Simplebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set title(value) {
	        throw new Error("<Simplebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get clicked() {
	        throw new Error("<Simplebutton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set clicked(value) {
	        throw new Error("<Simplebutton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$i, create_fragment$i, safe_not_equal, {
	            onclick: 0,
	            className: 1,
	            title: 2,
	            clicked: 3
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Simplebutton",
	            options,
	            id: create_fragment$i.name
	        });
	    }
	}

	function get_each_context$7(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[12] = list[i];
	    child_ctx[14] = i;
	    return child_ctx;
	}
	const get_default_slot_changes = (dirty)=>({
	        tk: dirty & /*abridges*/ 2
	    });
	const get_default_slot_context = (ctx)=>({
	        tk: /*ab*/ ctx[12]
	    });
	// (35:0) {:else}
	function create_else_block$6(ctx) {
	    let current;
	    const default_slot_template = /*#slots*/ ctx[7].default;
	    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], get_default_slot_context);
	    const default_slot_or_fallback = default_slot || fallback_block(ctx);
	    const block = {
	        c: function create() {
	            if (default_slot_or_fallback) default_slot_or_fallback.c();
	        },
	        m: function mount(target, anchor) {
	            if (default_slot_or_fallback) {
	                default_slot_or_fallback.m(target, anchor);
	            }
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (default_slot) {
	                if (default_slot.p && (!current || dirty & /*$$scope, abridges*/ 2050)) {
	                    update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], !current ? get_all_dirty_from_scope(/*$$scope*/ ctx[11]) : get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, get_default_slot_changes), get_default_slot_context);
	                }
	            } else {
	                if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*abridges*/ 2)) {
	                    default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
	                }
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(default_slot_or_fallback, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(default_slot_or_fallback, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$6.name,
	        type: "else",
	        source: "(35:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (30:0) {#if Array.isArray(ab)}
	function create_if_block$b(ctx) {
	    let if_block0_anchor;
	    let simplebutton;
	    let if_block1_anchor;
	    let current;
	    let if_block0 = /*ab*/ ctx[12][1] && /*ab*/ ctx[12][0] > 10 && create_if_block_2$3(ctx);
	    function func_1() {
	        return /*func_1*/ ctx[9](/*idx*/ ctx[14]);
	    }
	    simplebutton = new Simplebutton({
	        props: {
	            className: "abridged",
	            onclick: func_1,
	            $$slots: {
	                default: [
	                    create_default_slot_1$1
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    let if_block1 = !/*ab*/ ctx[12][2] && create_if_block_1$6(ctx);
	    const block = {
	        c: function create() {
	            if (if_block0) if_block0.c();
	            if_block0_anchor = empty();
	            create_component(simplebutton.$$.fragment);
	            if (if_block1) if_block1.c();
	            if_block1_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if (if_block0) if_block0.m(target, anchor);
	            insert_dev(target, if_block0_anchor, anchor);
	            mount_component(simplebutton, target, anchor);
	            if (if_block1) if_block1.m(target, anchor);
	            insert_dev(target, if_block1_anchor, anchor);
	            current = true;
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (/*ab*/ ctx[12][1] && /*ab*/ ctx[12][0] > 10) {
	                if (if_block0) {
	                    if_block0.p(ctx, dirty);
	                    if (dirty & /*abridges*/ 2) {
	                        transition_in(if_block0, 1);
	                    }
	                } else {
	                    if_block0 = create_if_block_2$3(ctx);
	                    if_block0.c();
	                    transition_in(if_block0, 1);
	                    if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
	                }
	            } else if (if_block0) {
	                group_outros();
	                transition_out(if_block0, 1, 1, ()=>{
	                    if_block0 = null;
	                });
	                check_outros();
	            }
	            const simplebutton_changes = {};
	            if (dirty & /*$$scope, abridges*/ 2050) {
	                simplebutton_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            simplebutton.$set(simplebutton_changes);
	            if (!/*ab*/ ctx[12][2]) {
	                if (if_block1) {
	                    if_block1.p(ctx, dirty);
	                    if (dirty & /*abridges*/ 2) {
	                        transition_in(if_block1, 1);
	                    }
	                } else {
	                    if_block1 = create_if_block_1$6(ctx);
	                    if_block1.c();
	                    transition_in(if_block1, 1);
	                    if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	                }
	            } else if (if_block1) {
	                group_outros();
	                transition_out(if_block1, 1, 1, ()=>{
	                    if_block1 = null;
	                });
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block0);
	            transition_in(simplebutton.$$.fragment, local);
	            transition_in(if_block1);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block0);
	            transition_out(simplebutton.$$.fragment, local);
	            transition_out(if_block1);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block0_anchor);
	                detach_dev(if_block1_anchor);
	            }
	            if (if_block0) if_block0.d(detaching);
	            destroy_component(simplebutton, detaching);
	            if (if_block1) if_block1.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$b.name,
	        type: "if",
	        source: "(30:0) {#if Array.isArray(ab)}",
	        ctx
	    });
	    return block;
	}
	// (36:14) {ab.text}
	function fallback_block(ctx) {
	    let t_value = /*ab*/ ctx[12].text + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*abridges*/ 2 && t_value !== (t_value = /*ab*/ ctx[12].text + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: fallback_block.name,
	        type: "fallback",
	        source: "(36:14) {ab.text}",
	        ctx
	    });
	    return block;
	}
	// (31:0) {#if ab[1] && ab[0]>10}
	function create_if_block_2$3(ctx) {
	    let simplebutton;
	    let current;
	    function func() {
	        return /*func*/ ctx[8](/*idx*/ ctx[14]);
	    }
	    simplebutton = new Simplebutton({
	        props: {
	            onclick: func,
	            $$slots: {
	                default: [
	                    create_default_slot_2$1
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(simplebutton.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(simplebutton, target, anchor);
	            current = true;
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            const simplebutton_changes = {};
	            if (dirty & /*$$scope*/ 2048) {
	                simplebutton_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            simplebutton.$set(simplebutton_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(simplebutton.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(simplebutton.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(simplebutton, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_2$3.name,
	        type: "if",
	        source: "(31:0) {#if ab[1] && ab[0]>10}",
	        ctx
	    });
	    return block;
	}
	// (31:23) <SimpleButton  onclick={()=>expand(idx,1)}>
	function create_default_slot_2$1(ctx) {
	    let t;
	    const block = {
	        c: function create() {
	            t = text("…");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot_2$1.name,
	        type: "slot",
	        source: "(31:23) <SimpleButton  onclick={()=>expand(idx,1)}>",
	        ctx
	    });
	    return block;
	}
	// (32:49) <SimpleButton className="abridged"   onclick={()=>expand(idx)}>
	function create_default_slot_1$1(ctx) {
	    let t_value = /*ab*/ ctx[12][0] + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*abridges*/ 2 && t_value !== (t_value = /*ab*/ ctx[12][0] + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot_1$1.name,
	        type: "slot",
	        source: "(32:49) <SimpleButton className=\\\"abridged\\\"   onclick={()=>expand(idx)}>",
	        ctx
	    });
	    return block;
	}
	// (33:48) {#if !ab[2]}
	function create_if_block_1$6(ctx) {
	    let simplebutton;
	    let current;
	    function func_2() {
	        return /*func_2*/ ctx[10](/*idx*/ ctx[14]);
	    }
	    simplebutton = new Simplebutton({
	        props: {
	            onclick: func_2,
	            $$slots: {
	                default: [
	                    create_default_slot$3
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(simplebutton.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(simplebutton, target, anchor);
	            current = true;
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            const simplebutton_changes = {};
	            if (dirty & /*$$scope*/ 2048) {
	                simplebutton_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            simplebutton.$set(simplebutton_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(simplebutton.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(simplebutton.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(simplebutton, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$6.name,
	        type: "if",
	        source: "(33:48) {#if !ab[2]}",
	        ctx
	    });
	    return block;
	}
	// (33:60) <SimpleButton  onclick={()=>expand(idx,-1)}>
	function create_default_slot$3(ctx) {
	    let t;
	    const block = {
	        c: function create() {
	            t = text("…");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot$3.name,
	        type: "slot",
	        source: "(33:60) <SimpleButton  onclick={()=>expand(idx,-1)}>",
	        ctx
	    });
	    return block;
	}
	// (29:0) {#each abridges as ab,idx}
	function create_each_block$7(ctx) {
	    let show_if;
	    let current_block_type_index;
	    let if_block;
	    let if_block_anchor;
	    let current;
	    const if_block_creators = [
	        create_if_block$b,
	        create_else_block$6
	    ];
	    const if_blocks = [];
	    function select_block_type(ctx, dirty) {
	        if (dirty & /*abridges*/ 2) show_if = null;
	        if (show_if == null) show_if = !!Array.isArray(/*ab*/ ctx[12]);
	        if (show_if) return 0;
	        return 1;
	    }
	    current_block_type_index = select_block_type(ctx, -1);
	    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    const block = {
	        c: function create() {
	            if_block.c();
	            if_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if_blocks[current_block_type_index].m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            let previous_block_index = current_block_type_index;
	            current_block_type_index = select_block_type(ctx, dirty);
	            if (current_block_type_index === previous_block_index) {
	                if_blocks[current_block_type_index].p(ctx, dirty);
	            } else {
	                group_outros();
	                transition_out(if_blocks[previous_block_index], 1, 1, ()=>{
	                    if_blocks[previous_block_index] = null;
	                });
	                check_outros();
	                if_block = if_blocks[current_block_type_index];
	                if (!if_block) {
	                    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	                    if_block.c();
	                } else {
	                    if_block.p(ctx, dirty);
	                }
	                transition_in(if_block, 1);
	                if_block.m(if_block_anchor.parentNode, if_block_anchor);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if_blocks[current_block_type_index].d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$7.name,
	        type: "each",
	        source: "(29:0) {#each abridges as ab,idx}",
	        ctx
	    });
	    return block;
	}
	// (28:0) {#key refreshcount}
	function create_key_block$6(ctx) {
	    let each_1_anchor;
	    let current;
	    let each_value = ensure_array_like_dev(/*abridges*/ ctx[1]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	    }
	    const out = (i)=>transition_out(each_blocks[i], 1, 1, ()=>{
	            each_blocks[i] = null;
	        });
	    const block = {
	        c: function create() {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            each_1_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, each_1_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*expand, abridges, Array, $$scope*/ 2054) {
	                each_value = ensure_array_like_dev(/*abridges*/ ctx[1]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$7(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                        transition_in(each_blocks[i], 1);
	                    } else {
	                        each_blocks[i] = create_each_block$7(child_ctx);
	                        each_blocks[i].c();
	                        transition_in(each_blocks[i], 1);
	                        each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	                    }
	                }
	                group_outros();
	                for(i = each_value.length; i < each_blocks.length; i += 1){
	                    out(i);
	                }
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            for(let i = 0; i < each_value.length; i += 1){
	                transition_in(each_blocks[i]);
	            }
	            current = true;
	        },
	        o: function outro(local) {
	            each_blocks = each_blocks.filter(Boolean);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                transition_out(each_blocks[i]);
	            }
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(each_1_anchor);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$6.name,
	        type: "key",
	        source: "(28:0) {#key refreshcount}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$h(ctx) {
	    let previous_key = /*refreshcount*/ ctx[0];
	    let key_block_anchor;
	    let current;
	    let key_block = create_key_block$6(ctx);
	    const block = {
	        c: function create() {
	            key_block.c();
	            key_block_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            key_block.m(target, anchor);
	            insert_dev(target, key_block_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*refreshcount*/ 1 && safe_not_equal(previous_key, previous_key = /*refreshcount*/ ctx[0])) {
	                group_outros();
	                transition_out(key_block, 1, 1, noop);
	                check_outros();
	                key_block = create_key_block$6(ctx);
	                key_block.c();
	                transition_in(key_block, 1);
	                key_block.m(key_block_anchor.parentNode, key_block_anchor);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(key_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(key_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(key_block_anchor);
	            }
	            key_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$h.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$h($$self, $$props, $$invalidate) {
	    let runits;
	    let abridges;
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Abridge', slots, [
	        'default'
	    ]);
	    let { hits = [] } = $$props;
	    if (!hits.length) hits = [
	        0
	    ]; //display begining snippet
	    let { phraselength = [
	        5
	    ] } = $$props;
	    let { text = '' } = $$props;
	    let refreshcount = 1;
	    const expand = (idx, direction = 0)=>{
	        const R = runits;
	        const [len, from] = abridges[idx];
	        const start = from + (direction == -1 ? len : 0);
	        let j = start;
	        if (direction == -1) {
	            while(j > 0 && (R[j].token.type >= TokenType.SEARCHABLE || start - j < MIN_ABRIDGE))j--;
	            for(let i = j; i < start; i++)R[i].luminate++;
	        } else if (direction == 1) {
	            while(j < R.length && (R[j].token.type >= TokenType.SEARCHABLE || j - start < MIN_ABRIDGE))j++;
	            for(let i = start; i < j; i++)R[i].luminate++;
	        } else {
	            for(let i = from; i < from + len; i++)R[i].luminate++;
	        }
	        $$invalidate(0, refreshcount++, refreshcount);
	    };
	    const writable_props = [
	        'hits',
	        'phraselength',
	        'text'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Abridge> was created with unknown prop '${key}'`);
	    });
	    const func = (idx)=>expand(idx, 1);
	    const func_1 = (idx)=>expand(idx);
	    const func_2 = (idx)=>expand(idx, -1);
	    $$self.$$set = ($$props)=>{
	        if ('hits' in $$props) $$invalidate(3, hits = $$props.hits);
	        if ('phraselength' in $$props) $$invalidate(4, phraselength = $$props.phraselength);
	        if ('text' in $$props) $$invalidate(5, text = $$props.text);
	        if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	    };
	    $$self.$capture_state = ()=>({
	            renderOfftext,
	            abridgeRenderUnits,
	            TokenType,
	            MIN_ABRIDGE,
	            SimpleButton: Simplebutton,
	            hits,
	            phraselength,
	            text,
	            refreshcount,
	            expand,
	            abridges,
	            runits
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('hits' in $$props) $$invalidate(3, hits = $$props.hits);
	        if ('phraselength' in $$props) $$invalidate(4, phraselength = $$props.phraselength);
	        if ('text' in $$props) $$invalidate(5, text = $$props.text);
	        if ('refreshcount' in $$props) $$invalidate(0, refreshcount = $$props.refreshcount);
	        if ('abridges' in $$props) $$invalidate(1, abridges = $$props.abridges);
	        if ('runits' in $$props) $$invalidate(6, runits = $$props.runits);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*text, hits, phraselength*/ 56) {
	            $$invalidate(6, [runits] = renderOfftext(text, {
	                hits,
	                phraselength
	            }), runits);
	        }
	        if ($$self.$$.dirty & /*runits, refreshcount*/ 65) {
	            $$invalidate(1, abridges = abridgeRenderUnits(runits, 20));
	        }
	    };
	    return [
	        refreshcount,
	        abridges,
	        expand,
	        hits,
	        phraselength,
	        text,
	        runits,
	        slots,
	        func,
	        func_1,
	        func_2,
	        $$scope
	    ];
	}
	class Abridge extends SvelteComponentDev {
	    get hits() {
	        throw new Error("<Abridge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set hits(value) {
	        throw new Error("<Abridge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get phraselength() {
	        throw new Error("<Abridge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set phraselength(value) {
	        throw new Error("<Abridge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get text() {
	        throw new Error("<Abridge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set text(value) {
	        throw new Error("<Abridge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$h, create_fragment$h, safe_not_equal, {
	            hits: 3,
	            phraselength: 4,
	            text: 5
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Abridge",
	            options,
	            id: create_fragment$h.name
	        });
	    }
	}

	const file$g = "src\\excerptline.svelte";
	// (12:118) {:else}
	function create_else_block$5(ctx) {
	    let t_value = /*tk*/ ctx[6].text + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*tk*/ 64 && t_value !== (t_value = /*tk*/ ctx[6].text + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$5.name,
	        type: "else",
	        source: "(12:118) {:else}",
	        ctx
	    });
	    return block;
	}
	// (12:0) {#if tk.highlight}
	function create_if_block$a(ctx) {
	    let span;
	    let t_value = /*tk*/ ctx[6].text + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[5](/*tk*/ ctx[6]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable hl0");
	            add_location(span, file$g, 11, 18, 297);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*tk*/ 64 && t_value !== (t_value = /*tk*/ ctx[6].text + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$a.name,
	        type: "if",
	        source: "(12:0) {#if tk.highlight}",
	        ctx
	    });
	    return block;
	}
	// (11:0) <Abridge {phraselength} text={linetext} {hits} let:tk>
	function create_default_slot$2(ctx) {
	    let if_block_anchor;
	    function select_block_type(ctx, dirty) {
	        if (/*tk*/ ctx[6].highlight) return create_if_block$a;
	        return create_else_block$5;
	    }
	    let current_block_type = select_block_type(ctx);
	    let if_block = current_block_type(ctx);
	    const block = {
	        c: function create() {
	            if_block.c();
	            if_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	                if_block.p(ctx, dirty);
	            } else {
	                if_block.d(1);
	                if_block = current_block_type(ctx);
	                if (if_block) {
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot$2.name,
	        type: "slot",
	        source: "(11:0) <Abridge {phraselength} text={linetext} {hits} let:tk>",
	        ctx
	    });
	    return block;
	}
	function create_fragment$g(ctx) {
	    let abridge;
	    let current;
	    abridge = new Abridge({
	        props: {
	            phraselength: /*phraselength*/ ctx[3],
	            text: /*linetext*/ ctx[0],
	            hits: /*hits*/ ctx[2],
	            $$slots: {
	                default: [
	                    create_default_slot$2,
	                    ({ tk })=>({
	                            6: tk
	                        }),
	                    ({ tk })=>tk ? 64 : 0
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(abridge.$$.fragment);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            mount_component(abridge, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            const abridge_changes = {};
	            if (dirty & /*phraselength*/ 8) abridge_changes.phraselength = /*phraselength*/ ctx[3];
	            if (dirty & /*linetext*/ 1) abridge_changes.text = /*linetext*/ ctx[0];
	            if (dirty & /*hits*/ 4) abridge_changes.hits = /*hits*/ ctx[2];
	            if (dirty & /*$$scope, gochar, line, tk*/ 210) {
	                abridge_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            abridge.$set(abridge_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(abridge.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(abridge.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(abridge, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$g.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$g($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Excerptline', slots, []);
	    let { linetext = '' } = $$props;
	    let { line = 0 } = $$props;
	    let { hits = [] } = $$props;
	    let { phraselength = [] } = $$props;
	    let { gochar = function(choff) {} } = $$props;
	    const writable_props = [
	        'linetext',
	        'line',
	        'hits',
	        'phraselength',
	        'gochar'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Excerptline> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (tk)=>gochar(line, tk.choff);
	    $$self.$$set = ($$props)=>{
	        if ('linetext' in $$props) $$invalidate(0, linetext = $$props.linetext);
	        if ('line' in $$props) $$invalidate(1, line = $$props.line);
	        if ('hits' in $$props) $$invalidate(2, hits = $$props.hits);
	        if ('phraselength' in $$props) $$invalidate(3, phraselength = $$props.phraselength);
	        if ('gochar' in $$props) $$invalidate(4, gochar = $$props.gochar);
	    };
	    $$self.$capture_state = ()=>({
	            _,
	            Abridge,
	            linetext,
	            line,
	            hits,
	            phraselength,
	            gochar
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('linetext' in $$props) $$invalidate(0, linetext = $$props.linetext);
	        if ('line' in $$props) $$invalidate(1, line = $$props.line);
	        if ('hits' in $$props) $$invalidate(2, hits = $$props.hits);
	        if ('phraselength' in $$props) $$invalidate(3, phraselength = $$props.phraselength);
	        if ('gochar' in $$props) $$invalidate(4, gochar = $$props.gochar);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        linetext,
	        line,
	        hits,
	        phraselength,
	        gochar,
	        click_handler
	    ];
	}
	class Excerptline extends SvelteComponentDev {
	    get linetext() {
	        throw new Error("<Excerptline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set linetext(value) {
	        throw new Error("<Excerptline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get line() {
	        throw new Error("<Excerptline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set line(value) {
	        throw new Error("<Excerptline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get hits() {
	        throw new Error("<Excerptline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set hits(value) {
	        throw new Error("<Excerptline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get phraselength() {
	        throw new Error("<Excerptline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set phraselength(value) {
	        throw new Error("<Excerptline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get gochar() {
	        throw new Error("<Excerptline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set gochar(value) {
	        throw new Error("<Excerptline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$g, create_fragment$g, safe_not_equal, {
	            linetext: 0,
	            line: 1,
	            hits: 2,
	            phraselength: 3,
	            gochar: 4
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Excerptline",
	            options,
	            id: create_fragment$g.name
	        });
	    }
	}

	const file$f = "src\\excerpt.svelte";
	function get_each_context$6(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[32] = list[i];
	    child_ctx[34] = i;
	    return child_ctx;
	}
	function get_each_context_1$2(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[35] = list[i];
	    child_ctx[34] = i;
	    return child_ctx;
	}
	function get_each_context_2$1(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[39] = list[i];
	    child_ctx[34] = i;
	    return child_ctx;
	}
	// (126:0) {#each scopes as scope,idx}
	function create_each_block_2$1(ctx) {
	    let span0;
	    let t0_value = _(/*scope*/ ctx[39].caption) + "";
	    let t0;
	    let span1;
	    let t1_value = '(' + /*scope*/ ctx[39].count + ')' + "";
	    let t1;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[19](/*idx*/ ctx[34]);
	    }
	    function click_handler_1() {
	        return /*click_handler_1*/ ctx[20](/*idx*/ ctx[34]);
	    }
	    const block = {
	        c: function create() {
	            span0 = element("span");
	            t0 = text(t0_value);
	            span1 = element("span");
	            t1 = text(t1_value);
	            attr_dev(span0, "aria-hidden", "true");
	            attr_dev(span0, "class", "clickable scopebtn");
	            toggle_class(span0, "selected", /*idx*/ ctx[34] * 2 == /*selected*/ ctx[5]);
	            add_location(span0, file$f, 126, 0, 3654);
	            attr_dev(span1, "aria-hidden", "true");
	            attr_dev(span1, "class", "clickable hitbtn");
	            toggle_class(span1, "selected", 1 + /*idx*/ ctx[34] * 2 == /*selected*/ ctx[5]);
	            add_location(span1, file$f, 127, 29, 3800);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span0, anchor);
	            append_dev(span0, t0);
	            insert_dev(target, span1, anchor);
	            append_dev(span1, t1);
	            if (!mounted) {
	                dispose = [
	                    listen_dev(span0, "click", click_handler, false, false, false, false),
	                    listen_dev(span1, "click", click_handler_1, false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty[0] & /*scopes*/ 8 && t0_value !== (t0_value = _(/*scope*/ ctx[39].caption) + "")) set_data_dev(t0, t0_value);
	            if (dirty[0] & /*selected*/ 32) {
	                toggle_class(span0, "selected", /*idx*/ ctx[34] * 2 == /*selected*/ ctx[5]);
	            }
	            if (dirty[0] & /*scopes*/ 8 && t1_value !== (t1_value = '(' + /*scope*/ ctx[39].count + ')' + "")) set_data_dev(t1, t1_value);
	            if (dirty[0] & /*selected*/ 32) {
	                toggle_class(span1, "selected", 1 + /*idx*/ ctx[34] * 2 == /*selected*/ ctx[5]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span0);
	                detach_dev(span1);
	            }
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block_2$1.name,
	        type: "each",
	        source: "(126:0) {#each scopes as scope,idx}",
	        ctx
	    });
	    return block;
	}
	// (133:0) <Pager caption={rangecaption} count={pagecount} bind:now onselect={gopage} let:idx let:caption let:active>
	function create_default_slot_2(ctx) {
	    let span;
	    let t_value = _(/*caption*/ ctx[37]) + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler_2() {
	        return /*click_handler_2*/ ctx[21](/*idx*/ ctx[34]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*active*/ ctx[38]);
	            add_location(span, file$f, 133, 4, 4096);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler_2, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty[1] & /*caption*/ 64 && t_value !== (t_value = _(/*caption*/ ctx[37]) + "")) set_data_dev(t, t_value);
	            if (dirty[1] & /*active*/ 128) {
	                toggle_class(span, "selected", /*active*/ ctx[38]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot_2.name,
	        type: "slot",
	        source: "(133:0) <Pager caption={rangecaption} count={pagecount} bind:now onselect={gopage} let:idx let:caption let:active>",
	        ctx
	    });
	    return block;
	}
	// (139:0) {#each excerpts as excerpt,idx}
	function create_each_block_1$2(ctx) {
	    let div;
	    let span0;
	    let t0_value = /*idx*/ ctx[34] + /*now*/ ctx[2] * ITEMPERPAGE + 1 + "";
	    let t0;
	    let excerptline;
	    let t1;
	    let span1;
	    let t2_value = humanAddress(makeAddressFromLine(/*excerpt*/ ctx[35].line)) + "";
	    let t2;
	    let t3;
	    let current;
	    let mounted;
	    let dispose;
	    const excerptline_spread_levels = [
	        {
	            gochar: /*gochar*/ ctx[14]
	        },
	        /*excerpt*/ ctx[35]
	    ];
	    let excerptline_props = {};
	    for(let i = 0; i < excerptline_spread_levels.length; i += 1){
	        excerptline_props = assign(excerptline_props, excerptline_spread_levels[i]);
	    }
	    excerptline = new Excerptline({
	        props: excerptline_props,
	        $$inline: true
	    });
	    function click_handler_3() {
	        return /*click_handler_3*/ ctx[23](/*idx*/ ctx[34]);
	    }
	    const block = {
	        c: function create() {
	            div = element("div");
	            span0 = element("span");
	            t0 = text(t0_value);
	            create_component(excerptline.$$.fragment);
	            t1 = space();
	            span1 = element("span");
	            t2 = text(t2_value);
	            t3 = space();
	            attr_dev(span0, "class", "excerptseq");
	            add_location(span0, file$f, 140, 0, 4361);
	            attr_dev(span1, "class", "clickable ck");
	            attr_dev(span1, "aria-hidden", "true");
	            toggle_class(span1, "selected", /*selecteditem*/ ctx[6] == /*idx*/ ctx[34] + /*now*/ ctx[2] * ITEMPERPAGE);
	            add_location(span1, file$f, 141, 0, 4456);
	            attr_dev(div, "class", "excerptline");
	            toggle_class(div, "oddline", /*idx*/ ctx[34] % 2 == 0);
	            add_location(div, file$f, 139, 0, 4310);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, span0);
	            append_dev(span0, t0);
	            mount_component(excerptline, div, null);
	            append_dev(div, t1);
	            append_dev(div, span1);
	            append_dev(span1, t2);
	            append_dev(div, t3);
	            current = true;
	            if (!mounted) {
	                dispose = listen_dev(span1, "click", click_handler_3, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if ((!current || dirty[0] & /*now*/ 4) && t0_value !== (t0_value = /*idx*/ ctx[34] + /*now*/ ctx[2] * ITEMPERPAGE + 1 + "")) set_data_dev(t0, t0_value);
	            const excerptline_changes = dirty[0] & /*gochar, excerpts*/ 16385 ? get_spread_update(excerptline_spread_levels, [
	                dirty[0] & /*gochar*/ 16384 && {
	                    gochar: /*gochar*/ ctx[14]
	                },
	                dirty[0] & /*excerpts*/ 1 && get_spread_object(/*excerpt*/ ctx[35])
	            ]) : {};
	            excerptline.$set(excerptline_changes);
	            if ((!current || dirty[0] & /*excerpts*/ 1) && t2_value !== (t2_value = humanAddress(makeAddressFromLine(/*excerpt*/ ctx[35].line)) + "")) set_data_dev(t2, t2_value);
	            if (!current || dirty[0] & /*selecteditem, now*/ 68) {
	                toggle_class(span1, "selected", /*selecteditem*/ ctx[6] == /*idx*/ ctx[34] + /*now*/ ctx[2] * ITEMPERPAGE);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(excerptline.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(excerptline.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_component(excerptline);
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block_1$2.name,
	        type: "each",
	        source: "(139:0) {#each excerpts as excerpt,idx}",
	        ctx
	    });
	    return block;
	}
	// (138:0) <Swipeview {onSwipe} reverse={$reverseswipe=='1'}>
	function create_default_slot_1(ctx) {
	    let each_1_anchor;
	    let current;
	    let each_value_1 = ensure_array_like_dev(/*excerpts*/ ctx[0]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value_1.length; i += 1){
	        each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	    }
	    const out = (i)=>transition_out(each_blocks[i], 1, 1, ()=>{
	            each_blocks[i] = null;
	        });
	    const block = {
	        c: function create() {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            each_1_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, each_1_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*selecteditem, now, go, excerpts, gochar*/ 20549) {
	                each_value_1 = ensure_array_like_dev(/*excerpts*/ ctx[0]);
	                let i;
	                for(i = 0; i < each_value_1.length; i += 1){
	                    const child_ctx = get_each_context_1$2(ctx, each_value_1, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                        transition_in(each_blocks[i], 1);
	                    } else {
	                        each_blocks[i] = create_each_block_1$2(child_ctx);
	                        each_blocks[i].c();
	                        transition_in(each_blocks[i], 1);
	                        each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	                    }
	                }
	                group_outros();
	                for(i = each_value_1.length; i < each_blocks.length; i += 1){
	                    out(i);
	                }
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            for(let i = 0; i < each_value_1.length; i += 1){
	                transition_in(each_blocks[i]);
	            }
	            current = true;
	        },
	        o: function outro(local) {
	            each_blocks = each_blocks.filter(Boolean);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                transition_out(each_blocks[i]);
	            }
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(each_1_anchor);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot_1.name,
	        type: "slot",
	        source: "(138:0) <Swipeview {onSwipe} reverse={$reverseswipe=='1'}>",
	        ctx
	    });
	    return block;
	}
	// (148:0) {#each chunkhits as chit,idx}
	function create_each_block$6(ctx) {
	    var /*chit*/ _ctx__ck_bk;
	    let div;
	    let span0;
	    let t0_value = /*idx*/ ctx[34] + /*now*/ ctx[2] * ITEMPERPAGE + 1 + "";
	    let t0;
	    let t1;
	    let t2_value = _((_ctx__ck_bk = ctx[32].ck.bk) === null || _ctx__ck_bk === void 0 ? void 0 : _ctx__ck_bk.caption) + "";
	    let t2;
	    let t3;
	    let t4_value = _(/*chit*/ ctx[32].ck.caption) + "";
	    let t4;
	    let t5;
	    let span1;
	    let t6_value = " " + /*chit*/ ctx[32].hits + "";
	    let t6;
	    let mounted;
	    let dispose;
	    function click_handler_4() {
	        return /*click_handler_4*/ ctx[24](/*idx*/ ctx[34]);
	    }
	    function click_handler_5() {
	        return /*click_handler_5*/ ctx[25](/*chit*/ ctx[32]);
	    }
	    const block = {
	        c: function create() {
	            div = element("div");
	            span0 = element("span");
	            t0 = text(t0_value);
	            t1 = space();
	            t2 = text(t2_value);
	            t3 = text("/");
	            t4 = text(t4_value);
	            t5 = space();
	            span1 = element("span");
	            t6 = text(t6_value);
	            attr_dev(span0, "aria-hidden", "true");
	            attr_dev(span0, "class", "excerptseq clickable");
	            toggle_class(span0, "selected", /*selecteditem*/ ctx[6] == /*idx*/ ctx[34]);
	            add_location(span0, file$f, 149, 0, 4814);
	            attr_dev(span1, "aria-hidden", "true");
	            attr_dev(span1, "class", "clickable hit");
	            add_location(span1, file$f, 152, 0, 5008);
	            attr_dev(div, "class", "excerptline");
	            toggle_class(div, "oddline", /*idx*/ ctx[34] % 2 == 0);
	            add_location(div, file$f, 148, 0, 4763);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, span0);
	            append_dev(span0, t0);
	            append_dev(span0, t1);
	            append_dev(span0, t2);
	            append_dev(span0, t3);
	            append_dev(span0, t4);
	            append_dev(div, t5);
	            append_dev(div, span1);
	            append_dev(span1, t6);
	            if (!mounted) {
	                dispose = [
	                    listen_dev(span0, "click", click_handler_4, false, false, false, false),
	                    listen_dev(span1, "click", click_handler_5, false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            var /*chit*/ _ctx__ck_bk;
	            ctx = new_ctx;
	            if (dirty[0] & /*now*/ 4 && t0_value !== (t0_value = /*idx*/ ctx[34] + /*now*/ ctx[2] * ITEMPERPAGE + 1 + "")) set_data_dev(t0, t0_value);
	            if (dirty[0] & /*chunkhits*/ 2 && t2_value !== (t2_value = _((_ctx__ck_bk = ctx[32].ck.bk) === null || _ctx__ck_bk === void 0 ? void 0 : _ctx__ck_bk.caption) + "")) set_data_dev(t2, t2_value);
	            if (dirty[0] & /*chunkhits*/ 2 && t4_value !== (t4_value = _(/*chit*/ ctx[32].ck.caption) + "")) set_data_dev(t4, t4_value);
	            if (dirty[0] & /*selecteditem*/ 64) {
	                toggle_class(span0, "selected", /*selecteditem*/ ctx[6] == /*idx*/ ctx[34]);
	            }
	            if (dirty[0] & /*chunkhits*/ 2 && t6_value !== (t6_value = " " + /*chit*/ ctx[32].hits + "")) set_data_dev(t6, t6_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$6.name,
	        type: "each",
	        source: "(148:0) {#each chunkhits as chit,idx}",
	        ctx
	    });
	    return block;
	}
	// (147:0) <Swipeview {onSwipe} reverse={$reverseswipe=='1'}>
	function create_default_slot$1(ctx) {
	    let each_1_anchor;
	    let each_value = ensure_array_like_dev(/*chunkhits*/ ctx[1]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            each_1_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, each_1_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*setChunkScope, chunkhits, selecteditem, gock, now*/ 10310) {
	                each_value = ensure_array_like_dev(/*chunkhits*/ ctx[1]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$6(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$6(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(each_1_anchor);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot$1.name,
	        type: "slot",
	        source: "(147:0) <Swipeview {onSwipe} reverse={$reverseswipe=='1'}>",
	        ctx
	    });
	    return block;
	}
	function create_fragment$f(ctx) {
	    let div1;
	    let t0;
	    let div0;
	    let pager;
	    let updating_now;
	    let t1;
	    let swipeview0;
	    let t2;
	    let swipeview1;
	    let current;
	    let each_value_2 = ensure_array_like_dev(/*scopes*/ ctx[3]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value_2.length; i += 1){
	        each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
	    }
	    function pager_now_binding(value) {
	        /*pager_now_binding*/ ctx[22](value);
	    }
	    let pager_props = {
	        caption: /*rangecaption*/ ctx[7],
	        count: /*pagecount*/ ctx[4],
	        onselect: /*gopage*/ ctx[10],
	        $$slots: {
	            default: [
	                create_default_slot_2,
	                ({ idx, caption, active })=>({
	                        34: idx,
	                        37: caption,
	                        38: active
	                    }),
	                ({ idx, caption, active })=>[
	                        0,
	                        (idx ? 8 : 0) | (caption ? 64 : 0) | (active ? 128 : 0)
	                    ]
	            ]
	        },
	        $$scope: {
	            ctx
	        }
	    };
	    if (/*now*/ ctx[2] !== void 0) {
	        pager_props.now = /*now*/ ctx[2];
	    }
	    pager = new Pager({
	        props: pager_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(pager, 'now', pager_now_binding));
	    swipeview0 = new Swipeview({
	        props: {
	            onSwipe: /*onSwipe*/ ctx[15],
	            reverse: /*$reverseswipe*/ ctx[8] == '1',
	            $$slots: {
	                default: [
	                    create_default_slot_1
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    swipeview1 = new Swipeview({
	        props: {
	            onSwipe: /*onSwipe*/ ctx[15],
	            reverse: /*$reverseswipe*/ ctx[8] == '1',
	            $$slots: {
	                default: [
	                    create_default_slot$1
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div1 = element("div");
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            t0 = space();
	            div0 = element("div");
	            create_component(pager.$$.fragment);
	            t1 = space();
	            create_component(swipeview0.$$.fragment);
	            t2 = space();
	            create_component(swipeview1.$$.fragment);
	            attr_dev(div0, "class", "pager");
	            add_location(div0, file$f, 131, 0, 3965);
	            attr_dev(div1, "class", "bodytextarea");
	            add_location(div1, file$f, 124, 0, 3599);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div1, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div1, null);
	                }
	            }
	            append_dev(div1, t0);
	            append_dev(div1, div0);
	            mount_component(pager, div0, null);
	            append_dev(div1, t1);
	            mount_component(swipeview0, div1, null);
	            append_dev(div1, t2);
	            mount_component(swipeview1, div1, null);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (dirty[0] & /*selected, setScope, scopes*/ 552) {
	                each_value_2 = ensure_array_like_dev(/*scopes*/ ctx[3]);
	                let i;
	                for(i = 0; i < each_value_2.length; i += 1){
	                    const child_ctx = get_each_context_2$1(ctx, each_value_2, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block_2$1(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div1, t0);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value_2.length;
	            }
	            const pager_changes = {};
	            if (dirty[0] & /*rangecaption*/ 128) pager_changes.caption = /*rangecaption*/ ctx[7];
	            if (dirty[0] & /*pagecount*/ 16) pager_changes.count = /*pagecount*/ ctx[4];
	            if (dirty[1] & /*$$scope, active, idx, caption*/ 1224) {
	                pager_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            if (!updating_now && dirty[0] & /*now*/ 4) {
	                updating_now = true;
	                pager_changes.now = /*now*/ ctx[2];
	                add_flush_callback(()=>updating_now = false);
	            }
	            pager.$set(pager_changes);
	            const swipeview0_changes = {};
	            if (dirty[0] & /*$reverseswipe*/ 256) swipeview0_changes.reverse = /*$reverseswipe*/ ctx[8] == '1';
	            if (dirty[0] & /*excerpts, selecteditem, now*/ 69 | dirty[1] & /*$$scope*/ 1024) {
	                swipeview0_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            swipeview0.$set(swipeview0_changes);
	            const swipeview1_changes = {};
	            if (dirty[0] & /*$reverseswipe*/ 256) swipeview1_changes.reverse = /*$reverseswipe*/ ctx[8] == '1';
	            if (dirty[0] & /*chunkhits, selecteditem, now*/ 70 | dirty[1] & /*$$scope*/ 1024) {
	                swipeview1_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            swipeview1.$set(swipeview1_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(pager.$$.fragment, local);
	            transition_in(swipeview0.$$.fragment, local);
	            transition_in(swipeview1.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(pager.$$.fragment, local);
	            transition_out(swipeview0.$$.fragment, local);
	            transition_out(swipeview1.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div1);
	            }
	            destroy_each(each_blocks, detaching);
	            destroy_component(pager);
	            destroy_component(swipeview0);
	            destroy_component(swipeview1);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$f.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	const ITEMPERPAGE = 5;
	function instance$f($$self, $$props, $$invalidate) {
	    let ptk;
	    let $activePtk;
	    let $tofind;
	    let $reverseswipe;
	    validate_store(activePtk, 'activePtk');
	    component_subscribe($$self, activePtk, ($$value)=>$$invalidate(17, $activePtk = $$value));
	    validate_store(tofind, 'tofind');
	    component_subscribe($$self, tofind, ($$value)=>$$invalidate(18, $tofind = $$value));
	    validate_store(reverseswipe, 'reverseswipe');
	    component_subscribe($$self, reverseswipe, ($$value)=>$$invalidate(8, $reverseswipe = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Excerpt', slots, []);
	    let { goLine } = $$props;
	    // $: includelines=includesent>-1&&ptk?ptk?.columns.sent?.occur[includesent]:null
	    // $: excludelines=excludesent>-1&&ptk?ptk.columns.sent?.occur[excludesent]:null;
	    let allexcerpts = [], excerpts = [], allpostings = [], allchunkhits = [], chunkhits = [], allphrases = [], now = 0, scopes = [];
	    let pagecount = 0, selected = 0, selecteditem = -1;
	    let rangecaption = '';
	    // add 本卷(本經)
	    const setScope = async (idx, range)=>{
	        var _scopes_at;
	        const at = Math.floor(idx / 2);
	        $$invalidate(4, pagecount = 0);
	        if (!((_scopes_at = scopes[at]) === null || _scopes_at === void 0 ? void 0 : _scopes_at.count)) return;
	        $$invalidate(5, selected = idx);
	        if (!range) {
	            $$invalidate(7, rangecaption = '');
	        }
	        const { lines, chunks, phrases, postings } = await listExcerpts(ptk, $tofind, {
	            range: range || scopes[at].scope
	        });
	        allphrases = phrases;
	        allpostings = postings;
	        if (selected % 2 == 0) {
	            allchunkhits = chunks.map((it)=>{
	                return {
	                    ck: ptk.getChunk(it[0]),
	                    hits: it[1]
	                };
	            });
	            $$invalidate(4, pagecount = Math.floor(allchunkhits.length / ITEMPERPAGE) + 1);
	            gopage(0);
	        } else {
	            allexcerpts = lines;
	            $$invalidate(4, pagecount = Math.floor(allexcerpts.length / ITEMPERPAGE) + 1);
	            gopage(0);
	        }
	    };
	    const gopage = async (idx)=>{
	        $$invalidate(0, excerpts.length = 0, excerpts);
	        $$invalidate(1, chunkhits.length = 0, chunkhits);
	        $$invalidate(6, selecteditem = -1);
	        if (selected % 2 == 0) {
	            $$invalidate(1, chunkhits = allchunkhits.slice(idx * ITEMPERPAGE, (idx + 1) * ITEMPERPAGE));
	            $$invalidate(4, pagecount = Math.floor(allchunkhits.length / ITEMPERPAGE) + 1);
	        } else {
	            const toload = [];
	            for(let i = idx * ITEMPERPAGE; i < (idx + 1) * ITEMPERPAGE && i < allexcerpts.length; i++){
	                toload.push(allexcerpts[i]);
	            }
	            await ptk.loadLines(toload.map((it)=>it[0]));
	            for(let i = 0; i < toload.length; i++){
	                const [line, occur] = toload[i];
	                const linetext = ptk.getLine(line);
	                const hits = occur.map((n)=>Math.floor(n / MAXPHRASELEN));
	                const phraselength = occur.map((n)=>n % MAXPHRASELEN);
	                excerpts.push({
	                    linetext,
	                    line,
	                    hits,
	                    phraselength
	                });
	            }
	            $$invalidate(4, pagecount = Math.floor(allexcerpts.length / ITEMPERPAGE) + 1);
	        }
	        $$invalidate(0, excerpts);
	        $$invalidate(1, chunkhits);
	        $$invalidate(2, now = idx);
	    };
	    const setChunkScope = (ck)=>{
	        var _ck_bk;
	        const rangeaddr = 'bk#' + ck.bk.id + '.ck#' + ck.id;
	        $$invalidate(7, rangecaption = (((_ck_bk = ck.bk) === null || _ck_bk === void 0 ? void 0 : _ck_bk.caption) || '') + '/' + ck.caption);
	        setScope(selected * 2 + 1, rangeaddr);
	    };
	    const go = (idx)=>{
	        let line = allexcerpts[idx][0];
	        goLine(line);
	        $$invalidate(6, selecteditem = idx);
	    };
	    const gock = (idx)=>{
	        const chit = chunkhits[idx];
	        const line = chit.ck.line;
	        goLine(line);
	        $$invalidate(6, selecteditem = idx);
	    };
	    const gochar = (line, choff)=>{
	        goLine(line, choff);
	    };
	    const updateList = (tf)=>{
	        ptk.scanText(tf).then((res)=>{
	            $$invalidate(3, scopes = res);
	            let done = false;
	            for(let i = 0; i < scopes.length; i++){
	                //first no-null scope
	                if (scopes[i].count) {
	                    setScope(i * 2 + 1);
	                    done = true;
	                    break;
	                }
	            }
	            if (!done) {
	                //no match
	                allexcerpts = [];
	                allpostings = [];
	                gopage(0);
	            }
	        });
	    };
	    const onSwipe = (direction)=>{
	        const pages = excerpts.length ? excerpts : chunkhits;
	        $$invalidate(2, now += direction);
	        if (now < 0) $$invalidate(2, now = 0);
	        if (now >= pages.length - 1) $$invalidate(2, now = pages.length - 1);
	        gopage(now);
	    };
	    $$self.$$.on_mount.push(function() {
	        if (goLine === undefined && !('goLine' in $$props || $$self.$$.bound[$$self.$$.props['goLine']])) {
	            console.warn("<Excerpt> was created without expected prop 'goLine'");
	        }
	    });
	    const writable_props = [
	        'goLine'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Excerpt> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (idx)=>setScope(idx * 2);
	    const click_handler_1 = (idx)=>setScope(idx * 2 + 1);
	    const click_handler_2 = (idx)=>gopage(idx);
	    function pager_now_binding(value) {
	        now = value;
	        $$invalidate(2, now);
	    }
	    const click_handler_3 = (idx)=>go(idx + now * ITEMPERPAGE);
	    const click_handler_4 = (idx)=>gock(idx);
	    const click_handler_5 = (chit)=>setChunkScope(chit.ck);
	    $$self.$$set = ($$props)=>{
	        if ('goLine' in $$props) $$invalidate(16, goLine = $$props.goLine);
	    };
	    $$self.$capture_state = ()=>({
	            usePtk,
	            listExcerpts,
	            MAXPHRASELEN,
	            activePtk,
	            tofind,
	            reverseswipe,
	            makeAddressFromLine,
	            humanAddress,
	            ExcerptLine: Excerptline,
	            Pager,
	            _,
	            Swipeview,
	            goLine,
	            ITEMPERPAGE,
	            allexcerpts,
	            excerpts,
	            allpostings,
	            allchunkhits,
	            chunkhits,
	            allphrases,
	            now,
	            scopes,
	            pagecount,
	            selected,
	            selecteditem,
	            rangecaption,
	            setScope,
	            gopage,
	            setChunkScope,
	            go,
	            gock,
	            gochar,
	            updateList,
	            onSwipe,
	            ptk,
	            $activePtk,
	            $tofind,
	            $reverseswipe
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('goLine' in $$props) $$invalidate(16, goLine = $$props.goLine);
	        if ('allexcerpts' in $$props) allexcerpts = $$props.allexcerpts;
	        if ('excerpts' in $$props) $$invalidate(0, excerpts = $$props.excerpts);
	        if ('allpostings' in $$props) allpostings = $$props.allpostings;
	        if ('allchunkhits' in $$props) allchunkhits = $$props.allchunkhits;
	        if ('chunkhits' in $$props) $$invalidate(1, chunkhits = $$props.chunkhits);
	        if ('allphrases' in $$props) allphrases = $$props.allphrases;
	        if ('now' in $$props) $$invalidate(2, now = $$props.now);
	        if ('scopes' in $$props) $$invalidate(3, scopes = $$props.scopes);
	        if ('pagecount' in $$props) $$invalidate(4, pagecount = $$props.pagecount);
	        if ('selected' in $$props) $$invalidate(5, selected = $$props.selected);
	        if ('selecteditem' in $$props) $$invalidate(6, selecteditem = $$props.selecteditem);
	        if ('rangecaption' in $$props) $$invalidate(7, rangecaption = $$props.rangecaption);
	        if ('ptk' in $$props) ptk = $$props.ptk;
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty[0] & /*$activePtk*/ 131072) {
	            ptk = usePtk($activePtk);
	        }
	        if ($$self.$$.dirty[0] & /*$tofind, $activePtk*/ 393216) {
	            updateList($tofind);
	        }
	    };
	    return [
	        excerpts,
	        chunkhits,
	        now,
	        scopes,
	        pagecount,
	        selected,
	        selecteditem,
	        rangecaption,
	        $reverseswipe,
	        setScope,
	        gopage,
	        setChunkScope,
	        go,
	        gock,
	        gochar,
	        onSwipe,
	        goLine,
	        $activePtk,
	        $tofind,
	        click_handler,
	        click_handler_1,
	        click_handler_2,
	        pager_now_binding,
	        click_handler_3,
	        click_handler_4,
	        click_handler_5
	    ];
	}
	class Excerpt extends SvelteComponentDev {
	    get goLine() {
	        throw new Error("<Excerpt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set goLine(value) {
	        throw new Error("<Excerpt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$f, create_fragment$f, safe_not_equal, {
	            goLine: 16
	        }, null, [
	            -1,
	            -1
	        ]);
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Excerpt",
	            options,
	            id: create_fragment$f.name
	        });
	    }
	}

	const file$e = "src\\searchmain.svelte";
	function get_each_context$5(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[18] = list[i];
	    child_ctx[20] = i;
	    return child_ctx;
	}
	// (158:0) {#each items as item,idx}
	function create_each_block$5(ctx) {
	    let span;
	    let t_value = _(/*item*/ ctx[18]) + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[14](/*idx*/ ctx[20]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "searchable");
	            toggle_class(span, "selectedsearchable", /*idx*/ ctx[20] <= /*activeidx*/ ctx[2]);
	            add_location(span, file$e, 158, 0, 3940);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*items*/ 1 && t_value !== (t_value = _(/*item*/ ctx[18]) + "")) set_data_dev(t, t_value);
	            if (dirty & /*activeidx*/ 4) {
	                toggle_class(span, "selectedsearchable", /*idx*/ ctx[20] <= /*activeidx*/ ctx[2]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$5.name,
	        type: "each",
	        source: "(158:0) {#each items as item,idx}",
	        ctx
	    });
	    return block;
	}
	// (161:0) {#if !items.length}
	function create_if_block_1$5(ctx) {
	    let t0;
	    let t1_value = _("候選區") + "";
	    let t1;
	    let t2;
	    const block = {
	        c: function create() {
	            t0 = text("【");
	            t1 = text(t1_value);
	            t2 = text("】");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t0, anchor);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, t2, anchor);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(t2);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$5.name,
	        type: "if",
	        source: "(161:0) {#if !items.length}",
	        ctx
	    });
	    return block;
	}
	// (166:0) {:else}
	function create_else_block$4(ctx) {
	    let div;
	    let excerpt;
	    let t;
	    let endmarker;
	    let current;
	    excerpt = new Excerpt({
	        props: {
	            goLine: /*goLine*/ ctx[7]
	        },
	        $$inline: true
	    });
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div = element("div");
	            create_component(excerpt.$$.fragment);
	            t = space();
	            create_component(endmarker.$$.fragment);
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$e, 168, 0, 4207);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            mount_component(excerpt, div, null);
	            insert_dev(target, t, anchor);
	            mount_component(endmarker, target, anchor);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(excerpt.$$.fragment, local);
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(excerpt.$$.fragment, local);
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	                detach_dev(t);
	            }
	            destroy_component(excerpt);
	            destroy_component(endmarker, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$4.name,
	        type: "else",
	        source: "(166:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (163:0) {#if $leftmode=='input' && value.trim()=='' }
	function create_if_block$9(ctx) {
	    let searchhelp;
	    let t;
	    let endmarker;
	    let current;
	    searchhelp = new Searchhelp({
	        $$inline: true
	    });
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(searchhelp.$$.fragment);
	            t = space();
	            create_component(endmarker.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(searchhelp, target, anchor);
	            insert_dev(target, t, anchor);
	            mount_component(endmarker, target, anchor);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(searchhelp.$$.fragment, local);
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(searchhelp.$$.fragment, local);
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	            destroy_component(searchhelp, detaching);
	            destroy_component(endmarker, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$9.name,
	        type: "if",
	        source: "(163:0) {#if $leftmode=='input' && value.trim()=='' }",
	        ctx
	    });
	    return block;
	}
	function create_fragment$e(ctx) {
	    let div;
	    let input;
	    let t0;
	    let t1;
	    let t2;
	    let show_if;
	    let current_block_type_index;
	    let if_block1;
	    let if_block1_anchor;
	    let current;
	    let mounted;
	    let dispose;
	    let each_value = ensure_array_like_dev(/*items*/ ctx[0]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	    }
	    let if_block0 = !/*items*/ ctx[0].length && create_if_block_1$5(ctx);
	    const if_block_creators = [
	        create_if_block$9,
	        create_else_block$4
	    ];
	    const if_blocks = [];
	    function select_block_type(ctx, dirty) {
	        if (dirty & /*$leftmode, value*/ 24) show_if = null;
	        if (show_if == null) show_if = !!/*$leftmode*/ (ctx[4] == 'input' && /*value*/ ctx[3].trim() == '');
	        if (show_if) return 0;
	        return 1;
	    }
	    current_block_type_index = select_block_type(ctx, -1);
	    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    const block = {
	        c: function create() {
	            div = element("div");
	            input = element("input");
	            t0 = space();
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            t1 = space();
	            if (if_block0) if_block0.c();
	            t2 = space();
	            if_block1.c();
	            if_block1_anchor = empty();
	            attr_dev(input, "class", "tofind svelte-a8ib29");
	            attr_dev(input, "placeholder", _("輸入區"));
	            attr_dev(input, "size", 8);
	            attr_dev(input, "id", "tofind");
	            toggle_class(input, "diminput", /*activeidx*/ ctx[2] > -1);
	            add_location(input, file$e, 155, 0, 3727);
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$e, 154, 0, 3704);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, input);
	            /*input_binding*/ ctx[12](input);
	            set_input_value(input, /*value*/ ctx[3]);
	            append_dev(div, t0);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div, null);
	                }
	            }
	            append_dev(div, t1);
	            if (if_block0) if_block0.m(div, null);
	            insert_dev(target, t2, anchor);
	            if_blocks[current_block_type_index].m(target, anchor);
	            insert_dev(target, if_block1_anchor, anchor);
	            current = true;
	            if (!mounted) {
	                dispose = [
	                    listen_dev(input, "focus", /*onfocus*/ ctx[9], false, false, false, false),
	                    listen_dev(input, "blur", /*onblur*/ ctx[8], false, false, false, false),
	                    listen_dev(input, "input", /*onchange*/ ctx[6], false, false, false, false),
	                    listen_dev(input, "input", /*input_input_handler*/ ctx[13])
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*value*/ 8 && input.value !== /*value*/ ctx[3]) {
	                set_input_value(input, /*value*/ ctx[3]);
	            }
	            if (!current || dirty & /*activeidx*/ 4) {
	                toggle_class(input, "diminput", /*activeidx*/ ctx[2] > -1);
	            }
	            if (dirty & /*activeidx, setInput, items*/ 37) {
	                each_value = ensure_array_like_dev(/*items*/ ctx[0]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$5(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$5(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div, t1);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	            if (!/*items*/ ctx[0].length) {
	                if (if_block0) ; else {
	                    if_block0 = create_if_block_1$5(ctx);
	                    if_block0.c();
	                    if_block0.m(div, null);
	                }
	            } else if (if_block0) {
	                if_block0.d(1);
	                if_block0 = null;
	            }
	            let previous_block_index = current_block_type_index;
	            current_block_type_index = select_block_type(ctx, dirty);
	            if (current_block_type_index === previous_block_index) {
	                if_blocks[current_block_type_index].p(ctx, dirty);
	            } else {
	                group_outros();
	                transition_out(if_blocks[previous_block_index], 1, 1, ()=>{
	                    if_blocks[previous_block_index] = null;
	                });
	                check_outros();
	                if_block1 = if_blocks[current_block_type_index];
	                if (!if_block1) {
	                    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	                    if_block1.c();
	                } else {
	                    if_block1.p(ctx, dirty);
	                }
	                transition_in(if_block1, 1);
	                if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block1);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block1);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	                detach_dev(t2);
	                detach_dev(if_block1_anchor);
	            }
	            /*input_binding*/ ctx[12](null);
	            destroy_each(each_blocks, detaching);
	            if (if_block0) if_block0.d();
	            if_blocks[current_block_type_index].d(detaching);
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$e.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$e($$self, $$props, $$invalidate) {
	    let $searchable;
	    let $leftmode;
	    validate_store(searchable, 'searchable');
	    component_subscribe($$self, searchable, ($$value)=>$$invalidate(11, $searchable = $$value));
	    validate_store(leftmode, 'leftmode');
	    component_subscribe($$self, leftmode, ($$value)=>$$invalidate(4, $leftmode = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Searchmain', slots, []);
	    let { ptk } = $$props;
	    let items = [], theinput, activeidx = -1, value = '';
	    const makeSearchable = (t)=>{
	        $$invalidate(0, items.length = 0, items);
	        const chars = splitUTF32Char(t);
	        for(let i = 0; i < chars.length; i++){
	            items.push(chars[i]);
	        }
	        if (items.length >= 2) $$invalidate(2, activeidx = 2);
	        else if (items.length == 1) $$invalidate(2, activeidx = 0);
	        else if (items.length == 0) $$invalidate(2, activeidx = -1);
	    };
	    let tf = '';
	    const setInput = (idx)=>{
	        tf = '';
	        for(let i = 0; i <= idx; i++){
	            tf += items[i] || '';
	        }
	        if (idx == activeidx) {
	            if (value == tf) {
	                $$invalidate(3, value = '');
	            } else {
	                $$invalidate(3, value = tf);
	                $$invalidate(2, activeidx = -1);
	            }
	        } else {
	            $$invalidate(2, activeidx = idx);
	        }
	        tofind.set(tf);
	    };
	    let inputtimer = 0;
	    const onchange = ()=>{
	        $$invalidate(2, activeidx = -1);
	        clearTimeout(inputtimer);
	        inputtimer = setTimeout(()=>{
	            tofind.set(value);
	        }, 250);
	    };
	    const goLine = (line, choff = 0)=>{
	        goPtkLine(ptk, line, choff);
	        leftmode.set('folio');
	        addTofind(value);
	    };
	    /*
	const dosearch=()=>{
	    excerpts.length=0;
	    if (activeidx>-1) {
	        tf=items.slice(0,activeidx+1).join('');
	    } else tf=value;

	    ptk.scanText(tf).then(res=>{
			scopes=res;
	        if (scopes.length) {
	            setScope(1);
	        }
		});
	}

	// add 本卷(本經)
	const setScope=async (idx,range)=>{
	    selected=idx;
	    pagecount=0;
	    const at=Math.floor(idx/2);
	    if (!range) {
	        rangecaption='';
	    }
	    const {lines,chunks,postings}=await listExcerpts(ptk,tf, {range:range||scopes[at].scope});
	    allpostings=postings;
	    if (selected%2==0) {
	        allchunkhits=chunks.map(it=>{
	            return {
	                ck:ptk.getChunk(it[0]),
	                hits:it[1]
	            }
	        })       
	        pagecount=Math.floor(allchunkhits.length /ITEMPERPAGE)+1; 
	        gopage(0)
	    } else {
	        allexcerpts=lines;
	        pagecount=Math.floor(allexcerpts.length /ITEMPERPAGE)+1;
	        gopage(0)
	    }
	}
	const gopage=async idx=>{
	    excerpts.length=0;
	    chunkhits.length=0;
	    selecteditem=-1;
	    if (selected%2==0) {
	        chunkhits=allchunkhits.slice(idx*ITEMPERPAGE,(idx+1)*ITEMPERPAGE);
	        pagecount=Math.floor(allchunkhits.length /ITEMPERPAGE)+1;
	    } else {
	        const toload=[];
	        for (let i=idx*ITEMPERPAGE;i<(idx+1)*ITEMPERPAGE && i<allexcerpts.length;i++) {
	            const line=allexcerpts[i][0];
	            toload.push( line);
	        }
	        await ptk.loadLines(toload);
	        for (let i=0;i<toload.length;i++) {
	            const line=toload[i];
	            const linetext=ptk.getLine(line);
	            [puretext]=parseOfftext(linetext);
	            excerpts.push({puretext,linetext, line});
	        }
	        pagecount=Math.floor(allexcerpts.length /10)+1;
	    }
	    excerpts=excerpts;
	    chunkhits=chunkhits;
	    now=idx;
	}
	*/ /*
	const go=(idx)=>{
	    let line=allexcerpts[idx][0];
	    goLine(line);
	    selecteditem=idx;
	}
	 const gock=(idx)=>{
	     const chit=chunkhits[idx]
	     const line=chit.ck.line;
	     goLine(line);
	     selecteditem=idx;
	 }
	const setChunkScope=(ck)=>{
	    const rangeaddr='bk#'+ck.bk.id+'.ck#'+ck.id;
	    rangecaption=(ck.bk?.caption||'')+'/'+ck.caption;
	    setScope(selected*2+1,rangeaddr);
	}


	*/ const onblur = ()=>{
	        setTimeout(()=>{
	            leftmode.set('folio');
	        }, 200);
	    };
	    const onfocus = ()=>{
	        $$invalidate(2, activeidx = -1);
	        leftmode.set('input');
	    };
	    $$self.$$.on_mount.push(function() {
	        if (ptk === undefined && !('ptk' in $$props || $$self.$$.bound[$$self.$$.props['ptk']])) {
	            console.warn("<Searchmain> was created without expected prop 'ptk'");
	        }
	    });
	    const writable_props = [
	        'ptk'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Searchmain> was created with unknown prop '${key}'`);
	    });
	    function input_binding($$value) {
	        binding_callbacks[$$value ? 'unshift' : 'push'](()=>{
	            theinput = $$value;
	            $$invalidate(1, theinput);
	        });
	    }
	    function input_input_handler() {
	        value = this.value;
	        $$invalidate(3, value);
	    }
	    const click_handler = (idx)=>setInput(idx);
	    $$self.$$set = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(10, ptk = $$props.ptk);
	    };
	    $$self.$capture_state = ()=>({
	            splitUTF32Char,
	            addTofind,
	            leftmode,
	            searchable,
	            tofind,
	            goPtkLine,
	            SearchHelp: Searchhelp,
	            _,
	            Endmarker,
	            Excerpt,
	            ptk,
	            items,
	            theinput,
	            activeidx,
	            value,
	            makeSearchable,
	            tf,
	            setInput,
	            inputtimer,
	            onchange,
	            goLine,
	            onblur,
	            onfocus,
	            $searchable,
	            $leftmode
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(10, ptk = $$props.ptk);
	        if ('items' in $$props) $$invalidate(0, items = $$props.items);
	        if ('theinput' in $$props) $$invalidate(1, theinput = $$props.theinput);
	        if ('activeidx' in $$props) $$invalidate(2, activeidx = $$props.activeidx);
	        if ('value' in $$props) $$invalidate(3, value = $$props.value);
	        if ('tf' in $$props) tf = $$props.tf;
	        if ('inputtimer' in $$props) inputtimer = $$props.inputtimer;
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$searchable*/ 2048) {
	            makeSearchable($searchable);
	        }
	    };
	    return [
	        items,
	        theinput,
	        activeidx,
	        value,
	        $leftmode,
	        setInput,
	        onchange,
	        goLine,
	        onblur,
	        onfocus,
	        ptk,
	        $searchable,
	        input_binding,
	        input_input_handler,
	        click_handler
	    ];
	}
	class Searchmain extends SvelteComponentDev {
	    get ptk() {
	        throw new Error("<Searchmain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set ptk(value) {
	        throw new Error("<Searchmain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$e, create_fragment$e, safe_not_equal, {
	            ptk: 10
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Searchmain",
	            options,
	            id: create_fragment$e.name
	        });
	    }
	}

	const file$d = "src\\externals.svelte";
	function get_each_context$4(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[1] = list[i][0];
	    child_ctx[2] = list[i][1];
	    return child_ctx;
	}
	// (4:0) {#each links as [caption,url]}
	function create_each_block$4(ctx) {
	    let a;
	    let t0_value = /*caption*/ ctx[1] + "";
	    let t0;
	    let a_href_value;
	    let t1_value = " " + "";
	    let t1;
	    const block = {
	        c: function create() {
	            a = element("a");
	            t0 = text(t0_value);
	            t1 = text(t1_value);
	            attr_dev(a, "href", a_href_value = /*url*/ ctx[2]);
	            attr_dev(a, "target", "_new");
	            add_location(a, file$d, 4, 0, 70);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, a, anchor);
	            append_dev(a, t0);
	            insert_dev(target, t1, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*links*/ 1 && t0_value !== (t0_value = /*caption*/ ctx[1] + "")) set_data_dev(t0, t0_value);
	            if (dirty & /*links*/ 1 && a_href_value !== (a_href_value = /*url*/ ctx[2])) {
	                attr_dev(a, "href", a_href_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(a);
	                detach_dev(t1);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$4.name,
	        type: "each",
	        source: "(4:0) {#each links as [caption,url]}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$d(ctx) {
	    let each_1_anchor;
	    let each_value = ensure_array_like_dev(/*links*/ ctx[0]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            each_1_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, each_1_anchor, anchor);
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*links*/ 1) {
	                each_value = ensure_array_like_dev(/*links*/ ctx[0]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$4(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$4(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(each_1_anchor);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$d.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$d($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Externals', slots, []);
	    let { links = [] } = $$props;
	    const writable_props = [
	        'links'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Externals> was created with unknown prop '${key}'`);
	    });
	    $$self.$$set = ($$props)=>{
	        if ('links' in $$props) $$invalidate(0, links = $$props.links);
	    };
	    $$self.$capture_state = ()=>({
	            links
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('links' in $$props) $$invalidate(0, links = $$props.links);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        links
	    ];
	}
	class Externals extends SvelteComponentDev {
	    get links() {
	        throw new Error("<Externals>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set links(value) {
	        throw new Error("<Externals>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$d, create_fragment$d, safe_not_equal, {
	            links: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Externals",
	            options,
	            id: create_fragment$d.name
	        });
	    }
	}

	const file$c = "src\\partext.svelte";
	function get_each_context$3(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[6] = list[i];
	    return child_ctx;
	}
	// (18:0) {#each lines as line}
	function create_each_block$3(ctx) {
	    let div;
	    let t_value = parseOfftext(/*line*/ ctx[6])[0] + "";
	    let t;
	    const block = {
	        c: function create() {
	            div = element("div");
	            t = text(t_value);
	            add_location(div, file$c, 18, 0, 443);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, t);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*lines*/ 2 && t_value !== (t_value = parseOfftext(/*line*/ ctx[6])[0] + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$3.name,
	        type: "each",
	        source: "(18:0) {#each lines as line}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$c(ctx) {
	    let div;
	    let span;
	    let t0;
	    let t1;
	    let t2;
	    let mounted;
	    let dispose;
	    let each_value = ensure_array_like_dev(/*lines*/ ctx[1]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            div = element("div");
	            span = element("span");
	            t0 = text("←");
	            t1 = text(/*caption*/ ctx[0]);
	            t2 = space();
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            add_location(span, file$c, 16, 0, 341);
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$c, 15, 0, 318);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, span);
	            append_dev(span, t0);
	            append_dev(span, t1);
	            append_dev(div, t2);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div, null);
	                }
	            }
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*gofolio*/ ctx[2], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*caption*/ 1) set_data_dev(t1, /*caption*/ ctx[0]);
	            if (dirty & /*lines*/ 2) {
	                each_value = ensure_array_like_dev(/*lines*/ ctx[1]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$3(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$3(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div, null);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_each(each_blocks, detaching);
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$c.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$c($$self, $$props, $$invalidate) {
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Partext', slots, []);
	    let { address } = $$props;
	    let { ptk } = $$props;
	    let { caption } = $$props;
	    let lines = [];
	    const fetchContent = async ()=>{
	        $$invalidate(1, lines = await ptk.fetchAddress(address));
	    };
	    const gofolio = ()=>{
	        loadAddress(ptk);
	    };
	    $$self.$$.on_mount.push(function() {
	        if (address === undefined && !('address' in $$props || $$self.$$.bound[$$self.$$.props['address']])) {
	            console.warn("<Partext> was created without expected prop 'address'");
	        }
	        if (ptk === undefined && !('ptk' in $$props || $$self.$$.bound[$$self.$$.props['ptk']])) {
	            console.warn("<Partext> was created without expected prop 'ptk'");
	        }
	        if (caption === undefined && !('caption' in $$props || $$self.$$.bound[$$self.$$.props['caption']])) {
	            console.warn("<Partext> was created without expected prop 'caption'");
	        }
	    });
	    const writable_props = [
	        'address',
	        'ptk',
	        'caption'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Partext> was created with unknown prop '${key}'`);
	    });
	    $$self.$$set = ($$props)=>{
	        if ('address' in $$props) $$invalidate(3, address = $$props.address);
	        if ('ptk' in $$props) $$invalidate(4, ptk = $$props.ptk);
	        if ('caption' in $$props) $$invalidate(0, caption = $$props.caption);
	    };
	    $$self.$capture_state = ()=>({
	            parseOfftext,
	            loadAddress,
	            address,
	            ptk,
	            caption,
	            lines,
	            fetchContent,
	            gofolio
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('address' in $$props) $$invalidate(3, address = $$props.address);
	        if ('ptk' in $$props) $$invalidate(4, ptk = $$props.ptk);
	        if ('caption' in $$props) $$invalidate(0, caption = $$props.caption);
	        if ('lines' in $$props) $$invalidate(1, lines = $$props.lines);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*address*/ 8) {
	            fetchContent();
	        }
	    };
	    return [
	        caption,
	        lines,
	        gofolio,
	        address,
	        ptk
	    ];
	}
	class Partext extends SvelteComponentDev {
	    get address() {
	        throw new Error("<Partext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set address(value) {
	        throw new Error("<Partext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get ptk() {
	        throw new Error("<Partext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set ptk(value) {
	        throw new Error("<Partext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get caption() {
	        throw new Error("<Partext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set caption(value) {
	        throw new Error("<Partext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$c, create_fragment$c, safe_not_equal, {
	            address: 3,
	            ptk: 4,
	            caption: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Partext",
	            options,
	            id: create_fragment$c.name
	        });
	    }
	}

	const file$b = "src\\textual.svelte";
	function get_each_context$2(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[19] = list[i];
	    child_ctx[21] = i;
	    return child_ctx;
	}
	function get_each_context_1$1(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[19] = list[i];
	    child_ctx[21] = i;
	    return child_ctx;
	}
	// (110:0) {#if hasSanskrit(bookByFolio($activefolioid))}
	function create_if_block_2$2(ctx) {
	    let span;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span = element("span");
	            span.textContent = "原文";
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*thetab*/ ctx[2] == "sourcetext");
	            add_location(span, file$b, 110, 0, 3803);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*click_handler_2*/ ctx[12], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*thetab*/ 4) {
	                toggle_class(span, "selected", /*thetab*/ ctx[2] == "sourcetext");
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_2$2.name,
	        type: "if",
	        source: "(110:0) {#if hasSanskrit(bookByFolio($activefolioid))}",
	        ctx
	    });
	    return block;
	}
	// (113:0) {#if hasTranslation(ptk,bookByFolio($activefolioid))}
	function create_if_block_1$4(ctx) {
	    let span;
	    let t_value = _("別譯", /*$tosim*/ ctx[6]) + "";
	    let t;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*thetab*/ ctx[2] == "translations");
	            add_location(span, file$b, 113, 0, 3997);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*click_handler_3*/ ctx[13], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*$tosim*/ 64 && t_value !== (t_value = _("別譯", /*$tosim*/ ctx[6]) + "")) set_data_dev(t, t_value);
	            if (dirty & /*thetab*/ 4) {
	                toggle_class(span, "selected", /*thetab*/ ctx[2] == "translations");
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$4.name,
	        type: "if",
	        source: "(113:0) {#if hasTranslation(ptk,bookByFolio($activefolioid))}",
	        ctx
	    });
	    return block;
	}
	// (116:0) {#if hasVariorum(bookByFolio($activefolioid))}
	function create_if_block$8(ctx) {
	    let span;
	    let t_value = _("集註", /*$tosim*/ ctx[6]) + "";
	    let t;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*thetab*/ ctx[2] == "variorum");
	            add_location(span, file$b, 116, 0, 4198);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*click_handler_4*/ ctx[14], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*$tosim*/ 64 && t_value !== (t_value = _("集註", /*$tosim*/ ctx[6]) + "")) set_data_dev(t, t_value);
	            if (dirty & /*thetab*/ 4) {
	                toggle_class(span, "selected", /*thetab*/ ctx[2] == "variorum");
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$8.name,
	        type: "if",
	        source: "(116:0) {#if hasVariorum(bookByFolio($activefolioid))}",
	        ctx
	    });
	    return block;
	}
	// (120:0) {#each internals as internal,idx}
	function create_each_block_1$1(ctx) {
	    let span;
	    let t_value = /*internal*/ ctx[19][0] + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler_5() {
	        return /*click_handler_5*/ ctx[15](/*idx*/ ctx[21]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*thetab*/ ctx[2] == "link" + /*idx*/ ctx[21]);
	            add_location(span, file$b, 120, 0, 4383);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler_5, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*internals*/ 8 && t_value !== (t_value = /*internal*/ ctx[19][0] + "")) set_data_dev(t, t_value);
	            if (dirty & /*thetab*/ 4) {
	                toggle_class(span, "selected", /*thetab*/ ctx[2] == "link" + /*idx*/ ctx[21]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block_1$1.name,
	        type: "each",
	        source: "(120:0) {#each internals as internal,idx}",
	        ctx
	    });
	    return block;
	}
	// (125:0) {#key externals}
	function create_key_block$5(ctx) {
	    let externals_1;
	    let current;
	    externals_1 = new Externals({
	        props: {
	            links: /*externals*/ ctx[4]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(externals_1.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(externals_1, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const externals_1_changes = {};
	            if (dirty & /*externals*/ 16) externals_1_changes.links = /*externals*/ ctx[4];
	            externals_1.$set(externals_1_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(externals_1.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(externals_1.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(externals_1, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$5.name,
	        type: "key",
	        source: "(125:0) {#key externals}",
	        ctx
	    });
	    return block;
	}
	// (136:0) {#each internals as internal,idx}
	function create_each_block$2(ctx) {
	    let div;
	    let partext;
	    let current;
	    partext = new Partext({
	        props: {
	            closePopup: /*closePopup*/ ctx[0],
	            caption: /*internal*/ ctx[19][0],
	            ptk: /*ptk*/ ctx[5],
	            address: /*internal*/ ctx[19][1]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div = element("div");
	            create_component(partext.$$.fragment);
	            attr_dev(div, "class", "subtab-content");
	            toggle_class(div, "visible", /*thetab*/ ctx[2] == "link" + /*idx*/ ctx[21]);
	            add_location(div, file$b, 136, 0, 5090);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            mount_component(partext, div, null);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const partext_changes = {};
	            if (dirty & /*closePopup*/ 1) partext_changes.closePopup = /*closePopup*/ ctx[0];
	            if (dirty & /*internals*/ 8) partext_changes.caption = /*internal*/ ctx[19][0];
	            if (dirty & /*ptk*/ 32) partext_changes.ptk = /*ptk*/ ctx[5];
	            if (dirty & /*internals*/ 8) partext_changes.address = /*internal*/ ctx[19][1];
	            partext.$set(partext_changes);
	            if (!current || dirty & /*thetab*/ 4) {
	                toggle_class(div, "visible", /*thetab*/ ctx[2] == "link" + /*idx*/ ctx[21]);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(partext.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(partext.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_component(partext);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$2.name,
	        type: "each",
	        source: "(136:0) {#each internals as internal,idx}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$b(ctx) {
	    let div0;
	    let span0;
	    let t0_value = _("搜尋", /*$tosim*/ ctx[6]) + "";
	    let t0;
	    let t1;
	    let span1;
	    let t3;
	    let show_if_2 = hasSanskrit(bookByFolio(/*$activefolioid*/ ctx[1]));
	    let t4;
	    let show_if_1 = hasTranslation(/*ptk*/ ctx[5], bookByFolio(/*$activefolioid*/ ctx[1]));
	    let t5;
	    let show_if = hasVariorum(bookByFolio(/*$activefolioid*/ ctx[1]));
	    let t6;
	    let t7;
	    let previous_key = /*externals*/ ctx[4];
	    let t8;
	    let div1;
	    let searchmain;
	    let t9;
	    let div2;
	    let chunktext;
	    let t10;
	    let div3;
	    let sourcetext;
	    let t11;
	    let div4;
	    let translations;
	    let t12;
	    let div5;
	    let variorum;
	    let t13;
	    let each1_anchor;
	    let current;
	    let mounted;
	    let dispose;
	    let if_block0 = show_if_2 && create_if_block_2$2(ctx);
	    let if_block1 = show_if_1 && create_if_block_1$4(ctx);
	    let if_block2 = show_if && create_if_block$8(ctx);
	    let each_value_1 = ensure_array_like_dev(/*internals*/ ctx[3]);
	    let each_blocks_1 = [];
	    for(let i = 0; i < each_value_1.length; i += 1){
	        each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	    }
	    let key_block = create_key_block$5(ctx);
	    searchmain = new Searchmain({
	        props: {
	            ptk: /*ptk*/ ctx[5]
	        },
	        $$inline: true
	    });
	    chunktext = new Chunktext({
	        props: {
	            ptk: /*ptk*/ ctx[5]
	        },
	        $$inline: true
	    });
	    sourcetext = new Sourcetext({
	        props: {
	            ptk: /*ptk*/ ctx[5]
	        },
	        $$inline: true
	    });
	    translations = new Translations({
	        props: {
	            closePopup: /*closePopup*/ ctx[0],
	            ptk: /*ptk*/ ctx[5]
	        },
	        $$inline: true
	    });
	    variorum = new Variorum({
	        $$inline: true
	    });
	    let each_value = ensure_array_like_dev(/*internals*/ ctx[3]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	    }
	    const out = (i)=>transition_out(each_blocks[i], 1, 1, ()=>{
	            each_blocks[i] = null;
	        });
	    const block = {
	        c: function create() {
	            div0 = element("div");
	            span0 = element("span");
	            t0 = text(t0_value);
	            t1 = space();
	            span1 = element("span");
	            span1.textContent = "全文";
	            t3 = space();
	            if (if_block0) if_block0.c();
	            t4 = space();
	            if (if_block1) if_block1.c();
	            t5 = space();
	            if (if_block2) if_block2.c();
	            t6 = space();
	            for(let i = 0; i < each_blocks_1.length; i += 1){
	                each_blocks_1[i].c();
	            }
	            t7 = space();
	            key_block.c();
	            t8 = space();
	            div1 = element("div");
	            create_component(searchmain.$$.fragment);
	            t9 = space();
	            div2 = element("div");
	            create_component(chunktext.$$.fragment);
	            t10 = space();
	            div3 = element("div");
	            create_component(sourcetext.$$.fragment);
	            t11 = space();
	            div4 = element("div");
	            create_component(translations.$$.fragment);
	            t12 = space();
	            div5 = element("div");
	            create_component(variorum.$$.fragment);
	            t13 = space();
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            each1_anchor = empty();
	            attr_dev(span0, "aria-hidden", "true");
	            attr_dev(span0, "class", "clickable");
	            toggle_class(span0, "selected", /*thetab*/ ctx[2] == "search");
	            add_location(span0, file$b, 105, 0, 3482);
	            attr_dev(span1, "aria-hidden", "true");
	            attr_dev(span1, "class", "clickable");
	            toggle_class(span1, "selected", /*thetab*/ ctx[2] == "chunktext");
	            add_location(span1, file$b, 107, 0, 3623);
	            attr_dev(div0, "class", "tabs");
	            add_location(div0, file$b, 104, 0, 3459);
	            attr_dev(div1, "class", "subtab-content");
	            toggle_class(div1, "visible", /*thetab*/ ctx[2] == 'search');
	            add_location(div1, file$b, 130, 0, 4596);
	            attr_dev(div2, "class", "subtab-content");
	            toggle_class(div2, "visible", /*thetab*/ ctx[2] == 'chunktext');
	            add_location(div2, file$b, 131, 0, 4684);
	            attr_dev(div3, "class", "subtab-content");
	            toggle_class(div3, "visible", /*thetab*/ ctx[2] == 'sourcetext');
	            add_location(div3, file$b, 132, 0, 4775);
	            attr_dev(div4, "class", "subtab-content");
	            toggle_class(div4, "visible", /*thetab*/ ctx[2] == 'translations');
	            add_location(div4, file$b, 133, 0, 4866);
	            attr_dev(div5, "class", "subtab-content");
	            toggle_class(div5, "visible", /*thetab*/ ctx[2] == 'variorum');
	            add_location(div5, file$b, 134, 0, 4974);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div0, anchor);
	            append_dev(div0, span0);
	            append_dev(span0, t0);
	            append_dev(div0, t1);
	            append_dev(div0, span1);
	            append_dev(div0, t3);
	            if (if_block0) if_block0.m(div0, null);
	            append_dev(div0, t4);
	            if (if_block1) if_block1.m(div0, null);
	            append_dev(div0, t5);
	            if (if_block2) if_block2.m(div0, null);
	            append_dev(div0, t6);
	            for(let i = 0; i < each_blocks_1.length; i += 1){
	                if (each_blocks_1[i]) {
	                    each_blocks_1[i].m(div0, null);
	                }
	            }
	            append_dev(div0, t7);
	            key_block.m(div0, null);
	            insert_dev(target, t8, anchor);
	            insert_dev(target, div1, anchor);
	            mount_component(searchmain, div1, null);
	            insert_dev(target, t9, anchor);
	            insert_dev(target, div2, anchor);
	            mount_component(chunktext, div2, null);
	            insert_dev(target, t10, anchor);
	            insert_dev(target, div3, anchor);
	            mount_component(sourcetext, div3, null);
	            insert_dev(target, t11, anchor);
	            insert_dev(target, div4, anchor);
	            mount_component(translations, div4, null);
	            insert_dev(target, t12, anchor);
	            insert_dev(target, div5, anchor);
	            mount_component(variorum, div5, null);
	            insert_dev(target, t13, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, each1_anchor, anchor);
	            current = true;
	            if (!mounted) {
	                dispose = [
	                    listen_dev(span0, "click", /*click_handler*/ ctx[10], false, false, false, false),
	                    listen_dev(span1, "click", /*click_handler_1*/ ctx[11], false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if ((!current || dirty & /*$tosim*/ 64) && t0_value !== (t0_value = _("搜尋", /*$tosim*/ ctx[6]) + "")) set_data_dev(t0, t0_value);
	            if (!current || dirty & /*thetab*/ 4) {
	                toggle_class(span0, "selected", /*thetab*/ ctx[2] == "search");
	            }
	            if (!current || dirty & /*thetab*/ 4) {
	                toggle_class(span1, "selected", /*thetab*/ ctx[2] == "chunktext");
	            }
	            if (dirty & /*$activefolioid*/ 2) show_if_2 = hasSanskrit(bookByFolio(/*$activefolioid*/ ctx[1]));
	            if (show_if_2) {
	                if (if_block0) {
	                    if_block0.p(ctx, dirty);
	                } else {
	                    if_block0 = create_if_block_2$2(ctx);
	                    if_block0.c();
	                    if_block0.m(div0, t4);
	                }
	            } else if (if_block0) {
	                if_block0.d(1);
	                if_block0 = null;
	            }
	            if (dirty & /*ptk, $activefolioid*/ 34) show_if_1 = hasTranslation(/*ptk*/ ctx[5], bookByFolio(/*$activefolioid*/ ctx[1]));
	            if (show_if_1) {
	                if (if_block1) {
	                    if_block1.p(ctx, dirty);
	                } else {
	                    if_block1 = create_if_block_1$4(ctx);
	                    if_block1.c();
	                    if_block1.m(div0, t5);
	                }
	            } else if (if_block1) {
	                if_block1.d(1);
	                if_block1 = null;
	            }
	            if (dirty & /*$activefolioid*/ 2) show_if = hasVariorum(bookByFolio(/*$activefolioid*/ ctx[1]));
	            if (show_if) {
	                if (if_block2) {
	                    if_block2.p(ctx, dirty);
	                } else {
	                    if_block2 = create_if_block$8(ctx);
	                    if_block2.c();
	                    if_block2.m(div0, t6);
	                }
	            } else if (if_block2) {
	                if_block2.d(1);
	                if_block2 = null;
	            }
	            if (dirty & /*thetab, selecttab, internals*/ 140) {
	                each_value_1 = ensure_array_like_dev(/*internals*/ ctx[3]);
	                let i;
	                for(i = 0; i < each_value_1.length; i += 1){
	                    const child_ctx = get_each_context_1$1(ctx, each_value_1, i);
	                    if (each_blocks_1[i]) {
	                        each_blocks_1[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks_1[i] = create_each_block_1$1(child_ctx);
	                        each_blocks_1[i].c();
	                        each_blocks_1[i].m(div0, t7);
	                    }
	                }
	                for(; i < each_blocks_1.length; i += 1){
	                    each_blocks_1[i].d(1);
	                }
	                each_blocks_1.length = each_value_1.length;
	            }
	            if (dirty & /*externals*/ 16 && safe_not_equal(previous_key, previous_key = /*externals*/ ctx[4])) {
	                group_outros();
	                transition_out(key_block, 1, 1, noop);
	                check_outros();
	                key_block = create_key_block$5(ctx);
	                key_block.c();
	                transition_in(key_block, 1);
	                key_block.m(div0, null);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	            const searchmain_changes = {};
	            if (dirty & /*ptk*/ 32) searchmain_changes.ptk = /*ptk*/ ctx[5];
	            searchmain.$set(searchmain_changes);
	            if (!current || dirty & /*thetab*/ 4) {
	                toggle_class(div1, "visible", /*thetab*/ ctx[2] == 'search');
	            }
	            const chunktext_changes = {};
	            if (dirty & /*ptk*/ 32) chunktext_changes.ptk = /*ptk*/ ctx[5];
	            chunktext.$set(chunktext_changes);
	            if (!current || dirty & /*thetab*/ 4) {
	                toggle_class(div2, "visible", /*thetab*/ ctx[2] == 'chunktext');
	            }
	            const sourcetext_changes = {};
	            if (dirty & /*ptk*/ 32) sourcetext_changes.ptk = /*ptk*/ ctx[5];
	            sourcetext.$set(sourcetext_changes);
	            if (!current || dirty & /*thetab*/ 4) {
	                toggle_class(div3, "visible", /*thetab*/ ctx[2] == 'sourcetext');
	            }
	            const translations_changes = {};
	            if (dirty & /*closePopup*/ 1) translations_changes.closePopup = /*closePopup*/ ctx[0];
	            if (dirty & /*ptk*/ 32) translations_changes.ptk = /*ptk*/ ctx[5];
	            translations.$set(translations_changes);
	            if (!current || dirty & /*thetab*/ 4) {
	                toggle_class(div4, "visible", /*thetab*/ ctx[2] == 'translations');
	            }
	            if (!current || dirty & /*thetab*/ 4) {
	                toggle_class(div5, "visible", /*thetab*/ ctx[2] == 'variorum');
	            }
	            if (dirty & /*thetab, closePopup, internals, ptk*/ 45) {
	                each_value = ensure_array_like_dev(/*internals*/ ctx[3]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$2(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                        transition_in(each_blocks[i], 1);
	                    } else {
	                        each_blocks[i] = create_each_block$2(child_ctx);
	                        each_blocks[i].c();
	                        transition_in(each_blocks[i], 1);
	                        each_blocks[i].m(each1_anchor.parentNode, each1_anchor);
	                    }
	                }
	                group_outros();
	                for(i = each_value.length; i < each_blocks.length; i += 1){
	                    out(i);
	                }
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(key_block);
	            transition_in(searchmain.$$.fragment, local);
	            transition_in(chunktext.$$.fragment, local);
	            transition_in(sourcetext.$$.fragment, local);
	            transition_in(translations.$$.fragment, local);
	            transition_in(variorum.$$.fragment, local);
	            for(let i = 0; i < each_value.length; i += 1){
	                transition_in(each_blocks[i]);
	            }
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(key_block);
	            transition_out(searchmain.$$.fragment, local);
	            transition_out(chunktext.$$.fragment, local);
	            transition_out(sourcetext.$$.fragment, local);
	            transition_out(translations.$$.fragment, local);
	            transition_out(variorum.$$.fragment, local);
	            each_blocks = each_blocks.filter(Boolean);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                transition_out(each_blocks[i]);
	            }
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div0);
	                detach_dev(t8);
	                detach_dev(div1);
	                detach_dev(t9);
	                detach_dev(div2);
	                detach_dev(t10);
	                detach_dev(div3);
	                detach_dev(t11);
	                detach_dev(div4);
	                detach_dev(t12);
	                detach_dev(div5);
	                detach_dev(t13);
	                detach_dev(each1_anchor);
	            }
	            if (if_block0) if_block0.d();
	            if (if_block1) if_block1.d();
	            if (if_block2) if_block2.d();
	            destroy_each(each_blocks_1, detaching);
	            key_block.d(detaching);
	            destroy_component(searchmain);
	            destroy_component(chunktext);
	            destroy_component(sourcetext);
	            destroy_component(translations);
	            destroy_component(variorum);
	            destroy_each(each_blocks, detaching);
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$b.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$b($$self, $$props, $$invalidate) {
	    let ptk;
	    let externals;
	    let internals;
	    let $activepb;
	    let $activefolioid;
	    let $tapmark;
	    let $foliotext;
	    let $activePtk;
	    let $tosim;
	    validate_store(activepb, 'activepb');
	    component_subscribe($$self, activepb, ($$value)=>$$invalidate(8, $activepb = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(1, $activefolioid = $$value));
	    validate_store(tapmark, 'tapmark');
	    component_subscribe($$self, tapmark, ($$value)=>$$invalidate(16, $tapmark = $$value));
	    validate_store(foliotext, 'foliotext');
	    component_subscribe($$self, foliotext, ($$value)=>$$invalidate(17, $foliotext = $$value));
	    validate_store(activePtk, 'activePtk');
	    component_subscribe($$self, activePtk, ($$value)=>$$invalidate(9, $activePtk = $$value));
	    validate_store(tosim, 'tosim');
	    component_subscribe($$self, tosim, ($$value)=>$$invalidate(6, $tosim = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Textual', slots, []);
	    let { closePopup } = $$props;
	    const getLinks = (folioid)=>{
	        //todo 更精準地定位 經 ，目前是以頁首，有時是上一經
	        const dcptk = usePtk("dc");
	        const [from, to] = ptk.rangeOfAddress('folio#' + folioid + '.pb#' + $activepb);
	        const externals = [], internals = [];
	        const agmsjuan = folioid.match(/agms(\d+)$/);
	        const ft = $foliotext;
	        if (!ft) return [
	            [],
	            []
	        ];
	        let col, key, caption, url;
	        if (agmsjuan) {
	            const at = ptk.nearestTag(to + 1, 'n');
	            const n = ptk.defines.n;
	            key = parseInt(n.fields.id.values[at]);
	            caption = _('雜') + key + _('導讀');
	            url = 'https://buddhaspace.org/agama/' + agmsjuan[1] + '.html#' + toChineseNumber(key);
	            externals.push([
	                caption,
	                url
	            ]);
	            col = dcptk.columns['par_agms'];
	        }
	        const agmssjuan = folioid.match(/agmss(\d+)$/);
	        if (agmssjuan) {
	            const at = ptk.nearestTag(to + 1, 'n');
	            const n = ptk.defines.n;
	            key = parseInt(n.fields.id.values[at]);
	            col = dcptk.columns['par_agmss'];
	        }
	        const agmdjuan = folioid.match(/agmd(\d+)$/);
	        if (agmdjuan) {
	            const cl = ft.fromFolioPos($tapmark);
	            if (cl && cl.ckid) {
	                caption = '長' + parseInt(cl.ckid) + _('導讀');
	                url = 'https://buddhaspace.org/agama3/' + parseInt(cl.ckid) + '.html';
	                key = cl.ckid;
	                externals.push([
	                    caption,
	                    url
	                ]);
	            }
	            col = dcptk.columns['par_agmd'];
	        }
	        const agmmjuan = folioid.match(/agmm(\d+)$/);
	        if (agmmjuan) {
	            const cl = ft.fromFolioPos($tapmark);
	            if (cl && cl.ckid) {
	                key = cl.ckid;
	                caption = '中' + parseInt(cl.ckid) + _('導讀');
	                url = 'https://buddhaspace.org/agama2/sub/' + cl.ckid + '.html';
	                externals.push([
	                    caption,
	                    url
	                ]);
	            }
	            col = dcptk.columns['par_agmm'];
	        }
	        const agmujuan = folioid.match(/agmu(\d+)$/);
	        if (agmujuan) {
	            col = dcptk.columns['par_agmu'];
	            const cl = ft.fromFolioPos($tapmark);
	            if (cl && cl.ckid) {
	                key = cl.ckid;
	            }
	        }
	        if (col && key) {
	            const at2 = col.keys.indexOf(key.toString());
	            const pars = (col.parallels[at2] || '').split(',');
	            for(let i = 0; i < pars.length; i++){
	                const par = pars[i];
	                if (par.match(/ak#[dmsa]n/)) {
	                    const host = location.host.replace('5002', '5080');
	                    const url = location.protocol + '//' + host + location.pathname.replace('ylz', 'sz') + '#' + par;
	                    externals.push([
	                        paliHumanAddress(par),
	                        url
	                    ]);
	                } else {
	                    internals.push([
	                        humanAddress(par),
	                        par
	                    ]);
	                }
	            }
	        }
	        if (thetab.startsWith('link')) {
	            $$invalidate(2, thetab = 'chunktext');
	        }
	        return [
	            externals,
	            internals
	        ];
	    };
	    const selecttab = (tabname)=>{
	        leftmode.set('folio');
	        $$invalidate(2, thetab = tabname);
	    };
	    let thetab = 'search';
	    $$self.$$.on_mount.push(function() {
	        if (closePopup === undefined && !('closePopup' in $$props || $$self.$$.bound[$$self.$$.props['closePopup']])) {
	            console.warn("<Textual> was created without expected prop 'closePopup'");
	        }
	    });
	    const writable_props = [
	        'closePopup'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Textual> was created with unknown prop '${key}'`);
	    });
	    const click_handler = ()=>selecttab("search");
	    const click_handler_1 = ()=>selecttab("chunktext");
	    const click_handler_2 = ()=>selecttab("sourcetext");
	    const click_handler_3 = ()=>selecttab("translations");
	    const click_handler_4 = ()=>selecttab("variorum");
	    const click_handler_5 = (idx)=>selecttab("link" + idx);
	    $$self.$$set = ($$props)=>{
	        if ('closePopup' in $$props) $$invalidate(0, closePopup = $$props.closePopup);
	    };
	    $$self.$capture_state = ()=>({
	            Translations,
	            ChunkText: Chunktext,
	            SourceText: Sourcetext,
	            Variorum,
	            SearchMain: Searchmain,
	            Externals,
	            ParText: Partext,
	            _,
	            humanAddress,
	            paliHumanAddress,
	            usePtk,
	            toChineseNumber,
	            tosim,
	            activefolioid,
	            activepb,
	            leftmode,
	            activePtk,
	            hasVariorum,
	            hasTranslation,
	            hasSanskrit,
	            bookByFolio,
	            tapmark,
	            foliotext,
	            closePopup,
	            getLinks,
	            selecttab,
	            thetab,
	            internals,
	            externals,
	            ptk,
	            $activepb,
	            $activefolioid,
	            $tapmark,
	            $foliotext,
	            $activePtk,
	            $tosim
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('closePopup' in $$props) $$invalidate(0, closePopup = $$props.closePopup);
	        if ('thetab' in $$props) $$invalidate(2, thetab = $$props.thetab);
	        if ('internals' in $$props) $$invalidate(3, internals = $$props.internals);
	        if ('externals' in $$props) $$invalidate(4, externals = $$props.externals);
	        if ('ptk' in $$props) $$invalidate(5, ptk = $$props.ptk);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$activePtk*/ 512) {
	            $$invalidate(5, ptk = usePtk($activePtk));
	        }
	        if ($$self.$$.dirty & /*$activefolioid, $activepb*/ 258) {
	            $$invalidate(4, [externals, internals] = getLinks($activefolioid), externals, ($$invalidate(3, internals), $$invalidate(1, $activefolioid), $$invalidate(8, $activepb)));
	        }
	    };
	    return [
	        closePopup,
	        $activefolioid,
	        thetab,
	        internals,
	        externals,
	        ptk,
	        $tosim,
	        selecttab,
	        $activepb,
	        $activePtk,
	        click_handler,
	        click_handler_1,
	        click_handler_2,
	        click_handler_3,
	        click_handler_4,
	        click_handler_5
	    ];
	}
	class Textual extends SvelteComponentDev {
	    get closePopup() {
	        throw new Error("<Textual>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set closePopup(value) {
	        throw new Error("<Textual>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$b, create_fragment$b, safe_not_equal, {
	            closePopup: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Textual",
	            options,
	            id: create_fragment$b.name
	        });
	    }
	}

	const file$a = "src\\sharing.svelte";
	function create_fragment$a(ctx) {
	    let div;
	    let t0_value = _(/*msg*/ ctx[3]) + "";
	    let t0;
	    let br;
	    let t1_value = _(/*linetext*/ ctx[0]) + "";
	    let t1;
	    let t2;
	    let t3_value = _(/*title*/ ctx[1]) + "";
	    let t3;
	    let t4;
	    let t5_value = _(/*caption*/ ctx[2]) + "";
	    let t5;
	    let t6;
	    let button0;
	    let t8;
	    let button1;
	    let t10;
	    let button2;
	    let t12;
	    let button3;
	    let t14;
	    let span;
	    let t15;
	    let t16_value = shareAddress() + "";
	    let t16;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            div = element("div");
	            t0 = text(t0_value);
	            br = element("br");
	            t1 = text(t1_value);
	            t2 = text("《");
	            t3 = text(t3_value);
	            t4 = text("》");
	            t5 = text(t5_value);
	            t6 = space();
	            button0 = element("button");
	            button0.textContent = `${_("複製連結")}`;
	            t8 = space();
	            button1 = element("button");
	            button1.textContent = `${_("複製經文及連結")}`;
	            t10 = space();
	            button2 = element("button");
	            button2.textContent = `${_("HTML格式連結")}`;
	            t12 = space();
	            button3 = element("button");
	            button3.textContent = `${_("MarkDown格式連結")}`;
	            t14 = space();
	            span = element("span");
	            t15 = space();
	            t16 = text(t16_value);
	            add_location(br, file$a, 43, 30, 1382);
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$a, 43, 0, 1352);
	            attr_dev(button0, "class", "svelte-1o0xp9s");
	            add_location(button0, file$a, 44, 0, 1431);
	            attr_dev(button1, "class", "svelte-1o0xp9s");
	            add_location(button1, file$a, 45, 0, 1480);
	            attr_dev(button2, "class", "svelte-1o0xp9s");
	            add_location(button2, file$a, 46, 0, 1535);
	            attr_dev(button3, "class", "svelte-1o0xp9s");
	            add_location(button3, file$a, 47, 0, 1588);
	            add_location(span, file$a, 48, 0, 1649);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, t0);
	            append_dev(div, br);
	            append_dev(div, t1);
	            append_dev(div, t2);
	            append_dev(div, t3);
	            append_dev(div, t4);
	            append_dev(div, t5);
	            insert_dev(target, t6, anchor);
	            insert_dev(target, button0, anchor);
	            insert_dev(target, t8, anchor);
	            insert_dev(target, button1, anchor);
	            insert_dev(target, t10, anchor);
	            insert_dev(target, button2, anchor);
	            insert_dev(target, t12, anchor);
	            insert_dev(target, button3, anchor);
	            insert_dev(target, t14, anchor);
	            insert_dev(target, span, anchor);
	            span.innerHTML = /*qrcode*/ ctx[4];
	            insert_dev(target, t15, anchor);
	            insert_dev(target, t16, anchor);
	            if (!mounted) {
	                dispose = [
	                    listen_dev(button0, "click", /*copylink*/ ctx[6], false, false, false, false),
	                    listen_dev(button1, "click", /*excerptcopy*/ ctx[5], false, false, false, false),
	                    listen_dev(button2, "click", /*htmlcopy*/ ctx[8], false, false, false, false),
	                    listen_dev(button3, "click", /*markdowncopy*/ ctx[7], false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*msg*/ 8 && t0_value !== (t0_value = _(/*msg*/ ctx[3]) + "")) set_data_dev(t0, t0_value);
	            if (dirty & /*linetext*/ 1 && t1_value !== (t1_value = _(/*linetext*/ ctx[0]) + "")) set_data_dev(t1, t1_value);
	            if (dirty & /*title*/ 2 && t3_value !== (t3_value = _(/*title*/ ctx[1]) + "")) set_data_dev(t3, t3_value);
	            if (dirty & /*caption*/ 4 && t5_value !== (t5_value = _(/*caption*/ ctx[2]) + "")) set_data_dev(t5, t5_value);
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	                detach_dev(t6);
	                detach_dev(button0);
	                detach_dev(t8);
	                detach_dev(button1);
	                detach_dev(t10);
	                detach_dev(button2);
	                detach_dev(t12);
	                detach_dev(button3);
	                detach_dev(t14);
	                detach_dev(span);
	                detach_dev(t15);
	                detach_dev(t16);
	            }
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$a.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	const copylinkmsg = '已複製連結到剪貼薄';
	function instance$a($$self, $$props, $$invalidate) {
	    let $tapmark;
	    let $foliotext;
	    validate_store(tapmark, 'tapmark');
	    component_subscribe($$self, tapmark, ($$value)=>$$invalidate(9, $tapmark = $$value));
	    validate_store(foliotext, 'foliotext');
	    component_subscribe($$self, foliotext, ($$value)=>$$invalidate(10, $foliotext = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Sharing', slots, []);
	    let qrcode = '', linetext, title = '', caption = '', msg = copylinkmsg;
	    onMount(async ()=>{
	        const cl = $foliotext.fromFolioPos($tapmark);
	        $$invalidate(0, linetext = parseOfftext((cl === null || cl === void 0 ? void 0 : cl.linetext) || '')[0]);
	        $$invalidate(1, title = (cl === null || cl === void 0 ? void 0 : cl.ck.bk.heading) || '');
	        $$invalidate(2, caption = cl === null || cl === void 0 ? void 0 : cl.ck.caption);
	    }); // qrcode=await QRCode.toString( shareAddress(),{type:'svg'});
	    let timer;
	    const showmessage = (_msg)=>{
	        $$invalidate(3, msg = _msg);
	        clearTimeout(timer);
	    };
	    const excerptcopy = async ()=>{
	        const text = shareAddress() + '\t「' + linetext + '」《' + title + '》' + caption;
	        await navigator.clipboard.writeText(text);
	        showmessage('已複製經文及連結到剪貼薄');
	    };
	    const copylink = async ()=>{
	        navigator.clipboard.writeText(shareAddress());
	        showmessage(copylinkmsg);
	    };
	    const markdowncopy = async ()=>{
	        const text = '[' + linetext + '《' + title + '》' + caption + '](' + shareAddress() + ')';
	        await navigator.clipboard.writeText(text);
	        showmessage('已複製Markdown格式到剪貼薄');
	    };
	    const htmlcopy = async ()=>{
	        const text = linetext + '<a href="' + shareAddress() + '">《' + title + '》' + caption + '</a>';
	        await navigator.clipboard.writeText(text);
	        showmessage('已複製HTML格式到剪貼薄');
	    };
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sharing> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            parseOfftext,
	            shareAddress,
	            foliotext,
	            tapmark,
	            tosim,
	            _,
	            onMount,
	            copylinkmsg,
	            qrcode,
	            linetext,
	            title,
	            caption,
	            msg,
	            timer,
	            showmessage,
	            excerptcopy,
	            copylink,
	            markdowncopy,
	            htmlcopy,
	            $tapmark,
	            $foliotext
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('qrcode' in $$props) $$invalidate(4, qrcode = $$props.qrcode);
	        if ('linetext' in $$props) $$invalidate(0, linetext = $$props.linetext);
	        if ('title' in $$props) $$invalidate(1, title = $$props.title);
	        if ('caption' in $$props) $$invalidate(2, caption = $$props.caption);
	        if ('msg' in $$props) $$invalidate(3, msg = $$props.msg);
	        if ('timer' in $$props) timer = $$props.timer;
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        linetext,
	        title,
	        caption,
	        msg,
	        qrcode,
	        excerptcopy,
	        copylink,
	        markdowncopy,
	        htmlcopy
	    ];
	}
	class Sharing extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$a, create_fragment$a, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Sharing",
	            options,
	            id: create_fragment$a.name
	        });
	    }
	}

	const file$9 = "src\\juan.svelte";
	// (48:0) {:else}
	function create_else_block$3(ctx) {
	    let slider;
	    let updating_value;
	    let current;
	    function slider_value_binding(value) {
	        /*slider_value_binding*/ ctx[11](value);
	    }
	    let slider_props = {
	        max: /*juans*/ ctx[0].length,
	        min: 1,
	        $$slots: {
	            caption: [
	                create_caption_slot$1
	            ]
	        },
	        $$scope: {
	            ctx
	        }
	    };
	    if (/*juan*/ ctx[1] !== void 0) {
	        slider_props.value = /*juan*/ ctx[1];
	    }
	    slider = new Rangeslider({
	        props: slider_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(slider, 'value', slider_value_binding));
	    slider.$on("input", debounce(/*gotojuan*/ ctx[4], 300));
	    const block = {
	        c: function create() {
	            create_component(slider.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(slider, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const slider_changes = {};
	            if (dirty & /*juans*/ 1) slider_changes.max = /*juans*/ ctx[0].length;
	            if (dirty & /*$$scope, juans, juan*/ 262147) {
	                slider_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            if (!updating_value && dirty & /*juan*/ 2) {
	                updating_value = true;
	                slider_changes.value = /*juan*/ ctx[1];
	                add_flush_callback(()=>updating_value = false);
	            }
	            slider.$set(slider_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(slider.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(slider.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(slider, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$3.name,
	        type: "else",
	        source: "(48:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (44:26) 
	function create_if_block_1$3(ctx) {
	    let pager;
	    let current;
	    pager = new Pager({
	        props: {
	            pages: /*juans*/ ctx[0],
	            caption: "卷",
	            now: /*currentjuan*/ ctx[2] - 1,
	            onselect: /*func*/ ctx[10],
	            $$slots: {
	                default: [
	                    create_default_slot,
	                    ({ active, caption, id })=>({
	                            15: active,
	                            16: caption,
	                            17: id
	                        }),
	                    ({ active, caption, id })=>(active ? 32768 : 0) | (caption ? 65536 : 0) | (id ? 131072 : 0)
	                ]
	            },
	            $$scope: {
	                ctx
	            }
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(pager.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(pager, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const pager_changes = {};
	            if (dirty & /*juans*/ 1) pager_changes.pages = /*juans*/ ctx[0];
	            if (dirty & /*$$scope, active, id, caption*/ 491520) {
	                pager_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            pager.$set(pager_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(pager.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(pager.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(pager, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$3.name,
	        type: "if",
	        source: "(44:26) ",
	        ctx
	    });
	    return block;
	}
	// (42:0) {#if juans.length==0}
	function create_if_block$7(ctx) {
	    let span;
	    const block = {
	        c: function create() {
	            span = element("span");
	            add_location(span, file$9, 42, 0, 1250);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	        },
	        p: noop,
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$7.name,
	        type: "if",
	        source: "(42:0) {#if juans.length==0}",
	        ctx
	    });
	    return block;
	}
	// (50:4) 
	function create_caption_slot$1(ctx) {
	    let span;
	    let t0;
	    let t1_value = /*juan*/ (ctx[1][0] || 1) + "";
	    let t1;
	    let t2;
	    let t3_value = /*juans*/ ctx[0].length + "";
	    let t3;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t0 = text("卷");
	            t1 = text(t1_value);
	            t2 = text("/");
	            t3 = text(t3_value);
	            attr_dev(span, "slot", "caption");
	            set_style(span, "float", "right");
	            add_location(span, file$9, 49, 4, 1637);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t0);
	            append_dev(span, t1);
	            append_dev(span, t2);
	            append_dev(span, t3);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*juan*/ 2 && t1_value !== (t1_value = /*juan*/ (ctx[1][0] || 1) + "")) set_data_dev(t1, t1_value);
	            if (dirty & /*juans*/ 1 && t3_value !== (t3_value = /*juans*/ ctx[0].length + "")) set_data_dev(t3, t3_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_caption_slot$1.name,
	        type: "slot",
	        source: "(50:4) ",
	        ctx
	    });
	    return block;
	}
	// (45:0) <Pager pages={juans} caption="卷" now={currentjuan-1} let:active let:caption  let:id  onselect={idx=>gojuan(idx+1)}>
	function create_default_slot(ctx) {
	    let span;
	    let t_value = /*caption*/ ctx[16] + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[9](/*id*/ ctx[17]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*active*/ ctx[15]);
	            add_location(span, file$9, 45, 4, 1411);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*caption*/ 65536 && t_value !== (t_value = /*caption*/ ctx[16] + "")) set_data_dev(t, t_value);
	            if (dirty & /*active*/ 32768) {
	                toggle_class(span, "selected", /*active*/ ctx[15]);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_default_slot.name,
	        type: "slot",
	        source: "(45:0) <Pager pages={juans} caption=\\\"卷\\\" now={currentjuan-1} let:active let:caption  let:id  onselect={idx=>gojuan(idx+1)}>",
	        ctx
	    });
	    return block;
	}
	function create_fragment$9(ctx) {
	    let current_block_type_index;
	    let if_block;
	    let if_block_anchor;
	    let current;
	    const if_block_creators = [
	        create_if_block$7,
	        create_if_block_1$3,
	        create_else_block$3
	    ];
	    const if_blocks = [];
	    function select_block_type(ctx, dirty) {
	        if (/*juans*/ ctx[0].length == 0) return 0;
	        if (/*juans*/ ctx[0].length < 10) return 1;
	        return 2;
	    }
	    current_block_type_index = select_block_type(ctx);
	    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    const block = {
	        c: function create() {
	            if_block.c();
	            if_block_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            if_blocks[current_block_type_index].m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            let previous_block_index = current_block_type_index;
	            current_block_type_index = select_block_type(ctx);
	            if (current_block_type_index === previous_block_index) {
	                if_blocks[current_block_type_index].p(ctx, dirty);
	            } else {
	                group_outros();
	                transition_out(if_blocks[previous_block_index], 1, 1, ()=>{
	                    if_blocks[previous_block_index] = null;
	                });
	                check_outros();
	                if_block = if_blocks[current_block_type_index];
	                if (!if_block) {
	                    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	                    if_block.c();
	                } else {
	                    if_block.p(ctx, dirty);
	                }
	                transition_in(if_block, 1);
	                if_block.m(if_block_anchor.parentNode, if_block_anchor);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if_blocks[current_block_type_index].d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$9.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$9($$self, $$props, $$invalidate) {
	    let ptk;
	    let $loadingfolio;
	    let $activefolioid;
	    let $activePtk;
	    validate_store(loadingfolio, 'loadingfolio');
	    component_subscribe($$self, loadingfolio, ($$value)=>$$invalidate(6, $loadingfolio = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(7, $activefolioid = $$value));
	    validate_store(activePtk, 'activePtk');
	    component_subscribe($$self, activePtk, ($$value)=>$$invalidate(8, $activePtk = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Juan', slots, []);
	    let { closePopup } = $$props;
	    let juans = []; //find out all juan
	    const m = $activefolioid.match(/([a-z_]+)(\d+$)/);
	    let currentjuan = m ? parseInt(m[2]) : 1;
	    let juan = [
	        1,
	        0
	    ];
	    const gojuan = (juan)=>{
	        const fid = $activefolioid;
	        const newid = fid.replace(/\d+$/, juan);
	        if (newid == fid) return;
	        loadFolio(newid, function() {
	            activepb.set('1');
	            tapmark.set([
	                '1',
	                0,
	                0
	            ]);
	            updateUrl(tapAddress());
	            closePopup();
	            loadJuan(newid);
	        });
	    };
	    const loadJuan = (folioid, loading)=>{
	        if (!ptk || loading) return [];
	        const m = folioid.match(/([a-z_]+)(\d+$)/);
	        if (!m) return [];
	        $$invalidate(1, juan[0] = currentjuan, juan);
	        const juans = allJuan(ptk, folioid).map((it, idx)=>{
	            return {
	                caption: it,
	                idx: parseInt(idx),
	                id: (idx + 1).toString()
	            };
	        });
	        return juans;
	    };
	    const gotojuan = (e)=>{
	        const j = (e.detail[0] || 1).toString();
	        gojuan(j);
	    };
	    $$self.$$.on_mount.push(function() {
	        if (closePopup === undefined && !('closePopup' in $$props || $$self.$$.bound[$$self.$$.props['closePopup']])) {
	            console.warn("<Juan> was created without expected prop 'closePopup'");
	        }
	    });
	    const writable_props = [
	        'closePopup'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Juan> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (id)=>gojuan(id);
	    const func = (idx)=>gojuan(idx + 1);
	    function slider_value_binding(value) {
	        juan = value;
	        $$invalidate(1, juan);
	    }
	    $$self.$$set = ($$props)=>{
	        if ('closePopup' in $$props) $$invalidate(5, closePopup = $$props.closePopup);
	    };
	    $$self.$capture_state = ()=>({
	            activePtk,
	            activefolioid,
	            loadingfolio,
	            tapmark,
	            activepb,
	            tapAddress,
	            Pager,
	            loadFolio,
	            allJuan,
	            updateUrl,
	            debounce,
	            usePtk,
	            Slider: Rangeslider,
	            closePopup,
	            juans,
	            m,
	            currentjuan,
	            juan,
	            gojuan,
	            loadJuan,
	            gotojuan,
	            ptk,
	            $loadingfolio,
	            $activefolioid,
	            $activePtk
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('closePopup' in $$props) $$invalidate(5, closePopup = $$props.closePopup);
	        if ('juans' in $$props) $$invalidate(0, juans = $$props.juans);
	        if ('currentjuan' in $$props) $$invalidate(2, currentjuan = $$props.currentjuan);
	        if ('juan' in $$props) $$invalidate(1, juan = $$props.juan);
	        if ('ptk' in $$props) ptk = $$props.ptk;
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$activePtk*/ 256) {
	            ptk = usePtk($activePtk);
	        }
	        if ($$self.$$.dirty & /*$activefolioid, $loadingfolio*/ 192) {
	            $$invalidate(0, juans = loadJuan($activefolioid, $loadingfolio));
	        }
	    };
	    return [
	        juans,
	        juan,
	        currentjuan,
	        gojuan,
	        gotojuan,
	        closePopup,
	        $loadingfolio,
	        $activefolioid,
	        $activePtk,
	        click_handler,
	        func,
	        slider_value_binding
	    ];
	}
	class Juan extends SvelteComponentDev {
	    get closePopup() {
	        throw new Error("<Juan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set closePopup(value) {
	        throw new Error("<Juan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$9, create_fragment$9, safe_not_equal, {
	            closePopup: 5
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Juan",
	            options,
	            id: create_fragment$9.name
	        });
	    }
	}

	const file$8 = "src\\toc.svelte";
	function get_each_context$1(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[17] = list[i];
	    return child_ctx;
	}
	// (59:0) {:else}
	function create_else_block$2(ctx) {
	    let t;
	    const block = {
	        c: function create() {
	            t = text("載入中");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: noop,
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$2.name,
	        type: "else",
	        source: "(59:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (46:0) {#if !$loadingfolio}
	function create_if_block$6(ctx) {
	    let juan;
	    let t0;
	    let slider;
	    let updating_value;
	    let t1;
	    let div;
	    let previous_key = /*$tosim*/ ctx[7];
	    let t2;
	    let endmarker;
	    let current;
	    juan = new Juan({
	        props: {
	            closePopup: /*closePopup*/ ctx[0]
	        },
	        $$inline: true
	    });
	    function slider_value_binding(value) {
	        /*slider_value_binding*/ ctx[13](value);
	    }
	    let slider_props = {
	        max: /*$maxfolio*/ ctx[6],
	        min: 1,
	        $$slots: {
	            caption: [
	                create_caption_slot
	            ]
	        },
	        $$scope: {
	            ctx
	        }
	    };
	    if (/*folio*/ ctx[5] !== void 0) {
	        slider_props.value = /*folio*/ ctx[5];
	    }
	    slider = new Rangeslider({
	        props: slider_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(slider, 'value', slider_value_binding));
	    slider.$on("input", debounce(/*setFolio*/ ctx[8], 800));
	    let key_block = create_key_block$4(ctx);
	    endmarker = new Endmarker({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(juan.$$.fragment);
	            t0 = space();
	            create_component(slider.$$.fragment);
	            t1 = space();
	            div = element("div");
	            key_block.c();
	            t2 = space();
	            create_component(endmarker.$$.fragment);
	            attr_dev(div, "class", "toc svelte-1ubc3jc");
	            add_location(div, file$8, 49, 0, 1507);
	        },
	        m: function mount(target, anchor) {
	            mount_component(juan, target, anchor);
	            insert_dev(target, t0, anchor);
	            mount_component(slider, target, anchor);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, div, anchor);
	            key_block.m(div, null);
	            append_dev(div, t2);
	            mount_component(endmarker, div, null);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const juan_changes = {};
	            if (dirty & /*closePopup*/ 1) juan_changes.closePopup = /*closePopup*/ ctx[0];
	            juan.$set(juan_changes);
	            const slider_changes = {};
	            if (dirty & /*$maxfolio*/ 64) slider_changes.max = /*$maxfolio*/ ctx[6];
	            if (dirty & /*$$scope, $maxfolio, folio*/ 1048672) {
	                slider_changes.$$scope = {
	                    dirty,
	                    ctx
	                };
	            }
	            if (!updating_value && dirty & /*folio*/ 32) {
	                updating_value = true;
	                slider_changes.value = /*folio*/ ctx[5];
	                add_flush_callback(()=>updating_value = false);
	            }
	            slider.$set(slider_changes);
	            if (dirty & /*$tosim*/ 128 && safe_not_equal(previous_key, previous_key = /*$tosim*/ ctx[7])) {
	                key_block.d(1);
	                key_block = create_key_block$4(ctx);
	                key_block.c();
	                key_block.m(div, t2);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(juan.$$.fragment, local);
	            transition_in(slider.$$.fragment, local);
	            transition_in(endmarker.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(juan.$$.fragment, local);
	            transition_out(slider.$$.fragment, local);
	            transition_out(endmarker.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(div);
	            }
	            destroy_component(juan, detaching);
	            destroy_component(slider, detaching);
	            key_block.d(detaching);
	            destroy_component(endmarker);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$6.name,
	        type: "if",
	        source: "(46:0) {#if !$loadingfolio}",
	        ctx
	    });
	    return block;
	}
	// (49:4) 
	function create_caption_slot(ctx) {
	    let span;
	    let t0;
	    let t1_value = /*folio*/ (ctx[5][0] || 1) + "";
	    let t1;
	    let t2;
	    let t3;
	    const block = {
	        c: function create() {
	            span = element("span");
	            t0 = text("折");
	            t1 = text(t1_value);
	            t2 = text("/");
	            t3 = text(/*$maxfolio*/ ctx[6]);
	            attr_dev(span, "slot", "caption");
	            set_style(span, "float", "right");
	            add_location(span, file$8, 48, 4, 1421);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t0);
	            append_dev(span, t1);
	            append_dev(span, t2);
	            append_dev(span, t3);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*folio*/ 32 && t1_value !== (t1_value = /*folio*/ (ctx[5][0] || 1) + "")) set_data_dev(t1, t1_value);
	            if (dirty & /*$maxfolio*/ 64) set_data_dev(t3, /*$maxfolio*/ ctx[6]);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_caption_slot.name,
	        type: "slot",
	        source: "(49:4) ",
	        ctx
	    });
	    return block;
	}
	// (52:0) {#each tocitems as item}
	function create_each_block$1(ctx) {
	    let div;
	    let t_value = styledNumber(/*item*/ ctx[17].id, '①') + _(/*item*/ ctx[17].caption) + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[14](/*item*/ ctx[17]);
	    }
	    const block = {
	        c: function create() {
	            div = element("div");
	            t = text(t_value);
	            attr_dev(div, "aria-hidden", "true");
	            attr_dev(div, "class", "tocitem");
	            toggle_class(div, "selecteditem", /*cknow*/ ctx[4] == /*item*/ ctx[17].id);
	            add_location(div, file$8, 52, 0, 1564);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, t);
	            if (!mounted) {
	                dispose = listen_dev(div, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*tocitems*/ 8 && t_value !== (t_value = styledNumber(/*item*/ ctx[17].id, '①') + _(/*item*/ ctx[17].caption) + "")) set_data_dev(t, t_value);
	            if (dirty & /*cknow, tocitems*/ 24) {
	                toggle_class(div, "selecteditem", /*cknow*/ ctx[4] == /*item*/ ctx[17].id);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block$1.name,
	        type: "each",
	        source: "(52:0) {#each tocitems as item}",
	        ctx
	    });
	    return block;
	}
	// (51:0) {#key $tosim}
	function create_key_block$4(ctx) {
	    let each_1_anchor;
	    let each_value = ensure_array_like_dev(/*tocitems*/ ctx[3]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            each_1_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(target, anchor);
	                }
	            }
	            insert_dev(target, each_1_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*cknow, tocitems, goBookPb, ptk*/ 538) {
	                each_value = ensure_array_like_dev(/*tocitems*/ ctx[3]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context$1(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block$1(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(each_1_anchor);
	            }
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$4.name,
	        type: "key",
	        source: "(51:0) {#key $tosim}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$8(ctx) {
	    let div;
	    let current_block_type_index;
	    let if_block;
	    let current;
	    const if_block_creators = [
	        create_if_block$6,
	        create_else_block$2
	    ];
	    const if_blocks = [];
	    function select_block_type(ctx, dirty) {
	        if (!/*$loadingfolio*/ ctx[2]) return 0;
	        return 1;
	    }
	    current_block_type_index = select_block_type(ctx);
	    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    const block = {
	        c: function create() {
	            div = element("div");
	            if_block.c();
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file$8, 44, 0, 1264);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            if_blocks[current_block_type_index].m(div, null);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            let previous_block_index = current_block_type_index;
	            current_block_type_index = select_block_type(ctx);
	            if (current_block_type_index === previous_block_index) {
	                if_blocks[current_block_type_index].p(ctx, dirty);
	            } else {
	                group_outros();
	                transition_out(if_blocks[previous_block_index], 1, 1, ()=>{
	                    if_blocks[previous_block_index] = null;
	                });
	                check_outros();
	                if_block = if_blocks[current_block_type_index];
	                if (!if_block) {
	                    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	                    if_block.c();
	                } else {
	                    if_block.p(ctx, dirty);
	                }
	                transition_in(if_block, 1);
	                if_block.m(div, null);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            if_blocks[current_block_type_index].d();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$8.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$8($$self, $$props, $$invalidate) {
	    let folio;
	    let ptk;
	    let $loadingfolio;
	    let $activepb;
	    let $activefolioid;
	    let $foliotext;
	    let $activePtk;
	    let $maxfolio;
	    let $tosim;
	    validate_store(loadingfolio, 'loadingfolio');
	    component_subscribe($$self, loadingfolio, ($$value)=>$$invalidate(2, $loadingfolio = $$value));
	    validate_store(activepb, 'activepb');
	    component_subscribe($$self, activepb, ($$value)=>$$invalidate(10, $activepb = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(11, $activefolioid = $$value));
	    validate_store(foliotext, 'foliotext');
	    component_subscribe($$self, foliotext, ($$value)=>$$invalidate(15, $foliotext = $$value));
	    validate_store(activePtk, 'activePtk');
	    component_subscribe($$self, activePtk, ($$value)=>$$invalidate(12, $activePtk = $$value));
	    validate_store(maxfolio, 'maxfolio');
	    component_subscribe($$self, maxfolio, ($$value)=>$$invalidate(6, $maxfolio = $$value));
	    validate_store(tosim, 'tosim');
	    component_subscribe($$self, tosim, ($$value)=>$$invalidate(7, $tosim = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Toc', slots, []);
	    let { closePopup } = $$props;
	    const setFolio = async (e)=>{
	        if ($loadingfolio) return;
	        const v = (e.detail[0] || 1).toString();
	        if ($activepb !== v) {
	            activepb.set(v);
	        }
	    };
	    let tocitems = [], cknow;
	    const goBookPb = (ptk, at)=>{
	        const ck = ptk.defines.ck;
	        const folioid = ptk.nearestTag(ck.linepos[at] + 1, 'folio', 'id');
	        if (folioid !== $activefolioid) {
	            loadFolio(folioid, ()=>{
	                goPbAt(ptk, at);
	            });
	        } else {
	            goPbAt(ptk, at);
	        }
	    };
	    const getCk = (pb, loading)=>{
	        if (loading) return '';
	        const ft = $foliotext;
	        if (!ft || !ft.fromFolioPos) return '';
	        const { ckid } = ft.fromFolioPos($activepb);
	        return ckid;
	    };
	    $$self.$$.on_mount.push(function() {
	        if (closePopup === undefined && !('closePopup' in $$props || $$self.$$.bound[$$self.$$.props['closePopup']])) {
	            console.warn("<Toc> was created without expected prop 'closePopup'");
	        }
	    });
	    const writable_props = [
	        'closePopup'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toc> was created with unknown prop '${key}'`);
	    });
	    function slider_value_binding(value) {
	        folio = value;
	        $$invalidate(5, folio), $$invalidate(10, $activepb);
	    }
	    const click_handler = (item)=>goBookPb(ptk, item.at);
	    $$self.$$set = ($$props)=>{
	        if ('closePopup' in $$props) $$invalidate(0, closePopup = $$props.closePopup);
	    };
	    $$self.$capture_state = ()=>({
	            Slider: Rangeslider,
	            bsearchNumber,
	            styledNumber,
	            debounce,
	            usePtk,
	            activePtk,
	            tosim,
	            activepb,
	            maxfolio,
	            activefolioid,
	            loadingfolio,
	            foliotext,
	            goPbAt,
	            loadFolio,
	            Endmarker,
	            _,
	            Juan,
	            getTocItems,
	            closePopup,
	            setFolio,
	            tocitems,
	            cknow,
	            goBookPb,
	            getCk,
	            ptk,
	            folio,
	            $loadingfolio,
	            $activepb,
	            $activefolioid,
	            $foliotext,
	            $activePtk,
	            $maxfolio,
	            $tosim
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('closePopup' in $$props) $$invalidate(0, closePopup = $$props.closePopup);
	        if ('tocitems' in $$props) $$invalidate(3, tocitems = $$props.tocitems);
	        if ('cknow' in $$props) $$invalidate(4, cknow = $$props.cknow);
	        if ('ptk' in $$props) $$invalidate(1, ptk = $$props.ptk);
	        if ('folio' in $$props) $$invalidate(5, folio = $$props.folio);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$activepb*/ 1024) {
	            $$invalidate(5, folio = [
	                parseInt($activepb),
	                0
	            ]);
	        }
	        if ($$self.$$.dirty & /*$activePtk*/ 4096) {
	            $$invalidate(1, ptk = usePtk($activePtk));
	        }
	        if ($$self.$$.dirty & /*ptk, $activefolioid, $loadingfolio*/ 2054) {
	            $$invalidate(3, tocitems = getTocItems(ptk, $activefolioid, $loadingfolio));
	        }
	        if ($$self.$$.dirty & /*$activepb, $loadingfolio*/ 1028) {
	            $$invalidate(4, cknow = getCk($activepb, $loadingfolio));
	        }
	    };
	    return [
	        closePopup,
	        ptk,
	        $loadingfolio,
	        tocitems,
	        cknow,
	        folio,
	        $maxfolio,
	        $tosim,
	        setFolio,
	        goBookPb,
	        $activepb,
	        $activefolioid,
	        $activePtk,
	        slider_value_binding,
	        click_handler
	    ];
	}
	class Toc extends SvelteComponentDev {
	    get closePopup() {
	        throw new Error("<Toc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set closePopup(value) {
	        throw new Error("<Toc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$8, create_fragment$8, safe_not_equal, {
	            closePopup: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Toc",
	            options,
	            id: create_fragment$8.name
	        });
	    }
	}

	const file$7 = "src\\taptext.svelte";
	// (47:144) {#if !ls}
	function create_if_block_10(ctx) {
	    let html_tag;
	    let raw_value = "&nbsp;" + "";
	    let t;
	    const block = {
	        c: function create() {
	            html_tag = new HtmlTag(false);
	            t = space();
	            html_tag.a = t;
	        },
	        m: function mount(target, anchor) {
	            html_tag.m(raw_value, target, anchor);
	            insert_dev(target, t, anchor);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                html_tag.d();
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_10.name,
	        type: "if",
	        source: "(47:144) {#if !ls}",
	        ctx
	    });
	    return block;
	}
	// (47:177) {#if ls}
	function create_if_block_9(ctx) {
	    let t;
	    const block = {
	        c: function create() {
	            t = text("首");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_9.name,
	        type: "if",
	        source: "(47:177) {#if ls}",
	        ctx
	    });
	    return block;
	}
	// (48:114) {#if ls}
	function create_if_block_8(ctx) {
	    let t_value = _("錄", /*$tosim*/ ctx[7]) + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*$tosim*/ 128 && t_value !== (t_value = _("錄", /*$tosim*/ ctx[7]) + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_8.name,
	        type: "if",
	        source: "(48:114) {#if ls}",
	        ctx
	    });
	    return block;
	}
	// (49:112) {#if ls}
	function create_if_block_7(ctx) {
	    let t;
	    const block = {
	        c: function create() {
	            t = text("次");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_7.name,
	        type: "if",
	        source: "(49:112) {#if ls}",
	        ctx
	    });
	    return block;
	}
	// (51:120) {#if ls}
	function create_if_block_6(ctx) {
	    let t;
	    const block = {
	        c: function create() {
	            t = text("文");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_6.name,
	        type: "if",
	        source: "(51:120) {#if ls}",
	        ctx
	    });
	    return block;
	}
	// (55:8) {:else}
	function create_else_block_1(ctx) {
	    let t;
	    let if_block_anchor;
	    let if_block = /*ls*/ ctx[5] && create_if_block_5$1(ctx);
	    const block = {
	        c: function create() {
	            t = text("🔠");
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (/*ls*/ ctx[5]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block_5$1(ctx);
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	                detach_dev(if_block_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block_1.name,
	        type: "else",
	        source: "(55:8) {:else}",
	        ctx
	    });
	    return block;
	}
	// (53:8) {#if $sharing}
	function create_if_block_3$1(ctx) {
	    let t;
	    let if_block_anchor;
	    let if_block = /*ls*/ ctx[5] && create_if_block_4$1(ctx);
	    const block = {
	        c: function create() {
	            t = text("🔗");
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (/*ls*/ ctx[5]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block_4$1(ctx);
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	                detach_dev(if_block_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_3$1.name,
	        type: "if",
	        source: "(53:8) {#if $sharing}",
	        ctx
	    });
	    return block;
	}
	// (56:14) {#if ls}
	function create_if_block_5$1(ctx) {
	    let t_value = _("詞", /*$tosim*/ ctx[7]) + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*$tosim*/ 128 && t_value !== (t_value = _("詞", /*$tosim*/ ctx[7]) + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_5$1.name,
	        type: "if",
	        source: "(56:14) {#if ls}",
	        ctx
	    });
	    return block;
	}
	// (54:14) {#if ls}
	function create_if_block_4$1(ctx) {
	    let t_value = _("鏈", /*$tosim*/ ctx[7]) + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*$tosim*/ 128 && t_value !== (t_value = _("鏈", /*$tosim*/ ctx[7]) + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_4$1.name,
	        type: "if",
	        source: "(54:14) {#if ls}",
	        ctx
	    });
	    return block;
	}
	// (61:8) {#if $mediaurls.length>1}
	function create_if_block_1$2(ctx) {
	    let span;
	    let t;
	    let mounted;
	    let dispose;
	    let if_block = /*ls*/ ctx[5] && create_if_block_2$1(ctx);
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text("🎵");
	            if (if_block) if_block.c();
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            toggle_class(span, "selected", /*thetab*/ ctx[1] == "audio");
	            add_location(span, file$7, 61, 8, 2427);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (if_block) if_block.m(span, null);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*click_handler_5*/ ctx[15], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (/*ls*/ ctx[5]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block_2$1(ctx);
	                    if_block.c();
	                    if_block.m(span, null);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	            if (dirty & /*thetab*/ 2) {
	                toggle_class(span, "selected", /*thetab*/ ctx[1] == "audio");
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            if (if_block) if_block.d();
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$2.name,
	        type: "if",
	        source: "(61:8) {#if $mediaurls.length>1}",
	        ctx
	    });
	    return block;
	}
	// (62:116) {#if ls}
	function create_if_block_2$1(ctx) {
	    let t_value = _("誦", /*$tosim*/ ctx[7]) + "";
	    let t;
	    const block = {
	        c: function create() {
	            t = text(t_value);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, t, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*$tosim*/ 128 && t_value !== (t_value = _("誦", /*$tosim*/ ctx[7]) + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_2$1.name,
	        type: "if",
	        source: "(62:116) {#if ls}",
	        ctx
	    });
	    return block;
	}
	// (73:6) {:else}
	function create_else_block$1(ctx) {
	    let div;
	    let dictpopup;
	    let current;
	    dictpopup = new Dictpopup({
	        props: {
	            entries: /*entries*/ ctx[4]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div = element("div");
	            create_component(dictpopup.$$.fragment);
	            attr_dev(div, "class", "tab-content");
	            toggle_class(div, "visible", /*thetab*/ ctx[1] == 'dict');
	            add_location(div, file$7, 73, 6, 3140);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            mount_component(dictpopup, div, null);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const dictpopup_changes = {};
	            if (dirty & /*entries*/ 16) dictpopup_changes.entries = /*entries*/ ctx[4];
	            dictpopup.$set(dictpopup_changes);
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(div, "visible", /*thetab*/ ctx[1] == 'dict');
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(dictpopup.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(dictpopup.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_component(dictpopup);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block$1.name,
	        type: "else",
	        source: "(73:6) {:else}",
	        ctx
	    });
	    return block;
	}
	// (71:6) {#if $sharing}
	function create_if_block$5(ctx) {
	    let div;
	    let sharing_1;
	    let current;
	    sharing_1 = new Sharing({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div = element("div");
	            create_component(sharing_1.$$.fragment);
	            attr_dev(div, "class", "tab-content");
	            toggle_class(div, "visible", /*thetab*/ ctx[1] == 'dict');
	            add_location(div, file$7, 71, 6, 3047);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            mount_component(sharing_1, div, null);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(div, "visible", /*thetab*/ ctx[1] == 'dict');
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(sharing_1.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(sharing_1.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            destroy_component(sharing_1);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$5.name,
	        type: "if",
	        source: "(71:6) {#if $sharing}",
	        ctx
	    });
	    return block;
	}
	// (44:0) {#key $landscape}
	function create_key_block$3(ctx) {
	    let div6;
	    let div0;
	    let span0;
	    let t0;
	    let t1;
	    let span1;
	    let t2;
	    let t3;
	    let span2;
	    let t4;
	    let t5;
	    let span3;
	    let t6;
	    let t7;
	    let span4;
	    let t8;
	    let t9;
	    let div1;
	    let foliolist;
	    let updating_thetab;
	    let t10;
	    let div2;
	    let toc;
	    let t11;
	    let div3;
	    let textual;
	    let t12;
	    let current_block_type_index;
	    let if_block7;
	    let t13;
	    let div4;
	    let audio;
	    let t14;
	    let div5;
	    let about;
	    let div6_style_value;
	    let current;
	    let mounted;
	    let dispose;
	    let if_block0 = !/*ls*/ ctx[5] && create_if_block_10(ctx);
	    let if_block1 = /*ls*/ ctx[5] && create_if_block_9(ctx);
	    let if_block2 = /*ls*/ ctx[5] && create_if_block_8(ctx);
	    let if_block3 = /*ls*/ ctx[5] && create_if_block_7(ctx);
	    let if_block4 = /*ls*/ ctx[5] && create_if_block_6(ctx);
	    function select_block_type(ctx, dirty) {
	        if (/*$sharing*/ ctx[2]) return create_if_block_3$1;
	        return create_else_block_1;
	    }
	    let current_block_type = select_block_type(ctx);
	    let if_block5 = current_block_type(ctx);
	    let if_block6 = /*$mediaurls*/ ctx[8].length > 1 && create_if_block_1$2(ctx);
	    function foliolist_thetab_binding(value) {
	        /*foliolist_thetab_binding*/ ctx[16](value);
	    }
	    let foliolist_props = {
	        closePopup: /*closePopup*/ ctx[0]
	    };
	    if (/*thetab*/ ctx[1] !== void 0) {
	        foliolist_props.thetab = /*thetab*/ ctx[1];
	    }
	    foliolist = new Foliolist({
	        props: foliolist_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(foliolist, 'thetab', foliolist_thetab_binding));
	    toc = new Toc({
	        props: {
	            closePopup: /*closePopup*/ ctx[0]
	        },
	        $$inline: true
	    });
	    textual = new Textual({
	        props: {
	            closePopup: /*closePopup*/ ctx[0]
	        },
	        $$inline: true
	    });
	    const if_block_creators = [
	        create_if_block$5,
	        create_else_block$1
	    ];
	    const if_blocks = [];
	    function select_block_type_1(ctx, dirty) {
	        if (/*$sharing*/ ctx[2]) return 0;
	        return 1;
	    }
	    current_block_type_index = select_block_type_1(ctx);
	    if_block7 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    audio = new Audio({
	        $$inline: true
	    });
	    about = new About({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            div6 = element("div");
	            div0 = element("div");
	            span0 = element("span");
	            if (if_block0) if_block0.c();
	            t0 = text("⚙️");
	            if (if_block1) if_block1.c();
	            t1 = space();
	            span1 = element("span");
	            t2 = text("📚");
	            if (if_block2) if_block2.c();
	            t3 = space();
	            span2 = element("span");
	            t4 = text("🧭");
	            if (if_block3) if_block3.c();
	            t5 = space();
	            span3 = element("span");
	            t6 = text("📜");
	            if (if_block4) if_block4.c();
	            t7 = space();
	            span4 = element("span");
	            if_block5.c();
	            t8 = space();
	            if (if_block6) if_block6.c();
	            t9 = space();
	            div1 = element("div");
	            create_component(foliolist.$$.fragment);
	            t10 = space();
	            div2 = element("div");
	            create_component(toc.$$.fragment);
	            t11 = space();
	            div3 = element("div");
	            create_component(textual.$$.fragment);
	            t12 = space();
	            if_block7.c();
	            t13 = space();
	            div4 = element("div");
	            create_component(audio.$$.fragment);
	            t14 = space();
	            div5 = element("div");
	            create_component(about.$$.fragment);
	            attr_dev(span0, "aria-hidden", "true");
	            attr_dev(span0, "class", "clickable");
	            toggle_class(span0, "needupdate", /*$hasupdate*/ ctx[6]);
	            toggle_class(span0, "selected", /*thetab*/ ctx[1] == "about");
	            add_location(span0, file$7, 46, 8, 1473);
	            attr_dev(span1, "aria-hidden", "true");
	            attr_dev(span1, "class", "clickable");
	            toggle_class(span1, "selected", /*thetab*/ ctx[1] == "list");
	            add_location(span1, file$7, 47, 8, 1672);
	            attr_dev(span2, "aria-hidden", "true");
	            attr_dev(span2, "class", "clickable");
	            toggle_class(span2, "selected", /*thetab*/ ctx[1] == "toc");
	            add_location(span2, file$7, 48, 8, 1822);
	            attr_dev(span3, "aria-hidden", "true");
	            attr_dev(span3, "class", "clickable");
	            toggle_class(span3, "selected", /*thetab*/ ctx[1] == "textual");
	            add_location(span3, file$7, 50, 8, 1965);
	            attr_dev(span4, "aria-hidden", "true");
	            attr_dev(span4, "class", "clickable");
	            toggle_class(span4, "selected", /*thetab*/ ctx[1] == "dict");
	            add_location(span4, file$7, 51, 8, 2111);
	            attr_dev(div0, "class", "tabs");
	            add_location(div0, file$7, 45, 4, 1442);
	            attr_dev(div1, "class", "tab-content");
	            toggle_class(div1, "visible", /*thetab*/ ctx[1] == 'list');
	            add_location(div1, file$7, 65, 6, 2603);
	            attr_dev(div2, "class", "tab-content");
	            toggle_class(div2, "visible", /*thetab*/ ctx[1] == 'toc');
	            add_location(div2, file$7, 66, 6, 2711);
	            attr_dev(div3, "class", "tab-content");
	            toggle_class(div3, "visible", /*thetab*/ ctx[1] == 'textual');
	            add_location(div3, file$7, 68, 6, 2923);
	            attr_dev(div4, "class", "tab-content");
	            toggle_class(div4, "visible", /*thetab*/ ctx[1] == 'audio');
	            add_location(div4, file$7, 76, 6, 3250);
	            attr_dev(div5, "class", "tab-content");
	            toggle_class(div5, "visible", /*thetab*/ ctx[1] == 'about');
	            add_location(div5, file$7, 77, 6, 3329);
	            attr_dev(div6, "class", "popup");
	            attr_dev(div6, "style", div6_style_value = /*ls*/ ctx[5] ? sideWidth(/*ls*/ ctx[5]) : '');
	            add_location(div6, file$7, 44, 0, 1390);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div6, anchor);
	            append_dev(div6, div0);
	            append_dev(div0, span0);
	            if (if_block0) if_block0.m(span0, null);
	            append_dev(span0, t0);
	            if (if_block1) if_block1.m(span0, null);
	            append_dev(div0, t1);
	            append_dev(div0, span1);
	            append_dev(span1, t2);
	            if (if_block2) if_block2.m(span1, null);
	            append_dev(div0, t3);
	            append_dev(div0, span2);
	            append_dev(span2, t4);
	            if (if_block3) if_block3.m(span2, null);
	            append_dev(div0, t5);
	            append_dev(div0, span3);
	            append_dev(span3, t6);
	            if (if_block4) if_block4.m(span3, null);
	            append_dev(div0, t7);
	            append_dev(div0, span4);
	            if_block5.m(span4, null);
	            append_dev(div0, t8);
	            if (if_block6) if_block6.m(div0, null);
	            append_dev(div6, t9);
	            append_dev(div6, div1);
	            mount_component(foliolist, div1, null);
	            append_dev(div6, t10);
	            append_dev(div6, div2);
	            mount_component(toc, div2, null);
	            append_dev(div6, t11);
	            append_dev(div6, div3);
	            mount_component(textual, div3, null);
	            append_dev(div6, t12);
	            if_blocks[current_block_type_index].m(div6, null);
	            append_dev(div6, t13);
	            append_dev(div6, div4);
	            mount_component(audio, div4, null);
	            append_dev(div6, t14);
	            append_dev(div6, div5);
	            mount_component(about, div5, null);
	            current = true;
	            if (!mounted) {
	                dispose = [
	                    listen_dev(span0, "click", /*click_handler*/ ctx[10], false, false, false, false),
	                    listen_dev(span1, "click", /*click_handler_1*/ ctx[11], false, false, false, false),
	                    listen_dev(span2, "click", /*click_handler_2*/ ctx[12], false, false, false, false),
	                    listen_dev(span3, "click", /*click_handler_3*/ ctx[13], false, false, false, false),
	                    listen_dev(span4, "click", /*click_handler_4*/ ctx[14], false, false, false, false)
	                ];
	                mounted = true;
	            }
	        },
	        p: function update(ctx, dirty) {
	            if (!/*ls*/ ctx[5]) {
	                if (if_block0) ; else {
	                    if_block0 = create_if_block_10(ctx);
	                    if_block0.c();
	                    if_block0.m(span0, t0);
	                }
	            } else if (if_block0) {
	                if_block0.d(1);
	                if_block0 = null;
	            }
	            if (/*ls*/ ctx[5]) {
	                if (if_block1) ; else {
	                    if_block1 = create_if_block_9(ctx);
	                    if_block1.c();
	                    if_block1.m(span0, null);
	                }
	            } else if (if_block1) {
	                if_block1.d(1);
	                if_block1 = null;
	            }
	            if (!current || dirty & /*$hasupdate*/ 64) {
	                toggle_class(span0, "needupdate", /*$hasupdate*/ ctx[6]);
	            }
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(span0, "selected", /*thetab*/ ctx[1] == "about");
	            }
	            if (/*ls*/ ctx[5]) {
	                if (if_block2) {
	                    if_block2.p(ctx, dirty);
	                } else {
	                    if_block2 = create_if_block_8(ctx);
	                    if_block2.c();
	                    if_block2.m(span1, null);
	                }
	            } else if (if_block2) {
	                if_block2.d(1);
	                if_block2 = null;
	            }
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(span1, "selected", /*thetab*/ ctx[1] == "list");
	            }
	            if (/*ls*/ ctx[5]) {
	                if (if_block3) ; else {
	                    if_block3 = create_if_block_7(ctx);
	                    if_block3.c();
	                    if_block3.m(span2, null);
	                }
	            } else if (if_block3) {
	                if_block3.d(1);
	                if_block3 = null;
	            }
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(span2, "selected", /*thetab*/ ctx[1] == "toc");
	            }
	            if (/*ls*/ ctx[5]) {
	                if (if_block4) ; else {
	                    if_block4 = create_if_block_6(ctx);
	                    if_block4.c();
	                    if_block4.m(span3, null);
	                }
	            } else if (if_block4) {
	                if_block4.d(1);
	                if_block4 = null;
	            }
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(span3, "selected", /*thetab*/ ctx[1] == "textual");
	            }
	            if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block5) {
	                if_block5.p(ctx, dirty);
	            } else {
	                if_block5.d(1);
	                if_block5 = current_block_type(ctx);
	                if (if_block5) {
	                    if_block5.c();
	                    if_block5.m(span4, null);
	                }
	            }
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(span4, "selected", /*thetab*/ ctx[1] == "dict");
	            }
	            if (/*$mediaurls*/ ctx[8].length > 1) {
	                if (if_block6) {
	                    if_block6.p(ctx, dirty);
	                } else {
	                    if_block6 = create_if_block_1$2(ctx);
	                    if_block6.c();
	                    if_block6.m(div0, null);
	                }
	            } else if (if_block6) {
	                if_block6.d(1);
	                if_block6 = null;
	            }
	            const foliolist_changes = {};
	            if (dirty & /*closePopup*/ 1) foliolist_changes.closePopup = /*closePopup*/ ctx[0];
	            if (!updating_thetab && dirty & /*thetab*/ 2) {
	                updating_thetab = true;
	                foliolist_changes.thetab = /*thetab*/ ctx[1];
	                add_flush_callback(()=>updating_thetab = false);
	            }
	            foliolist.$set(foliolist_changes);
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(div1, "visible", /*thetab*/ ctx[1] == 'list');
	            }
	            const toc_changes = {};
	            if (dirty & /*closePopup*/ 1) toc_changes.closePopup = /*closePopup*/ ctx[0];
	            toc.$set(toc_changes);
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(div2, "visible", /*thetab*/ ctx[1] == 'toc');
	            }
	            const textual_changes = {};
	            if (dirty & /*closePopup*/ 1) textual_changes.closePopup = /*closePopup*/ ctx[0];
	            textual.$set(textual_changes);
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(div3, "visible", /*thetab*/ ctx[1] == 'textual');
	            }
	            let previous_block_index = current_block_type_index;
	            current_block_type_index = select_block_type_1(ctx);
	            if (current_block_type_index === previous_block_index) {
	                if_blocks[current_block_type_index].p(ctx, dirty);
	            } else {
	                group_outros();
	                transition_out(if_blocks[previous_block_index], 1, 1, ()=>{
	                    if_blocks[previous_block_index] = null;
	                });
	                check_outros();
	                if_block7 = if_blocks[current_block_type_index];
	                if (!if_block7) {
	                    if_block7 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	                    if_block7.c();
	                } else {
	                    if_block7.p(ctx, dirty);
	                }
	                transition_in(if_block7, 1);
	                if_block7.m(div6, t13);
	            }
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(div4, "visible", /*thetab*/ ctx[1] == 'audio');
	            }
	            if (!current || dirty & /*thetab*/ 2) {
	                toggle_class(div5, "visible", /*thetab*/ ctx[1] == 'about');
	            }
	            if (!current || dirty & /*ls*/ 32 && div6_style_value !== (div6_style_value = /*ls*/ ctx[5] ? sideWidth(/*ls*/ ctx[5]) : '')) {
	                attr_dev(div6, "style", div6_style_value);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(foliolist.$$.fragment, local);
	            transition_in(toc.$$.fragment, local);
	            transition_in(textual.$$.fragment, local);
	            transition_in(if_block7);
	            transition_in(audio.$$.fragment, local);
	            transition_in(about.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(foliolist.$$.fragment, local);
	            transition_out(toc.$$.fragment, local);
	            transition_out(textual.$$.fragment, local);
	            transition_out(if_block7);
	            transition_out(audio.$$.fragment, local);
	            transition_out(about.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div6);
	            }
	            if (if_block0) if_block0.d();
	            if (if_block1) if_block1.d();
	            if (if_block2) if_block2.d();
	            if (if_block3) if_block3.d();
	            if (if_block4) if_block4.d();
	            if_block5.d();
	            if (if_block6) if_block6.d();
	            destroy_component(foliolist);
	            destroy_component(toc);
	            destroy_component(textual);
	            if_blocks[current_block_type_index].d();
	            destroy_component(audio);
	            destroy_component(about);
	            mounted = false;
	            run_all(dispose);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$3.name,
	        type: "key",
	        source: "(44:0) {#key $landscape}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$7(ctx) {
	    let previous_key = /*$landscape*/ ctx[3];
	    let key_block_anchor;
	    let current;
	    let key_block = create_key_block$3(ctx);
	    const block = {
	        c: function create() {
	            key_block.c();
	            key_block_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            key_block.m(target, anchor);
	            insert_dev(target, key_block_anchor, anchor);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*$landscape*/ 8 && safe_not_equal(previous_key, previous_key = /*$landscape*/ ctx[3])) {
	                group_outros();
	                transition_out(key_block, 1, 1, noop);
	                check_outros();
	                key_block = create_key_block$3(ctx);
	                key_block.c();
	                transition_in(key_block, 1);
	                key_block.m(key_block_anchor.parentNode, key_block_anchor);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(key_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(key_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(key_block_anchor);
	            }
	            key_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$7.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$7($$self, $$props, $$invalidate) {
	    let ls;
	    let $sharing;
	    let $landscape;
	    let $activePtk;
	    let $hasupdate;
	    let $tosim;
	    let $mediaurls;
	    validate_store(sharing, 'sharing');
	    component_subscribe($$self, sharing, ($$value)=>$$invalidate(2, $sharing = $$value));
	    validate_store(landscape, 'landscape');
	    component_subscribe($$self, landscape, ($$value)=>$$invalidate(3, $landscape = $$value));
	    validate_store(activePtk, 'activePtk');
	    component_subscribe($$self, activePtk, ($$value)=>$$invalidate(17, $activePtk = $$value));
	    validate_store(hasupdate, 'hasupdate');
	    component_subscribe($$self, hasupdate, ($$value)=>$$invalidate(6, $hasupdate = $$value));
	    validate_store(tosim, 'tosim');
	    component_subscribe($$self, tosim, ($$value)=>$$invalidate(7, $tosim = $$value));
	    validate_store(mediaurls, 'mediaurls');
	    component_subscribe($$self, mediaurls, ($$value)=>$$invalidate(8, $mediaurls = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Taptext', slots, []);
	    let { tofind = '' } = $$props;
	    let { closePopup } = $$props;
	    let thetab = $landscape || !tofind ? "textual" : "dict";
	    if (!navigator.onLine && thetab == 'dict') thetab = 'list';
	    let entries = [];
	    const onDict = (t)=>{
	        var _ptk_columns_entries;
	        const tap_at = t.indexOf(CURSORMARK);
	        const ptk = usePtk($activePtk);
	        $$invalidate(4, entries = ((_ptk_columns_entries = ptk.columns.entries) === null || _ptk_columns_entries === void 0 ? void 0 : _ptk_columns_entries.keys.findMatches(t.replace(CURSORMARK, '')).map((it)=>[
	                Math.abs(it[0] - tap_at - 1),
	                it[1],
	                it[2]
	            ])) || []);
	        entries.sort((a, b)=>a[0] - b[0]); // 越接近點擊處的優先
	    }; //showdict=true;
	    const setSearchable = (t)=>{
	        const tap_at = t.indexOf(CURSORMARK);
	        searchable.set(t.slice(tap_at + 1));
	    };
	    $$self.$$.on_mount.push(function() {
	        if (closePopup === undefined && !('closePopup' in $$props || $$self.$$.bound[$$self.$$.props['closePopup']])) {
	            console.warn("<Taptext> was created without expected prop 'closePopup'");
	        }
	    });
	    const writable_props = [
	        'tofind',
	        'closePopup'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Taptext> was created with unknown prop '${key}'`);
	    });
	    const click_handler = ()=>$$invalidate(1, thetab = "about");
	    const click_handler_1 = ()=>$$invalidate(1, thetab = "list");
	    const click_handler_2 = ()=>$$invalidate(1, thetab = "toc");
	    const click_handler_3 = ()=>$$invalidate(1, thetab = "textual");
	    const click_handler_4 = ()=>$$invalidate(1, thetab = "dict");
	    const click_handler_5 = ()=>$$invalidate(1, thetab = "audio");
	    function foliolist_thetab_binding(value) {
	        thetab = value;
	        $$invalidate(1, thetab), $$invalidate(2, $sharing);
	    }
	    $$self.$$set = ($$props)=>{
	        if ('tofind' in $$props) $$invalidate(9, tofind = $$props.tofind);
	        if ('closePopup' in $$props) $$invalidate(0, closePopup = $$props.closePopup);
	    };
	    $$self.$capture_state = ()=>({
	            DictPopup: Dictpopup,
	            Foliolist,
	            Audio,
	            About,
	            Textual,
	            Sharing,
	            Toc,
	            _,
	            activePtk,
	            landscape,
	            sideWidth,
	            searchable,
	            mediaurls,
	            sharing,
	            tosim,
	            hasupdate,
	            usePtk,
	            CURSORMARK,
	            tofind,
	            closePopup,
	            thetab,
	            entries,
	            onDict,
	            setSearchable,
	            ls,
	            $sharing,
	            $landscape,
	            $activePtk,
	            $hasupdate,
	            $tosim,
	            $mediaurls
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('tofind' in $$props) $$invalidate(9, tofind = $$props.tofind);
	        if ('closePopup' in $$props) $$invalidate(0, closePopup = $$props.closePopup);
	        if ('thetab' in $$props) $$invalidate(1, thetab = $$props.thetab);
	        if ('entries' in $$props) $$invalidate(4, entries = $$props.entries);
	        if ('ls' in $$props) $$invalidate(5, ls = $$props.ls);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$landscape*/ 8) {
	            /*
	const copyaddress=async ele=>{
	    await navigator.clipboard.writeText(tapAddress());
	    ele.target.innerHTML='copied';
	    setTimeout(()=>{
	        ele.target.innerHTML=tapAddress();
	    },2000)
	}
	*/ $$invalidate(5, ls = $landscape);
	        }
	        if ($$self.$$.dirty & /*tofind*/ 512) {
	            setSearchable(tofind);
	        }
	        if ($$self.$$.dirty & /*$sharing*/ 4) {
	            if ($sharing) $$invalidate(1, thetab = 'dict');
	        }
	        if ($$self.$$.dirty & /*thetab, tofind*/ 514) {
	            thetab == 'dict' && onDict(tofind);
	        }
	    };
	    return [
	        closePopup,
	        thetab,
	        $sharing,
	        $landscape,
	        entries,
	        ls,
	        $hasupdate,
	        $tosim,
	        $mediaurls,
	        tofind,
	        click_handler,
	        click_handler_1,
	        click_handler_2,
	        click_handler_3,
	        click_handler_4,
	        click_handler_5,
	        foliolist_thetab_binding
	    ];
	}
	class Taptext extends SvelteComponentDev {
	    get tofind() {
	        throw new Error("<Taptext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set tofind(value) {
	        throw new Error("<Taptext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    get closePopup() {
	        throw new Error("<Taptext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set closePopup(value) {
	        throw new Error("<Taptext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$7, create_fragment$7, safe_not_equal, {
	            tofind: 9,
	            closePopup: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Taptext",
	            options,
	            id: create_fragment$7.name
	        });
	    }
	}

	const file$6 = "src\\player.svelte";
	// (24:4) {#if $audioid}
	function create_if_block$4(ctx) {
	    let source;
	    let source_src_value;
	    const block = {
	        c: function create() {
	            source = element("source");
	            if (!src_url_equal(source.src, source_src_value = audiofolder + /*$audioid*/ ctx[1].replace(/\^\d+$/, '') + '.mp3')) attr_dev(source, "src", source_src_value);
	            add_location(source, file$6, 23, 18, 757);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, source, anchor);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*$audioid*/ 2 && !src_url_equal(source.src, source_src_value = audiofolder + /*$audioid*/ ctx[1].replace(/\^\d+$/, '') + '.mp3')) {
	                attr_dev(source, "src", source_src_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(source);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$4.name,
	        type: "if",
	        source: "(24:4) {#if $audioid}",
	        ctx
	    });
	    return block;
	}
	// (22:0) {#key $audioid}
	function create_key_block$2(ctx) {
	    let audio;
	    let if_block = /*$audioid*/ ctx[1] && create_if_block$4(ctx);
	    const block = {
	        c: function create() {
	            audio = element("audio");
	            if (if_block) if_block.c();
	            add_location(audio, file$6, 22, 0, 707);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, audio, anchor);
	            if (if_block) if_block.m(audio, null);
	            /*audio_binding*/ ctx[3](audio);
	        },
	        p: function update(ctx, dirty) {
	            if (/*$audioid*/ ctx[1]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block$4(ctx);
	                    if_block.c();
	                    if_block.m(audio, null);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(audio);
	            }
	            if (if_block) if_block.d();
	            /*audio_binding*/ ctx[3](null);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$2.name,
	        type: "key",
	        source: "(22:0) {#key $audioid}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$6(ctx) {
	    let previous_key = /*$audioid*/ ctx[1];
	    let key_block_anchor;
	    let key_block = create_key_block$2(ctx);
	    const block = {
	        c: function create() {
	            key_block.c();
	            key_block_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            key_block.m(target, anchor);
	            insert_dev(target, key_block_anchor, anchor);
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*$audioid*/ 2 && safe_not_equal(previous_key, previous_key = /*$audioid*/ ctx[1])) {
	                key_block.d(1);
	                key_block = create_key_block$2(ctx);
	                key_block.c();
	                key_block.m(key_block_anchor.parentNode, key_block_anchor);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(key_block_anchor);
	            }
	            key_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$6.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$6($$self, $$props, $$invalidate) {
	    let $audioid;
	    let $activepb;
	    let $activefolioid;
	    let $playing;
	    let $continueplay;
	    validate_store(audioid, 'audioid');
	    component_subscribe($$self, audioid, ($$value)=>$$invalidate(1, $audioid = $$value));
	    validate_store(activepb, 'activepb');
	    component_subscribe($$self, activepb, ($$value)=>$$invalidate(2, $activepb = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(5, $activefolioid = $$value));
	    validate_store(playing, 'playing');
	    component_subscribe($$self, playing, ($$value)=>$$invalidate(6, $playing = $$value));
	    validate_store(continueplay, 'continueplay');
	    component_subscribe($$self, continueplay, ($$value)=>$$invalidate(7, $continueplay = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Player', slots, []);
	    let audioplayer;
	    const seekToPb = (pbid, audioid)=>{
	        if (!audioid || $continueplay || !$playing) return;
	        const { timestamp, bookid } = findByAudioId(audioid);
	        if (bookid !== $activefolioid) {
	            stopAudio();
	        }
	        if (!timestamp) return;
	        const line = (parseInt(pbid) - 1) * folioLines();
	        const t = timestamp[line];
	        setTimeout(()=>{
	            //allow audio to initialized
	            if (player) player.currentTime = t / 100;
	        }, 100);
	    };
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Player> was created with unknown prop '${key}'`);
	    });
	    function audio_binding($$value) {
	        binding_callbacks[$$value ? 'unshift' : 'push'](()=>{
	            audioplayer = $$value;
	            $$invalidate(0, audioplayer);
	        });
	    }
	    $$self.$capture_state = ()=>({
	            player,
	            setplayer,
	            activepb,
	            audioid,
	            folioLines,
	            continueplay,
	            playing,
	            activefolioid,
	            stopAudio,
	            findByAudioId,
	            audiofolder,
	            audioplayer,
	            seekToPb,
	            $audioid,
	            $activepb,
	            $activefolioid,
	            $playing,
	            $continueplay
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('audioplayer' in $$props) $$invalidate(0, audioplayer = $$props.audioplayer);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*audioplayer*/ 1) {
	            setplayer(audioplayer);
	        }
	        if ($$self.$$.dirty & /*$activepb, $audioid*/ 6) {
	            seekToPb($activepb, $audioid);
	        }
	    };
	    return [
	        audioplayer,
	        $audioid,
	        $activepb,
	        audio_binding
	    ];
	}
	class Player extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Player",
	            options,
	            id: create_fragment$6.name
	        });
	    }
	}

	const file$5 = "src\\newbie.svelte";
	// (16:0) {#key $tosim}
	function create_key_block$1(ctx) {
	    let span;
	    let t3;
	    let br0;
	    let t4_value = _("僅供非佛學專業人士使用") + "";
	    let t4;
	    let t5;
	    let br1;
	    let t6_value = _("漢字顯示") + "";
	    let t6;
	    let t7;
	    let statebtn;
	    let t8;
	    let br2;
	    let t9_value = _("全屏模式安裝步驟") + "";
	    let t9;
	    let t10;
	    let br3;
	    let t11_value = _("安卓：右上角⋮ →安裝應用程式") + "";
	    let t11;
	    let t12;
	    let br4;
	    let t13_value = _("iOS：分享→加到主畫面") + "";
	    let t13;
	    let t14;
	    let hr;
	    let t15;
	    let t16_value = _("本軟件不會主動收集個人資訊") + "";
	    let t16;
	    let t17;
	    let br5;
	    let t18_value = _("同意接受使用本軟件產生的任何結果") + "";
	    let t18;
	    let t19;
	    let br6;
	    let button;
	    let t21;
	    let switch_1;
	    let updating_value;
	    let current;
	    let mounted;
	    let dispose;
	    statebtn = new Statebutton({
	        props: {
	            states: {
	                0: "原貌",
	                1: _("简體（「乾後發」等不變）"),
	                2: "简体"
	            },
	            storeid: tosim
	        },
	        $$inline: true
	    });
	    function switch_1_value_binding(value) {
	        /*switch_1_value_binding*/ ctx[3](value);
	    }
	    let switch_1_props = {
	        label: _("啟用時再度顯示此畫面"),
	        design: "slider"
	    };
	    if (/*value*/ ctx[1] !== void 0) {
	        switch_1_props.value = /*value*/ ctx[1];
	    }
	    switch_1 = new Switch({
	        props: switch_1_props,
	        $$inline: true
	    });
	    binding_callbacks.push(()=>bind(switch_1, 'value', switch_1_value_binding));
	    const block = {
	        c: function create() {
	            span = element("span");
	            span.textContent = `${_("永樂藏")} ${APPVER}`;
	            t3 = space();
	            br0 = element("br");
	            t4 = text(t4_value);
	            t5 = space();
	            br1 = element("br");
	            t6 = text(t6_value);
	            t7 = text("：");
	            create_component(statebtn.$$.fragment);
	            t8 = space();
	            br2 = element("br");
	            t9 = text(t9_value);
	            t10 = space();
	            br3 = element("br");
	            t11 = text(t11_value);
	            t12 = space();
	            br4 = element("br");
	            t13 = text(t13_value);
	            t14 = space();
	            hr = element("hr");
	            t15 = space();
	            t16 = text(t16_value);
	            t17 = space();
	            br5 = element("br");
	            t18 = text(t18_value);
	            t19 = space();
	            br6 = element("br");
	            button = element("button");
	            button.textContent = "同意";
	            t21 = space();
	            create_component(switch_1.$$.fragment);
	            attr_dev(span, "class", "welcome");
	            add_location(span, file$5, 16, 0, 397);
	            add_location(br0, file$5, 17, 0, 446);
	            add_location(br1, file$5, 18, 0, 470);
	            add_location(br2, file$5, 19, 0, 560);
	            add_location(br3, file$5, 20, 0, 581);
	            add_location(br4, file$5, 21, 0, 609);
	            add_location(hr, file$5, 22, 0, 634);
	            add_location(br5, file$5, 24, 0, 661);
	            add_location(br6, file$5, 25, 0, 690);
	            set_style(button, "font-size", "150%");
	            set_style(button, "width", "100%");
	            add_location(button, file$5, 25, 5, 695);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            insert_dev(target, t3, anchor);
	            insert_dev(target, br0, anchor);
	            insert_dev(target, t4, anchor);
	            insert_dev(target, t5, anchor);
	            insert_dev(target, br1, anchor);
	            insert_dev(target, t6, anchor);
	            insert_dev(target, t7, anchor);
	            mount_component(statebtn, target, anchor);
	            insert_dev(target, t8, anchor);
	            insert_dev(target, br2, anchor);
	            insert_dev(target, t9, anchor);
	            insert_dev(target, t10, anchor);
	            insert_dev(target, br3, anchor);
	            insert_dev(target, t11, anchor);
	            insert_dev(target, t12, anchor);
	            insert_dev(target, br4, anchor);
	            insert_dev(target, t13, anchor);
	            insert_dev(target, t14, anchor);
	            insert_dev(target, hr, anchor);
	            insert_dev(target, t15, anchor);
	            insert_dev(target, t16, anchor);
	            insert_dev(target, t17, anchor);
	            insert_dev(target, br5, anchor);
	            insert_dev(target, t18, anchor);
	            insert_dev(target, t19, anchor);
	            insert_dev(target, br6, anchor);
	            insert_dev(target, button, anchor);
	            insert_dev(target, t21, anchor);
	            mount_component(switch_1, target, anchor);
	            current = true;
	            if (!mounted) {
	                dispose = listen_dev(button, "click", function() {
	                    if (is_function(/*closePopup*/ ctx[0])) /*closePopup*/ ctx[0].apply(this, arguments);
	                }, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            const switch_1_changes = {};
	            if (!updating_value && dirty & /*value*/ 2) {
	                updating_value = true;
	                switch_1_changes.value = /*value*/ ctx[1];
	                add_flush_callback(()=>updating_value = false);
	            }
	            switch_1.$set(switch_1_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(statebtn.$$.fragment, local);
	            transition_in(switch_1.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(statebtn.$$.fragment, local);
	            transition_out(switch_1.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	                detach_dev(t3);
	                detach_dev(br0);
	                detach_dev(t4);
	                detach_dev(t5);
	                detach_dev(br1);
	                detach_dev(t6);
	                detach_dev(t7);
	                detach_dev(t8);
	                detach_dev(br2);
	                detach_dev(t9);
	                detach_dev(t10);
	                detach_dev(br3);
	                detach_dev(t11);
	                detach_dev(t12);
	                detach_dev(br4);
	                detach_dev(t13);
	                detach_dev(t14);
	                detach_dev(hr);
	                detach_dev(t15);
	                detach_dev(t16);
	                detach_dev(t17);
	                detach_dev(br5);
	                detach_dev(t18);
	                detach_dev(t19);
	                detach_dev(br6);
	                detach_dev(button);
	                detach_dev(t21);
	            }
	            destroy_component(statebtn, detaching);
	            destroy_component(switch_1, detaching);
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block$1.name,
	        type: "key",
	        source: "(16:0) {#key $tosim}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$5(ctx) {
	    let div1;
	    let div0;
	    let previous_key = /*$tosim*/ ctx[2];
	    let current;
	    let key_block = create_key_block$1(ctx);
	    const block = {
	        c: function create() {
	            div1 = element("div");
	            div0 = element("div");
	            key_block.c();
	            attr_dev(div0, "class", "bodytext");
	            add_location(div0, file$5, 14, 0, 360);
	            attr_dev(div1, "class", "popup");
	            add_location(div1, file$5, 13, 0, 340);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div1, anchor);
	            append_dev(div1, div0);
	            key_block.m(div0, null);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*$tosim*/ 4 && safe_not_equal(previous_key, previous_key = /*$tosim*/ ctx[2])) {
	                group_outros();
	                transition_out(key_block, 1, 1, noop);
	                check_outros();
	                key_block = create_key_block$1(ctx);
	                key_block.c();
	                transition_in(key_block, 1);
	                key_block.m(div0, null);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(key_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(key_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div1);
	            }
	            key_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$5.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$5($$self, $$props, $$invalidate) {
	    let $newbie;
	    let $tosim;
	    validate_store(newbie, 'newbie');
	    component_subscribe($$self, newbie, ($$value)=>$$invalidate(4, $newbie = $$value));
	    validate_store(tosim, 'tosim');
	    component_subscribe($$self, tosim, ($$value)=>$$invalidate(2, $tosim = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Newbie', slots, []);
	    let value = $newbie;
	    let { closePopup } = $$props;
	    onDestroy(()=>{
	        newbie.set(value);
	    });
	    $$self.$$.on_mount.push(function() {
	        if (closePopup === undefined && !('closePopup' in $$props || $$self.$$.bound[$$self.$$.props['closePopup']])) {
	            console.warn("<Newbie> was created without expected prop 'closePopup'");
	        }
	    });
	    const writable_props = [
	        'closePopup'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Newbie> was created with unknown prop '${key}'`);
	    });
	    function switch_1_value_binding(value$1) {
	        value = value$1;
	        $$invalidate(1, value);
	    }
	    $$self.$$set = ($$props)=>{
	        if ('closePopup' in $$props) $$invalidate(0, closePopup = $$props.closePopup);
	    };
	    $$self.$capture_state = ()=>({
	            onDestroy,
	            Switch,
	            newbie,
	            tosim,
	            APPVER,
	            StateBtn: Statebutton,
	            _,
	            value,
	            closePopup,
	            $newbie,
	            $tosim
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('value' in $$props) $$invalidate(1, value = $$props.value);
	        if ('closePopup' in $$props) $$invalidate(0, closePopup = $$props.closePopup);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        closePopup,
	        value,
	        $tosim,
	        switch_1_value_binding
	    ];
	}
	class Newbie extends SvelteComponentDev {
	    get closePopup() {
	        throw new Error("<Newbie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set closePopup(value) {
	        throw new Error("<Newbie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$5, create_fragment$5, safe_not_equal, {
	            closePopup: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Newbie",
	            options,
	            id: create_fragment$5.name
	        });
	    }
	}

	const file$4 = "src\\paiji.svelte";
	// (22:20) 
	function create_if_block_1$1(ctx) {
	    let div3;
	    let img;
	    let img_src_value;
	    let t0;
	    let div0;
	    let t1;
	    let div0_style_value;
	    let t2;
	    let div2;
	    let div1;
	    let br0;
	    let t3;
	    let br1;
	    let t4;
	    let br2;
	    let t5;
	    let div3_style_value;
	    const block = {
	        c: function create() {
	            div3 = element("div");
	            img = element("img");
	            t0 = space();
	            div0 = element("div");
	            t1 = text(/*text*/ ctx[1]);
	            t2 = space();
	            div2 = element("div");
	            div1 = element("div");
	            br0 = element("br");
	            t3 = text("　諸供養中　法供養最\n");
	            br1 = element("br");
	            t4 = text("願以此功德　普及於一切\n");
	            br2 = element("br");
	            t5 = text("我等與眾生　皆共成佛道");
	            attr_dev(img, "alt", "frame");
	            if (!src_url_equal(img.src, img_src_value = "frames/red.jpg")) attr_dev(img, "src", img_src_value);
	            attr_dev(img, "class", "svelte-1p857lj");
	            add_location(img, file$4, 23, 0, 662);
	            attr_dev(div0, "class", "sponsor");
	            attr_dev(div0, "style", div0_style_value = "padding-left:" + /*forceshow*/ (ctx[0] ? folioHolderWidth(/*$landscape*/ ctx[3], 0.45) : '45vw'));
	            add_location(div0, file$4, 24, 0, 702);
	            add_location(br0, file$4, 28, 0, 871);
	            add_location(br1, file$4, 29, 0, 887);
	            add_location(br2, file$4, 30, 0, 904);
	            attr_dev(div1, "class", "paijitext");
	            add_location(div1, file$4, 27, 0, 847);
	            attr_dev(div2, "class", "paijitextcontainer");
	            add_location(div2, file$4, 26, 0, 814);
	            attr_dev(div3, "class", "paiji");
	            attr_dev(div3, "style", div3_style_value = 'width:' + /*forceshow*/ (ctx[0] ? folioHolderWidth() : ''));
	            add_location(div3, file$4, 22, 0, 591);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div3, anchor);
	            append_dev(div3, img);
	            append_dev(div3, t0);
	            append_dev(div3, div0);
	            append_dev(div0, t1);
	            append_dev(div3, t2);
	            append_dev(div3, div2);
	            append_dev(div2, div1);
	            append_dev(div1, br0);
	            append_dev(div1, t3);
	            append_dev(div1, br1);
	            append_dev(div1, t4);
	            append_dev(div1, br2);
	            append_dev(div1, t5);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*text*/ 2) set_data_dev(t1, /*text*/ ctx[1]);
	            if (dirty & /*forceshow, $landscape*/ 9 && div0_style_value !== (div0_style_value = "padding-left:" + /*forceshow*/ (ctx[0] ? folioHolderWidth(/*$landscape*/ ctx[3], 0.45) : '45vw'))) {
	                attr_dev(div0, "style", div0_style_value);
	            }
	            if (dirty & /*forceshow*/ 1 && div3_style_value !== (div3_style_value = 'width:' + /*forceshow*/ (ctx[0] ? folioHolderWidth() : ''))) {
	                attr_dev(div3, "style", div3_style_value);
	            }
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div3);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1$1.name,
	        type: "if",
	        source: "(22:20) ",
	        ctx
	    });
	    return block;
	}
	// (16:0) {#if isSidePaiji() && !forceshow}
	function create_if_block$3(ctx) {
	    let div3;
	    let div0;
	    let t0;
	    let t1;
	    let div1;
	    let t3;
	    let div2;
	    const block = {
	        c: function create() {
	            div3 = element("div");
	            div0 = element("div");
	            t0 = text(/*text*/ ctx[1]);
	            t1 = space();
	            div1 = element("div");
	            div1.textContent = "我等與眾生皆共成佛道";
	            t3 = space();
	            div2 = element("div");
	            div2.textContent = "願以此功德普及於一切";
	            attr_dev(div0, "class", "sidesponsor");
	            add_location(div0, file$4, 17, 4, 424);
	            attr_dev(div1, "class", "sidesponsortext");
	            add_location(div1, file$4, 18, 4, 466);
	            attr_dev(div2, "class", "sidesponsortext2");
	            add_location(div2, file$4, 19, 4, 516);
	            attr_dev(div3, "class", "sidepaiji");
	            attr_dev(div3, "style", sideWidth());
	            add_location(div3, file$4, 16, 0, 375);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div3, anchor);
	            append_dev(div3, div0);
	            append_dev(div0, t0);
	            append_dev(div3, t1);
	            append_dev(div3, div1);
	            append_dev(div3, t3);
	            append_dev(div3, div2);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*text*/ 2) set_data_dev(t0, /*text*/ ctx[1]);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div3);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$3.name,
	        type: "if",
	        source: "(16:0) {#if isSidePaiji() && !forceshow}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$4(ctx) {
	    let show_if;
	    let if_block_anchor;
	    function select_block_type(ctx, dirty) {
	        if (dirty & /*forceshow*/ 1) show_if = null;
	        if (show_if == null) show_if = !!(isSidePaiji() && !/*forceshow*/ ctx[0]);
	        if (show_if) return create_if_block$3;
	        if (!/*$playing*/ ctx[2]) return create_if_block_1$1;
	    }
	    let current_block_type = select_block_type(ctx, -1);
	    let if_block = current_block_type && current_block_type(ctx);
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, [dirty]) {
	            if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
	                if_block.p(ctx, dirty);
	            } else {
	                if (if_block) if_block.d(1);
	                if_block = current_block_type && current_block_type(ctx);
	                if (if_block) {
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if (if_block) {
	                if_block.d(detaching);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$4.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$4($$self, $$props, $$invalidate) {
	    let $playing;
	    let $landscape;
	    validate_store(playing, 'playing');
	    component_subscribe($$self, playing, ($$value)=>$$invalidate(2, $playing = $$value));
	    validate_store(landscape, 'landscape');
	    component_subscribe($$self, landscape, ($$value)=>$$invalidate(3, $landscape = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Paiji', slots, []);
	    let now = 0;
	    let { forceshow = false } = $$props;
	    let text = paijitexts[0];
	    let timer = setInterval(()=>{
	        $$invalidate(1, text = paijitexts[++now % paijitexts.length]);
	    }, 5000);
	    onDestroy(()=>{
	        clearInterval(timer);
	    });
	    const writable_props = [
	        'forceshow'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Paiji> was created with unknown prop '${key}'`);
	    });
	    $$self.$$set = ($$props)=>{
	        if ('forceshow' in $$props) $$invalidate(0, forceshow = $$props.forceshow);
	    };
	    $$self.$capture_state = ()=>({
	            sideWidth,
	            paijitexts,
	            folioHolderWidth,
	            landscape,
	            playing,
	            isSidePaiji,
	            onDestroy,
	            now,
	            forceshow,
	            text,
	            timer,
	            $playing,
	            $landscape
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('now' in $$props) now = $$props.now;
	        if ('forceshow' in $$props) $$invalidate(0, forceshow = $$props.forceshow);
	        if ('text' in $$props) $$invalidate(1, text = $$props.text);
	        if ('timer' in $$props) timer = $$props.timer;
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    return [
	        forceshow,
	        text,
	        $playing,
	        $landscape
	    ];
	}
	class Paiji extends SvelteComponentDev {
	    get forceshow() {
	        throw new Error("<Paiji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set forceshow(value) {
	        throw new Error("<Paiji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$4, create_fragment$4, safe_not_equal, {
	            forceshow: 0
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Paiji",
	            options,
	            id: create_fragment$4.name
	        });
	    }
	}

	const file$3 = "src\\notification.svelte";
	// (14:0) {#if msg}
	function create_if_block$2(ctx) {
	    let div;
	    let t;
	    const block = {
	        c: function create() {
	            div = element("div");
	            t = text(/*msg*/ ctx[0]);
	            attr_dev(div, "class", "notification");
	            add_location(div, file$3, 14, 0, 265);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, t);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*msg*/ 1) set_data_dev(t, /*msg*/ ctx[0]);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$2.name,
	        type: "if",
	        source: "(14:0) {#if msg}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$3(ctx) {
	    let if_block_anchor;
	    let if_block = /*msg*/ ctx[0] && create_if_block$2(ctx);
	    const block = {
	        c: function create() {
	            if (if_block) if_block.c();
	            if_block_anchor = empty();
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            if (if_block) if_block.m(target, anchor);
	            insert_dev(target, if_block_anchor, anchor);
	        },
	        p: function update(ctx, [dirty]) {
	            if (/*msg*/ ctx[0]) {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                } else {
	                    if_block = create_if_block$2(ctx);
	                    if_block.c();
	                    if_block.m(if_block_anchor.parentNode, if_block_anchor);
	                }
	            } else if (if_block) {
	                if_block.d(1);
	                if_block = null;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(if_block_anchor);
	            }
	            if (if_block) if_block.d(detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$3.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$3($$self, $$props, $$invalidate) {
	    let $notificationmessage;
	    validate_store(notificationmessage, 'notificationmessage');
	    component_subscribe($$self, notificationmessage, ($$value)=>$$invalidate(1, $notificationmessage = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Notification', slots, []);
	    let msg = '', timer;
	    const shownotification = (_msg)=>{
	        $$invalidate(0, msg = _msg);
	        clearTimeout(timer);
	        timer = setTimeout(()=>{
	            $$invalidate(0, msg = '');
	        }, 4000);
	    };
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Notification> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            notificationmessage,
	            msg,
	            timer,
	            shownotification,
	            $notificationmessage
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('msg' in $$props) $$invalidate(0, msg = $$props.msg);
	        if ('timer' in $$props) timer = $$props.timer;
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$notificationmessage*/ 2) {
	            shownotification($notificationmessage);
	        }
	    };
	    return [
	        msg,
	        $notificationmessage
	    ];
	}
	class Notification extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$3, create_fragment$3, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Notification",
	            options,
	            id: create_fragment$3.name
	        });
	    }
	}

	const file$2 = "src\\inputhelper.svelte";
	function get_each_context(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[10] = list[i];
	    return child_ctx;
	}
	function get_each_context_1(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[10] = list[i];
	    return child_ctx;
	}
	function get_each_context_2(ctx, list, i) {
	    const child_ctx = ctx.slice();
	    child_ctx[10] = list[i];
	    return child_ctx;
	}
	// (19:0) {#each starts as i}
	function create_each_block_2(ctx) {
	    let span;
	    let t_value = /*entries*/ ctx[0].get(/*i*/ ctx[10]) + " " + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler() {
	        return /*click_handler*/ ctx[6](/*i*/ ctx[10]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            add_location(span, file$2, 19, 0, 470);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*entries, starts*/ 3 && t_value !== (t_value = /*entries*/ ctx[0].get(/*i*/ ctx[10]) + " " + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block_2.name,
	        type: "each",
	        source: "(19:0) {#each starts as i}",
	        ctx
	    });
	    return block;
	}
	// (25:0) {#each ends as i}
	function create_each_block_1(ctx) {
	    let span;
	    let t_value = /*entries*/ ctx[0].get(/*i*/ ctx[10]) + " " + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler_1() {
	        return /*click_handler_1*/ ctx[7](/*i*/ ctx[10]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            add_location(span, file$2, 25, 0, 649);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler_1, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*entries, ends*/ 9 && t_value !== (t_value = /*entries*/ ctx[0].get(/*i*/ ctx[10]) + " " + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block_1.name,
	        type: "each",
	        source: "(25:0) {#each ends as i}",
	        ctx
	    });
	    return block;
	}
	// (31:0) {#each middles as i}
	function create_each_block(ctx) {
	    let span;
	    let t_value = /*entries*/ ctx[0].get(/*i*/ ctx[10]) + " " + "";
	    let t;
	    let mounted;
	    let dispose;
	    function click_handler_2() {
	        return /*click_handler_2*/ ctx[8](/*i*/ ctx[10]);
	    }
	    const block = {
	        c: function create() {
	            span = element("span");
	            t = text(t_value);
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "clickable");
	            add_location(span, file$2, 31, 0, 831);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            append_dev(span, t);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", click_handler_2, false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: function update(new_ctx, dirty) {
	            ctx = new_ctx;
	            if (dirty & /*entries, middles*/ 5 && t_value !== (t_value = /*entries*/ ctx[0].get(/*i*/ ctx[10]) + " " + "")) set_data_dev(t, t_value);
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_each_block.name,
	        type: "each",
	        source: "(31:0) {#each middles as i}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$2(ctx) {
	    let div0;
	    let t0;
	    let hr0;
	    let t1;
	    let div1;
	    let t2;
	    let hr1;
	    let t3;
	    let div2;
	    let each_value_2 = ensure_array_like_dev(/*starts*/ ctx[1]);
	    let each_blocks_2 = [];
	    for(let i = 0; i < each_value_2.length; i += 1){
	        each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	    }
	    let each_value_1 = ensure_array_like_dev(/*ends*/ ctx[3]);
	    let each_blocks_1 = [];
	    for(let i = 0; i < each_value_1.length; i += 1){
	        each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	    }
	    let each_value = ensure_array_like_dev(/*middles*/ ctx[2]);
	    let each_blocks = [];
	    for(let i = 0; i < each_value.length; i += 1){
	        each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	    }
	    const block = {
	        c: function create() {
	            div0 = element("div");
	            for(let i = 0; i < each_blocks_2.length; i += 1){
	                each_blocks_2[i].c();
	            }
	            t0 = space();
	            hr0 = element("hr");
	            t1 = space();
	            div1 = element("div");
	            for(let i = 0; i < each_blocks_1.length; i += 1){
	                each_blocks_1[i].c();
	            }
	            t2 = space();
	            hr1 = element("hr");
	            t3 = space();
	            div2 = element("div");
	            for(let i = 0; i < each_blocks.length; i += 1){
	                each_blocks[i].c();
	            }
	            attr_dev(div0, "class", "bodytext");
	            add_location(div0, file$2, 17, 0, 427);
	            add_location(hr0, file$2, 22, 0, 602);
	            attr_dev(div1, "class", "bodytext");
	            add_location(div1, file$2, 23, 0, 608);
	            add_location(hr1, file$2, 28, 0, 781);
	            attr_dev(div2, "class", "bodytext");
	            add_location(div2, file$2, 29, 0, 787);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div0, anchor);
	            for(let i = 0; i < each_blocks_2.length; i += 1){
	                if (each_blocks_2[i]) {
	                    each_blocks_2[i].m(div0, null);
	                }
	            }
	            insert_dev(target, t0, anchor);
	            insert_dev(target, hr0, anchor);
	            insert_dev(target, t1, anchor);
	            insert_dev(target, div1, anchor);
	            for(let i = 0; i < each_blocks_1.length; i += 1){
	                if (each_blocks_1[i]) {
	                    each_blocks_1[i].m(div1, null);
	                }
	            }
	            insert_dev(target, t2, anchor);
	            insert_dev(target, hr1, anchor);
	            insert_dev(target, t3, anchor);
	            insert_dev(target, div2, anchor);
	            for(let i = 0; i < each_blocks.length; i += 1){
	                if (each_blocks[i]) {
	                    each_blocks[i].m(div2, null);
	                }
	            }
	        },
	        p: function update(ctx, [dirty]) {
	            if (dirty & /*entries, starts*/ 3) {
	                each_value_2 = ensure_array_like_dev(/*starts*/ ctx[1]);
	                let i;
	                for(i = 0; i < each_value_2.length; i += 1){
	                    const child_ctx = get_each_context_2(ctx, each_value_2, i);
	                    if (each_blocks_2[i]) {
	                        each_blocks_2[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks_2[i] = create_each_block_2(child_ctx);
	                        each_blocks_2[i].c();
	                        each_blocks_2[i].m(div0, null);
	                    }
	                }
	                for(; i < each_blocks_2.length; i += 1){
	                    each_blocks_2[i].d(1);
	                }
	                each_blocks_2.length = each_value_2.length;
	            }
	            if (dirty & /*entries, ends*/ 9) {
	                each_value_1 = ensure_array_like_dev(/*ends*/ ctx[3]);
	                let i;
	                for(i = 0; i < each_value_1.length; i += 1){
	                    const child_ctx = get_each_context_1(ctx, each_value_1, i);
	                    if (each_blocks_1[i]) {
	                        each_blocks_1[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks_1[i] = create_each_block_1(child_ctx);
	                        each_blocks_1[i].c();
	                        each_blocks_1[i].m(div1, null);
	                    }
	                }
	                for(; i < each_blocks_1.length; i += 1){
	                    each_blocks_1[i].d(1);
	                }
	                each_blocks_1.length = each_value_1.length;
	            }
	            if (dirty & /*entries, middles*/ 5) {
	                each_value = ensure_array_like_dev(/*middles*/ ctx[2]);
	                let i;
	                for(i = 0; i < each_value.length; i += 1){
	                    const child_ctx = get_each_context(ctx, each_value, i);
	                    if (each_blocks[i]) {
	                        each_blocks[i].p(child_ctx, dirty);
	                    } else {
	                        each_blocks[i] = create_each_block(child_ctx);
	                        each_blocks[i].c();
	                        each_blocks[i].m(div2, null);
	                    }
	                }
	                for(; i < each_blocks.length; i += 1){
	                    each_blocks[i].d(1);
	                }
	                each_blocks.length = each_value.length;
	            }
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div0);
	                detach_dev(t0);
	                detach_dev(hr0);
	                detach_dev(t1);
	                detach_dev(div1);
	                detach_dev(t2);
	                detach_dev(hr1);
	                detach_dev(t3);
	                detach_dev(div2);
	            }
	            destroy_each(each_blocks_2, detaching);
	            destroy_each(each_blocks_1, detaching);
	            destroy_each(each_blocks, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$2.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$2($$self, $$props, $$invalidate) {
	    let $tofind;
	    validate_store(tofind, 'tofind');
	    component_subscribe($$self, tofind, ($$value)=>$$invalidate(5, $tofind = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Inputhelper', slots, []);
	    let { ptk } = $$props;
	    let entries, starts = [], middles = [], ends = [];
	    const listCandidate = (tf)=>{
	        $$invalidate(1, starts = []);
	        $$invalidate(2, middles = []);
	        $$invalidate(3, ends = []);
	        if (!tf.trim()) return;
	        if (tf.length > 4) return;
	        $$invalidate(0, entries = ptk.columns.entries.keys);
	        $$invalidate(1, starts = entries.enumStart(tf, 20));
	        $$invalidate(2, middles = entries.enumMiddle(tf, 20));
	        $$invalidate(3, ends = entries.enumEnd(tf, 20));
	    };
	    $$self.$$.on_mount.push(function() {
	        if (ptk === undefined && !('ptk' in $$props || $$self.$$.bound[$$self.$$.props['ptk']])) {
	            console.warn("<Inputhelper> was created without expected prop 'ptk'");
	        }
	    });
	    const writable_props = [
	        'ptk'
	    ];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Inputhelper> was created with unknown prop '${key}'`);
	    });
	    const click_handler = (i)=>searchable.set(entries.get(i));
	    const click_handler_1 = (i)=>searchable.set(entries.get(i));
	    const click_handler_2 = (i)=>searchable.set(entries.get(i));
	    $$self.$$set = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(4, ptk = $$props.ptk);
	    };
	    $$self.$capture_state = ()=>({
	            searchable,
	            tofind,
	            ptk,
	            entries,
	            starts,
	            middles,
	            ends,
	            listCandidate,
	            $tofind
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(4, ptk = $$props.ptk);
	        if ('entries' in $$props) $$invalidate(0, entries = $$props.entries);
	        if ('starts' in $$props) $$invalidate(1, starts = $$props.starts);
	        if ('middles' in $$props) $$invalidate(2, middles = $$props.middles);
	        if ('ends' in $$props) $$invalidate(3, ends = $$props.ends);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$tofind*/ 32) {
	            listCandidate($tofind);
	        }
	    };
	    return [
	        entries,
	        starts,
	        middles,
	        ends,
	        ptk,
	        $tofind,
	        click_handler,
	        click_handler_1,
	        click_handler_2
	    ];
	}
	class Inputhelper extends SvelteComponentDev {
	    get ptk() {
	        throw new Error("<Inputhelper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    set ptk(value) {
	        throw new Error("<Inputhelper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	    }
	    constructor(options){
	        super(options);
	        init(this, options, instance$2, create_fragment$2, safe_not_equal, {
	            ptk: 4
	        });
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Inputhelper",
	            options,
	            id: create_fragment$2.name
	        });
	    }
	}

	const file$1 = "src\\left.svelte";
	// (9:0) {#if $leftmode=='input'}
	function create_if_block$1(ctx) {
	    let inputhelper;
	    let current;
	    inputhelper = new Inputhelper({
	        props: {
	            ptk: /*ptk*/ ctx[0]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(inputhelper.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(inputhelper, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const inputhelper_changes = {};
	            if (dirty & /*ptk*/ 1) inputhelper_changes.ptk = /*ptk*/ ctx[0];
	            inputhelper.$set(inputhelper_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(inputhelper.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(inputhelper.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(inputhelper, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block$1.name,
	        type: "if",
	        source: "(9:0) {#if $leftmode=='input'}",
	        ctx
	    });
	    return block;
	}
	function create_fragment$1(ctx) {
	    let div;
	    let div_style_value;
	    let current;
	    let if_block = /*$leftmode*/ ctx[2] == 'input' && create_if_block$1(ctx);
	    const block = {
	        c: function create() {
	            div = element("div");
	            if (if_block) if_block.c();
	            attr_dev(div, "class", "left svelte-1uyqkjl");
	            attr_dev(div, "style", div_style_value = "width:" + folioHolderWidth(/*$landscape*/ ctx[1]));
	            add_location(div, file$1, 7, 0, 198);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            if (if_block) if_block.m(div, null);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            if (/*$leftmode*/ ctx[2] == 'input') {
	                if (if_block) {
	                    if_block.p(ctx, dirty);
	                    if (dirty & /*$leftmode*/ 4) {
	                        transition_in(if_block, 1);
	                    }
	                } else {
	                    if_block = create_if_block$1(ctx);
	                    if_block.c();
	                    transition_in(if_block, 1);
	                    if_block.m(div, null);
	                }
	            } else if (if_block) {
	                group_outros();
	                transition_out(if_block, 1, 1, ()=>{
	                    if_block = null;
	                });
	                check_outros();
	            }
	            if (!current || dirty & /*$landscape*/ 2 && div_style_value !== (div_style_value = "width:" + folioHolderWidth(/*$landscape*/ ctx[1]))) {
	                attr_dev(div, "style", div_style_value);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            if (if_block) if_block.d();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment$1.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	function instance$1($$self, $$props, $$invalidate) {
	    let ptk;
	    let $activePtk;
	    let $landscape;
	    let $leftmode;
	    validate_store(activePtk, 'activePtk');
	    component_subscribe($$self, activePtk, ($$value)=>$$invalidate(3, $activePtk = $$value));
	    validate_store(landscape, 'landscape');
	    component_subscribe($$self, landscape, ($$value)=>$$invalidate(1, $landscape = $$value));
	    validate_store(leftmode, 'leftmode');
	    component_subscribe($$self, leftmode, ($$value)=>$$invalidate(2, $leftmode = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('Left', slots, []);
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Left> was created with unknown prop '${key}'`);
	    });
	    $$self.$capture_state = ()=>({
	            usePtk,
	            InputHelper: Inputhelper,
	            leftmode,
	            folioHolderWidth,
	            landscape,
	            activePtk,
	            ptk,
	            $activePtk,
	            $landscape,
	            $leftmode
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('ptk' in $$props) $$invalidate(0, ptk = $$props.ptk);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$activePtk*/ 8) {
	            $$invalidate(0, ptk = usePtk($activePtk));
	        }
	    };
	    return [
	        ptk,
	        $landscape,
	        $leftmode,
	        $activePtk
	    ];
	}
	class Left extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "Left",
	            options,
	            id: create_fragment$1.name
	        });
	    }
	}

	const file = "src\\app.svelte";
	// (135:0) {:else}
	function create_else_block(ctx) {
	    let div;
	    let t0;
	    let t1;
	    let t2;
	    let a;
	    let t4;
	    let br;
	    let t5;
	    const block = {
	        c: function create() {
	            div = element("div");
	            t0 = text("永樂藏 ");
	            t1 = text(APPVER);
	            t2 = space();
	            a = element("a");
	            a.textContent = "官網";
	            t4 = space();
	            br = element("br");
	            t5 = text(/*bootmessage*/ ctx[4]);
	            attr_dev(a, "href", "https://nissaya.cn/");
	            attr_dev(a, "target", "_new");
	            add_location(a, file, 136, 13, 3934);
	            add_location(br, file, 137, 0, 3985);
	            attr_dev(div, "class", "bodytext");
	            add_location(div, file, 135, 0, 3898);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            append_dev(div, t0);
	            append_dev(div, t1);
	            append_dev(div, t2);
	            append_dev(div, a);
	            append_dev(div, t4);
	            append_dev(div, br);
	            append_dev(div, t5);
	        },
	        p: function update(ctx, dirty) {
	            if (dirty & /*bootmessage*/ 16) set_data_dev(t5, /*bootmessage*/ ctx[4]);
	        },
	        i: noop,
	        o: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_else_block.name,
	        type: "else",
	        source: "(135:0) {:else}",
	        ctx
	    });
	    return block;
	}
	// (112:0) {#if loaded}
	function create_if_block(ctx) {
	    let t0;
	    let previous_key = /*$activefolioid*/ ctx[9];
	    let t1;
	    let t2;
	    let t3;
	    let t4;
	    let t5;
	    let player;
	    let t6;
	    let notification;
	    let current;
	    let if_block0 = /*$showpaiji*/ ctx[8] && !/*showpopup*/ ctx[5] && !/*shownewbie*/ ctx[6] && !/*$landscape*/ ctx[0] && /*$showsponsor*/ ctx[7] == 'on' && create_if_block_5(ctx);
	    let key_block = create_key_block(ctx);
	    let if_block1 = /*$leftmode*/ ctx[10] !== 'folio' && create_if_block_4(ctx);
	    let if_block2 = /*shownewbie*/ (ctx[6] || /*showpopup*/ ctx[5]) && !/*$landscape*/ ctx[0] && create_if_block_3(ctx);
	    let if_block3 = /*showpopup*/ (ctx[5] || /*$landscape*/ ctx[0]) && create_if_block_2(ctx);
	    let if_block4 = /*shownewbie*/ ctx[6] && create_if_block_1(ctx);
	    player = new Player({
	        $$inline: true
	    });
	    notification = new Notification({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            if (if_block0) if_block0.c();
	            t0 = space();
	            key_block.c();
	            t1 = space();
	            if (if_block1) if_block1.c();
	            t2 = space();
	            if (if_block2) if_block2.c();
	            t3 = space();
	            if (if_block3) if_block3.c();
	            t4 = space();
	            if (if_block4) if_block4.c();
	            t5 = space();
	            create_component(player.$$.fragment);
	            t6 = space();
	            create_component(notification.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            if (if_block0) if_block0.m(target, anchor);
	            insert_dev(target, t0, anchor);
	            key_block.m(target, anchor);
	            insert_dev(target, t1, anchor);
	            if (if_block1) if_block1.m(target, anchor);
	            insert_dev(target, t2, anchor);
	            if (if_block2) if_block2.m(target, anchor);
	            insert_dev(target, t3, anchor);
	            if (if_block3) if_block3.m(target, anchor);
	            insert_dev(target, t4, anchor);
	            if (if_block4) if_block4.m(target, anchor);
	            insert_dev(target, t5, anchor);
	            mount_component(player, target, anchor);
	            insert_dev(target, t6, anchor);
	            mount_component(notification, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            if (/*$showpaiji*/ ctx[8] && !/*showpopup*/ ctx[5] && !/*shownewbie*/ ctx[6] && !/*$landscape*/ ctx[0] && /*$showsponsor*/ ctx[7] == 'on') {
	                if (if_block0) {
	                    if (dirty & /*$showpaiji, showpopup, shownewbie, $landscape, $showsponsor*/ 481) {
	                        transition_in(if_block0, 1);
	                    }
	                } else {
	                    if_block0 = create_if_block_5(ctx);
	                    if_block0.c();
	                    transition_in(if_block0, 1);
	                    if_block0.m(t0.parentNode, t0);
	                }
	            } else if (if_block0) {
	                group_outros();
	                transition_out(if_block0, 1, 1, ()=>{
	                    if_block0 = null;
	                });
	                check_outros();
	            }
	            if (dirty & /*$activefolioid*/ 512 && safe_not_equal(previous_key, previous_key = /*$activefolioid*/ ctx[9])) {
	                group_outros();
	                transition_out(key_block, 1, 1, noop);
	                check_outros();
	                key_block = create_key_block(ctx);
	                key_block.c();
	                transition_in(key_block, 1);
	                key_block.m(t1.parentNode, t1);
	            } else {
	                key_block.p(ctx, dirty);
	            }
	            if (/*$leftmode*/ ctx[10] !== 'folio') {
	                if (if_block1) {
	                    if (dirty & /*$leftmode*/ 1024) {
	                        transition_in(if_block1, 1);
	                    }
	                } else {
	                    if_block1 = create_if_block_4(ctx);
	                    if_block1.c();
	                    transition_in(if_block1, 1);
	                    if_block1.m(t2.parentNode, t2);
	                }
	            } else if (if_block1) {
	                group_outros();
	                transition_out(if_block1, 1, 1, ()=>{
	                    if_block1 = null;
	                });
	                check_outros();
	            }
	            if (/*shownewbie*/ (ctx[6] || /*showpopup*/ ctx[5]) && !/*$landscape*/ ctx[0]) {
	                if (if_block2) {
	                    if_block2.p(ctx, dirty);
	                } else {
	                    if_block2 = create_if_block_3(ctx);
	                    if_block2.c();
	                    if_block2.m(t3.parentNode, t3);
	                }
	            } else if (if_block2) {
	                if_block2.d(1);
	                if_block2 = null;
	            }
	            if (/*showpopup*/ ctx[5] || /*$landscape*/ ctx[0]) {
	                if (if_block3) {
	                    if_block3.p(ctx, dirty);
	                    if (dirty & /*showpopup, $landscape*/ 33) {
	                        transition_in(if_block3, 1);
	                    }
	                } else {
	                    if_block3 = create_if_block_2(ctx);
	                    if_block3.c();
	                    transition_in(if_block3, 1);
	                    if_block3.m(t4.parentNode, t4);
	                }
	            } else if (if_block3) {
	                group_outros();
	                transition_out(if_block3, 1, 1, ()=>{
	                    if_block3 = null;
	                });
	                check_outros();
	            }
	            if (/*shownewbie*/ ctx[6]) {
	                if (if_block4) {
	                    if_block4.p(ctx, dirty);
	                    if (dirty & /*shownewbie*/ 64) {
	                        transition_in(if_block4, 1);
	                    }
	                } else {
	                    if_block4 = create_if_block_1(ctx);
	                    if_block4.c();
	                    transition_in(if_block4, 1);
	                    if_block4.m(t5.parentNode, t5);
	                }
	            } else if (if_block4) {
	                group_outros();
	                transition_out(if_block4, 1, 1, ()=>{
	                    if_block4 = null;
	                });
	                check_outros();
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block0);
	            transition_in(key_block);
	            transition_in(if_block1);
	            transition_in(if_block3);
	            transition_in(if_block4);
	            transition_in(player.$$.fragment, local);
	            transition_in(notification.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block0);
	            transition_out(key_block);
	            transition_out(if_block1);
	            transition_out(if_block3);
	            transition_out(if_block4);
	            transition_out(player.$$.fragment, local);
	            transition_out(notification.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(t0);
	                detach_dev(t1);
	                detach_dev(t2);
	                detach_dev(t3);
	                detach_dev(t4);
	                detach_dev(t5);
	                detach_dev(t6);
	            }
	            if (if_block0) if_block0.d(detaching);
	            key_block.d(detaching);
	            if (if_block1) if_block1.d(detaching);
	            if (if_block2) if_block2.d(detaching);
	            if (if_block3) if_block3.d(detaching);
	            if (if_block4) if_block4.d(detaching);
	            destroy_component(player, detaching);
	            destroy_component(notification, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block.name,
	        type: "if",
	        source: "(112:0) {#if loaded}",
	        ctx
	    });
	    return block;
	}
	// (113:0) {#if $showpaiji && !showpopup && !shownewbie && !$landscape && $showsponsor=='on'}
	function create_if_block_5(ctx) {
	    let paiji;
	    let current;
	    paiji = new Paiji({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(paiji.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(paiji, target, anchor);
	            current = true;
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(paiji.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(paiji.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(paiji, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_5.name,
	        type: "if",
	        source: "(113:0) {#if $showpaiji && !showpopup && !shownewbie && !$landscape && $showsponsor=='on'}",
	        ctx
	    });
	    return block;
	}
	// (117:0) {#key $activefolioid}
	function create_key_block(ctx) {
	    let swipezipimage;
	    let current;
	    swipezipimage = new Swipezipimage({
	        props: {
	            src: /*$activefolioid*/ ctx[9] + ".zip",
	            onTapText: /*onTapText*/ ctx[13],
	            onMainmenu: /*onMainmenu*/ ctx[12]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(swipezipimage.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(swipezipimage, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const swipezipimage_changes = {};
	            if (dirty & /*$activefolioid*/ 512) swipezipimage_changes.src = /*$activefolioid*/ ctx[9] + ".zip";
	            swipezipimage.$set(swipezipimage_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(swipezipimage.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(swipezipimage.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(swipezipimage, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_key_block.name,
	        type: "key",
	        source: "(117:0) {#key $activefolioid}",
	        ctx
	    });
	    return block;
	}
	// (121:0) {#if $leftmode!=='folio'}
	function create_if_block_4(ctx) {
	    let left;
	    let current;
	    left = new Left({
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(left.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(left, target, anchor);
	            current = true;
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(left.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(left.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(left, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_4.name,
	        type: "if",
	        source: "(121:0) {#if $leftmode!=='folio'}",
	        ctx
	    });
	    return block;
	}
	// (124:0) {#if (shownewbie||showpopup) && !$landscape}
	function create_if_block_3(ctx) {
	    let span;
	    let mounted;
	    let dispose;
	    const block = {
	        c: function create() {
	            span = element("span");
	            span.textContent = "✖️";
	            attr_dev(span, "aria-hidden", "true");
	            attr_dev(span, "class", "closepopup");
	            add_location(span, file, 124, 0, 3658);
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, span, anchor);
	            if (!mounted) {
	                dispose = listen_dev(span, "click", /*closePopup*/ ctx[11], false, false, false, false);
	                mounted = true;
	            }
	        },
	        p: noop,
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(span);
	            }
	            mounted = false;
	            dispose();
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_3.name,
	        type: "if",
	        source: "(124:0) {#if (shownewbie||showpopup) && !$landscape}",
	        ctx
	    });
	    return block;
	}
	// (127:0) {#if showpopup || $landscape}
	function create_if_block_2(ctx) {
	    let taptext;
	    let current;
	    taptext = new Taptext({
	        props: {
	            tofind: /*tofind*/ ctx[1],
	            closePopup: /*closePopup*/ ctx[11]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(taptext.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(taptext, target, anchor);
	            current = true;
	        },
	        p: function update(ctx, dirty) {
	            const taptext_changes = {};
	            if (dirty & /*tofind*/ 2) taptext_changes.tofind = /*tofind*/ ctx[1];
	            taptext.$set(taptext_changes);
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(taptext.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(taptext.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(taptext, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_2.name,
	        type: "if",
	        source: "(127:0) {#if showpopup || $landscape}",
	        ctx
	    });
	    return block;
	}
	// (130:0) {#if shownewbie}
	function create_if_block_1(ctx) {
	    let newbie_1;
	    let current;
	    newbie_1 = new Newbie({
	        props: {
	            closePopup: /*closePopup*/ ctx[11]
	        },
	        $$inline: true
	    });
	    const block = {
	        c: function create() {
	            create_component(newbie_1.$$.fragment);
	        },
	        m: function mount(target, anchor) {
	            mount_component(newbie_1, target, anchor);
	            current = true;
	        },
	        p: noop,
	        i: function intro(local) {
	            if (current) return;
	            transition_in(newbie_1.$$.fragment, local);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(newbie_1.$$.fragment, local);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            destroy_component(newbie_1, detaching);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_if_block_1.name,
	        type: "if",
	        source: "(130:0) {#if shownewbie}",
	        ctx
	    });
	    return block;
	}
	function create_fragment(ctx) {
	    let div;
	    let current_block_type_index;
	    let if_block;
	    let current;
	    const if_block_creators = [
	        create_if_block,
	        create_else_block
	    ];
	    const if_blocks = [];
	    function select_block_type(ctx, dirty) {
	        if (/*loaded*/ ctx[3]) return 0;
	        return 1;
	    }
	    current_block_type_index = select_block_type(ctx);
	    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    const block = {
	        c: function create() {
	            div = element("div");
	            if_block.c();
	            attr_dev(div, "class", "app");
	            add_location(div, file, 110, 0, 3325);
	        },
	        l: function claim(nodes) {
	            throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	        },
	        m: function mount(target, anchor) {
	            insert_dev(target, div, anchor);
	            if_blocks[current_block_type_index].m(div, null);
	            /*div_binding*/ ctx[14](div);
	            current = true;
	        },
	        p: function update(ctx, [dirty]) {
	            let previous_block_index = current_block_type_index;
	            current_block_type_index = select_block_type(ctx);
	            if (current_block_type_index === previous_block_index) {
	                if_blocks[current_block_type_index].p(ctx, dirty);
	            } else {
	                group_outros();
	                transition_out(if_blocks[previous_block_index], 1, 1, ()=>{
	                    if_blocks[previous_block_index] = null;
	                });
	                check_outros();
	                if_block = if_blocks[current_block_type_index];
	                if (!if_block) {
	                    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	                    if_block.c();
	                } else {
	                    if_block.p(ctx, dirty);
	                }
	                transition_in(if_block, 1);
	                if_block.m(div, null);
	            }
	        },
	        i: function intro(local) {
	            if (current) return;
	            transition_in(if_block);
	            current = true;
	        },
	        o: function outro(local) {
	            transition_out(if_block);
	            current = false;
	        },
	        d: function destroy(detaching) {
	            if (detaching) {
	                detach_dev(div);
	            }
	            if_blocks[current_block_type_index].d();
	            /*div_binding*/ ctx[14](null);
	        }
	    };
	    dispatch_dev("SvelteRegisterBlock", {
	        block,
	        id: create_fragment.name,
	        type: "component",
	        source: "",
	        ctx
	    });
	    return block;
	}
	const idleinterval = 2;
	function instance($$self, $$props, $$invalidate) {
	    let $landscape;
	    let $newbie;
	    let $idlecount;
	    let $showsponsor;
	    let $showpaiji;
	    let $activefolioid;
	    let $leftmode;
	    validate_store(landscape, 'landscape');
	    component_subscribe($$self, landscape, ($$value)=>$$invalidate(0, $landscape = $$value));
	    validate_store(newbie, 'newbie');
	    component_subscribe($$self, newbie, ($$value)=>$$invalidate(16, $newbie = $$value));
	    validate_store(idlecount, 'idlecount');
	    component_subscribe($$self, idlecount, ($$value)=>$$invalidate(17, $idlecount = $$value));
	    validate_store(showsponsor, 'showsponsor');
	    component_subscribe($$self, showsponsor, ($$value)=>$$invalidate(7, $showsponsor = $$value));
	    validate_store(showpaiji, 'showpaiji');
	    component_subscribe($$self, showpaiji, ($$value)=>$$invalidate(8, $showpaiji = $$value));
	    validate_store(activefolioid, 'activefolioid');
	    component_subscribe($$self, activefolioid, ($$value)=>$$invalidate(9, $activefolioid = $$value));
	    validate_store(leftmode, 'leftmode');
	    component_subscribe($$self, leftmode, ($$value)=>$$invalidate(10, $leftmode = $$value));
	    let { $$slots: slots = {}, $$scope } = $$props;
	    validate_slots('App', slots, []);
	    let tofind;
	    registerServiceWorker();
	    isAndroid.set(!!navigator.userAgent.match(/Android/i));
	    const handleConnection = ()=>{
	        online.set(navigator.onLine || location.hostname == '127.0.0.1' || location.hostname == 'localhost');
	    };
	    window.addEventListener('online', handleConnection);
	    window.addEventListener('offline', handleConnection);
	    let app;
	    let loaded = false, timer, bootmessage = '啟動中';
	    onDestroy(()=>clearInterval(timer));
	    const installptk = async (name)=>{
	        $$invalidate(4, bootmessage = 'try to download ' + name + '.ptk');
	        const res = await downloadToCache(CacheName, name + '.ptk', (msg)=>{
	            $$invalidate(4, bootmessage = name + '.ptk ' + msg);
	        });
	        const buf = await res.arrayBuffer();
	        const ptk = await openPtk(name, new Uint8Array(buf));
	        enableAccelon23Features(ptk);
	        return ptk;
	    };
	    const init = async ()=>{
	        documentHeight();
	        const toload = await ptkInCache(CacheName);
	        for(let i = 0; i < ptks.length; i++){
	            if (!~toload.indexOf(ptks[i])) {
	                toload.push(ptks[i]);
	            }
	        }
	        for(let i = 0; i < toload.length; i++){
	            const ptk = await installptk(toload[i]);
	            $$invalidate(4, bootmessage = 'open ptk ' + toload[i]);
	            //if (ptks[i]=='ylz-prjn') console.log(ptk)
	            if (toload[i] == 'dc') setTimestampPtk(ptk);
	        }
	        $$invalidate(4, bootmessage = 'fetching foliolist from cache');
	        await fetchFolioList(folioincache);
	        $$invalidate(4, bootmessage = 'load folio address from url');
	        let addr = addressFromUrl();
	        if (!~addr.indexOf('bk')) {
	            addr = localStorage.getItem(AppPrefix + 'homeurl') || '';
	        }
	        await loadAddress(addr);
	        $$invalidate(4, bootmessage = 'loaded');
	        $$invalidate(3, loaded = true);
	        timer = setInterval(()=>{
	            showpaiji.set($idlecount >= idletime);
	            if (!shownewbie && !showpopup && $showsponsor == 'on') {
	                idlecount.set($idlecount + idleinterval);
	            }
	        }, idleinterval * 1000);
	    };
	    let showpopup = false, shownewbie = $newbie == 'on';
	    const closePopup = ()=>{
	        $$invalidate(6, shownewbie = false);
	        if (get_store_value(landscape)) return;
	        $$invalidate(5, showpopup = false);
	    };
	    const onMainmenu = ()=>{
	        $$invalidate(5, showpopup = false);
	    };
	    const onTapText = (t)=>{
	        $$invalidate(5, showpopup = true);
	        if (typeof t == 'string') $$invalidate(1, tofind = t);
	    };
	    const orientation = (ls)=>{
	        $$invalidate(5, showpopup = false);
	        if (ls) $$invalidate(6, shownewbie = false);
	        idlecount.set(0);
	    };
	    // $: console.log(sidepaiji,idletime,$idlecount,$showpaiji,$playing,showpopup)
	    setTimeout(init, 500);
	    const writable_props = [];
	    Object.keys($$props).forEach((key)=>{
	        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
	    });
	    function div_binding($$value) {
	        binding_callbacks[$$value ? 'unshift' : 'push'](()=>{
	            app = $$value;
	            $$invalidate(2, app);
	        });
	    }
	    $$self.$capture_state = ()=>({
	            openPtk,
	            addressFromUrl,
	            enableAccelon23Features,
	            SwipeZipImage: Swipezipimage,
	            registerServiceWorker,
	            downloadToCache,
	            ptkInCache,
	            onDestroy,
	            activefolioid,
	            isAndroid,
	            idlecount,
	            showpaiji,
	            leftmode,
	            online,
	            folioincache,
	            showsponsor,
	            newbie,
	            idletime,
	            landscape,
	            ptks,
	            CacheName,
	            APPVER,
	            documentHeight,
	            setTimestampPtk,
	            fetchFolioList,
	            TapText: Taptext,
	            Player,
	            Newbie,
	            Paiji,
	            Notification,
	            get: get_store_value,
	            Left,
	            loadAddress,
	            AppPrefix,
	            tofind,
	            idleinterval,
	            handleConnection,
	            app,
	            loaded,
	            timer,
	            bootmessage,
	            installptk,
	            init,
	            showpopup,
	            shownewbie,
	            closePopup,
	            onMainmenu,
	            onTapText,
	            orientation,
	            $landscape,
	            $newbie,
	            $idlecount,
	            $showsponsor,
	            $showpaiji,
	            $activefolioid,
	            $leftmode
	        });
	    $$self.$inject_state = ($$props)=>{
	        if ('tofind' in $$props) $$invalidate(1, tofind = $$props.tofind);
	        if ('app' in $$props) $$invalidate(2, app = $$props.app);
	        if ('loaded' in $$props) $$invalidate(3, loaded = $$props.loaded);
	        if ('timer' in $$props) timer = $$props.timer;
	        if ('bootmessage' in $$props) $$invalidate(4, bootmessage = $$props.bootmessage);
	        if ('showpopup' in $$props) $$invalidate(5, showpopup = $$props.showpopup);
	        if ('shownewbie' in $$props) $$invalidate(6, shownewbie = $$props.shownewbie);
	    };
	    if ($$props && "$$inject" in $$props) {
	        $$self.$inject_state($$props.$$inject);
	    }
	    $$self.$$.update = ()=>{
	        if ($$self.$$.dirty & /*$landscape*/ 1) {
	            orientation($landscape);
	        }
	    };
	    return [
	        $landscape,
	        tofind,
	        app,
	        loaded,
	        bootmessage,
	        showpopup,
	        shownewbie,
	        $showsponsor,
	        $showpaiji,
	        $activefolioid,
	        $leftmode,
	        closePopup,
	        onMainmenu,
	        onTapText,
	        div_binding
	    ];
	}
	class App extends SvelteComponentDev {
	    constructor(options){
	        super(options);
	        init(this, options, instance, create_fragment, safe_not_equal, {});
	        dispatch_dev("SvelteRegisterComponent", {
	            component: this,
	            tagName: "App",
	            options,
	            id: create_fragment.name
	        });
	    }
	}

	const app = new App({
	    target: document.body
	});
	document.querySelector("#bootmessage").innerHTML = '';

	return app;

})();
//# sourceMappingURL=index.js.map
